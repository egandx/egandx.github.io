<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Go Map扩容</title>
      <link href="2022/10/24/Go_Map_Grow/"/>
      <url>2022/10/24/Go_Map_Grow/</url>
      
        <content type="html"><![CDATA[<p>在使用slice的时候，如果向slice中追加元素的时候，导致元素数量大于cap，这时候就会发生slice的扩容。那么在go语言中，什么时候map会发生扩容呢？扩容的策略有哪些呢？扩容的过程是怎样的呢？很是好奇，心动不如行动。开始学习，又是收获满满的一天。</p><span id="more"></span><h2 id="0x0-触发扩容的条件"><a href="#0x0-触发扩容的条件" class="headerlink" title="0x0.触发扩容的条件"></a>0x0.触发扩容的条件</h2><p>众所周知，map是使用hash表的。使用hash表的目的就是追求更加快速的找到key，但是当map中key的数量逐渐增加，逐渐离谱的时候，那么碰撞的几率就越来越大，效率也就随之下降了。最离谱的时候就是所有的key都在一个bucket里面 (<del>这是碳基生物能干出来的事?这和链表有个锤子的区别吗？</del>)，最好就是一个bucket里面就一个key，找到了bucket就找到了key，效率贼高，直接拉到o(1)。但是空间不允许啊，为了效率用空间换时间不寒碜？(<del>很寒碜，贼TM寒碜</del>)。</p><p>最好最坏都属于极端，其实都很难遇到，只是在举🌰的时候夸张表述才会用到。在go语言中，有一个<code>loadFactor</code>指标来对上面的两种情况进行衡量。废话不多说，直接上源码(/go1.18.2/src/runtime/map.go)</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断条件在mapassign函数中。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// If we hit the max load factor or we have too many overflow buckets,</span></span><br><span class="line"><span class="comment">// and we&#x27;re not already in the middle of growing, start growing.</span></span><br><span class="line"><span class="keyword">if</span> !h.growing() &amp;&amp; (overLoadFactor(h.count+<span class="number">1</span>, h.B) || tooManyOverflowBuckets(h.noverflow, h.B)) &#123;</span><br><span class="line">hashGrow(t, h)</span><br><span class="line"><span class="keyword">goto</span> again <span class="comment">// Growing the table invalidates everything, so try again</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的条件可以看出，map扩容一个是在<code>overLoadFactor</code>的时候，一个是在<code>tooManyOverflowBuckets</code>。下面是这两个函数所用到的常量以及主要的引用函数。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line"><span class="comment">// Maximum number of key/elem pairs a bucket can hold.</span></span><br><span class="line">bucketCntBits = <span class="number">3</span></span><br><span class="line">bucketCnt     = <span class="number">1</span> &lt;&lt; bucketCntBits <span class="comment">//8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Maximum average load of a bucket that triggers growth is 6.5.</span></span><br><span class="line"><span class="comment">// Represent as loadFactorNum/loadFactorDen, to allow integer math.</span></span><br><span class="line">loadFactorNum = <span class="number">13</span></span><br><span class="line">loadFactorDen = <span class="number">2</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// PtrSize is the size of a pointer in bytes - unsafe.Sizeof(uintptr(0)) but as an ideal constant.</span></span><br><span class="line"><span class="comment">// It is also the size of the machine&#x27;s native word size (that is, 4 on 32-bit systems, 8 on 64-bit).</span></span><br><span class="line"><span class="keyword">const</span> PtrSize = <span class="number">4</span> &lt;&lt; (^<span class="keyword">uintptr</span>(<span class="number">0</span>) &gt;&gt; <span class="number">63</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// bucketShift returns 1&lt;&lt;b, optimized for code generation.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bucketShift</span><span class="params">(b <span class="keyword">uint8</span>)</span> <span class="title">uintptr</span></span> &#123;</span><br><span class="line"><span class="comment">// Masking the shift amount allows overflow checks to be elided.</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">uintptr</span>(<span class="number">1</span>) &lt;&lt; (b &amp; (goarch.PtrSize*<span class="number">8</span> - <span class="number">1</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// overLoadFactor reports whether count items placed in 1&lt;&lt;B buckets is over loadFactor.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">overLoadFactor</span><span class="params">(count <span class="keyword">int</span>, B <span class="keyword">uint8</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> count &gt; bucketCnt &amp;&amp; <span class="keyword">uintptr</span>(count) &gt; loadFactorNum*(bucketShift(B)/loadFactorDen)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// tooManyOverflowBuckets reports whether noverflow buckets is too many for a map with 1&lt;&lt;B buckets.</span></span><br><span class="line"><span class="comment">// Note that most of these overflow buckets must be in sparse use;</span></span><br><span class="line"><span class="comment">// if use was dense, then we&#x27;d have already triggered regular map growth.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tooManyOverflowBuckets</span><span class="params">(noverflow <span class="keyword">uint16</span>, B <span class="keyword">uint8</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="comment">// If the threshold is too low, we do extraneous work.</span></span><br><span class="line"><span class="comment">// If the threshold is too high, maps that grow and shrink can hold on to lots of unused memory.</span></span><br><span class="line"><span class="comment">// &quot;too many&quot; means (approximately) as many overflow buckets as regular buckets.</span></span><br><span class="line"><span class="comment">// See incrnoverflow for more details.</span></span><br><span class="line"><span class="keyword">if</span> B &gt; <span class="number">15</span> &#123;</span><br><span class="line">B = <span class="number">15</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// The compiler doesn&#x27;t see here that B &lt; 16; mask B to generate shorter shift code.</span></span><br><span class="line"><span class="keyword">return</span> noverflow &gt;= <span class="keyword">uint16</span>(<span class="number">1</span>)&lt;&lt;(B&amp;<span class="number">15</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1）第一种情况"><a href="#1）第一种情况" class="headerlink" title="1）第一种情况"></a>1）第一种情况</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// overLoadFactor reports whether count items placed in 1&lt;&lt;B buckets is over loadFactor.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">overLoadFactor</span><span class="params">(count <span class="keyword">int</span>, B <span class="keyword">uint8</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">  <span class="comment">// 换算一下下: count &gt; 8 &amp;&amp; count &gt; 13*((2^B)/2)</span></span><br><span class="line">  <span class="comment">// loadFactor = count/(2^B) &gt; 6.5</span></span><br><span class="line"><span class="keyword">return</span> count &gt; bucketCnt &amp;&amp; <span class="keyword">uintptr</span>(count) &gt; loadFactorNum*(bucketShift(B)/loadFactorDen)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>count</code>是map的元素个数，<code>1&lt;&lt;B</code>表示bucket数组长度。也就是说<font color=red>在<code>loadFactor := count/(2^B)</code>超过6.5的时候，会触发map的扩容</font>。按照<code>loadFactor</code>的计算方式，当所有bucket都满的时候是8。达到6.5的时候也就差不多算是满了大半了，无论查找还是插入，这个时候碰撞的几率很高，效率也会下降的厉害，所以这是触发扩容的时机。</p><p>如果不停的插入元素、删除元素，然后在插入元素。刚开始插入元素的时候会创建大量bucket。但是只要没有达到第一种扩容情况，也就是说loadFactor的值低于6.5。这个时候进行删除元素的操作，降低loadFactor的分子。然后重复操作，就会产生大量overflow bucket。这个时候key就会过于分散，导致查找和插入的效率过低。为了避免这种情况的发生，就有了下面第二种触发扩容的条件。</p><h3 id="2-第二种情况"><a href="#2-第二种情况" class="headerlink" title="2) 第二种情况"></a>2) 第二种情况</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// tooManyOverflowBuckets reports whether noverflow buckets is too many for a map with 1&lt;&lt;B buckets.</span></span><br><span class="line"><span class="comment">// Note that most of these overflow buckets must be in sparse use;</span></span><br><span class="line"><span class="comment">// if use was dense, then we&#x27;d have already triggered regular map growth.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tooManyOverflowBuckets</span><span class="params">(noverflow <span class="keyword">uint16</span>, B <span class="keyword">uint8</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="comment">// If the threshold is too low, we do extraneous work.</span></span><br><span class="line"><span class="comment">// If the threshold is too high, maps that grow and shrink can hold on to lots of unused memory.</span></span><br><span class="line"><span class="comment">// &quot;too many&quot; means (approximately) as many overflow buckets as regular buckets.</span></span><br><span class="line"><span class="comment">// See incrnoverflow for more details.</span></span><br><span class="line"><span class="keyword">if</span> B &gt; <span class="number">15</span> &#123;</span><br><span class="line">B = <span class="number">15</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// The compiler doesn&#x27;t see here that B &lt; 16; mask B to generate shorter shift code.</span></span><br><span class="line"><span class="keyword">return</span> noverflow &gt;= <span class="keyword">uint16</span>(<span class="number">1</span>)&lt;&lt;(B&amp;<span class="number">15</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>翻译成人话：overflow的bucket数量太多了。<font color=red>当<code>B &gt;= 15</code>的时候，如果overflow的bucket数量超过<code>2^15</code>就触发扩容；当<code>B &lt; 15</code>的时候，如果overflow的bucket数量超过<code>2^B</code>就触发扩容。</font>第二种的这个情况主要是为了避免loadFactor的分子小的时候，却有大量的bucket(包括大量的overflow bucket)。</p><h2 id="0x1-扩容策略"><a href="#0x1-扩容策略" class="headerlink" title="0x1.扩容策略"></a>0x1.扩容策略</h2><p>针对两种不同的触发扩容的条件，进行扩容的策略也有所不同。</p><p>第一种情况是由于元素数量过多，导致了bucket数组快满了。这个时候采用的扩容策略就是<code>B+1</code>，bucket的数组长度变成之前的2倍（<font color=red>2倍扩容</font>）</p><p>第二种情况是由于flowbucket的过多造成，元素没有那么多，主要是位置分散，造成查找和插入的效率较低。采用第一种的扩容策略肯定是不行的，解决的办法是采用<font color=red>等量扩容</font>，创建一个和老buckets数组相同长度的新buckets数组。将老buckets中处于同一个bucket的元素进行紧密排列，尽可能的消除overflow bucket，节省空间，提高效率。</p><p>map的扩容不是原子操作，不会一步到位。扩容需要将原本的键值对迁移到新bucket得内存地址中，大量键值对同时迁移会影响性能，所以Go map的扩容是采用“渐进式”方式。每次最多只会迁移2个bucket。</p><h2 id="0x2-迁移过程"><a href="#0x2-迁移过程" class="headerlink" title="0x2.迁移过程"></a>0x2.迁移过程</h2><p>第一种扩容策略，因为<code>B+1</code>会导致key的hash值需要重新计算，才能确定它会落入那个bucket中，毕竟确定bucket位置的是根据hash值的后B位。这样的话就会导致某些key在迁移前后的bucket序号是不一样的。</p><p>举个🌰：初始状态下B=2，3号bucket里有两个key的hash值后3位值<code>011,111</code>，经过B+1扩容之后，这两个原本处于3号bucket的key会分别落入3号和7号bucket。key在迁移前后是否还是处于原本的bucket取决于倒数第3位是0还是1。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">                     ┌───────────────────────┐</span><br><span class="line">                     │                       │</span><br><span class="line">               ┌─────┼─────────────────┐     │</span><br><span class="line">               │     │                 │     │</span><br><span class="line">         ┌─────┼─────┼───────────┐     │     │</span><br><span class="line">         │     │     │           │     │     │</span><br><span class="line">   ┌─────┼─────┼─────┼─────┐     │     │     │</span><br><span class="line">   │     │     │     │     │     │     │     │</span><br><span class="line">┌──┴──┬──┴──┬──┴──┬──┴──┐  │     │     │     │</span><br><span class="line">│     │     │     │     │  │     │     │     │</span><br><span class="line">│  0  │  1  │  2  │  3  │  │     │     │     │</span><br><span class="line">│     │     │     │     │  │     │     │     │</span><br><span class="line">└──┬──┴──┬──┴──┬──┴──┬──┘  │     │     │     │</span><br><span class="line">   │     │     │     │     │     │     │     │</span><br><span class="line">   │     │     │     │     │     │     │     │</span><br><span class="line">   │     │     │     │     │     │     │     │</span><br><span class="line">   │     │     │     │     │     │     │     │</span><br><span class="line">   ▼     ▼     ▼     ▼     ▼     ▼     ▼     ▼</span><br><span class="line">┌─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┐</span><br><span class="line">│     │     │     │     │     │     │     │     │</span><br><span class="line">│  0  │  1  │  2  │  3  │  4  │  5  │  6  │  7  │</span><br><span class="line">│     │     │     │     │     │     │     │     │</span><br><span class="line">└─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┘</span><br></pre></td></tr></table></figure><p>第二种扩容策略，等量扩容因为B是不变的，所以key还是在原来的bucket。主要是为了收拢过于分散的key(<font color=linblue>大多数都分散在overflow bucket中</font>)。下面的图是迁移完成的情况。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">buckets     B&#x3D;2                         buckets     B&#x3D;2</span><br><span class="line">┌─────┬─────┬─────┬─────┐               ┌─────┬─────┬─────┬─────┐</span><br><span class="line">│     │     │     │     │               │     │     │     │     │</span><br><span class="line">│  0  │  1  │  2  │  3  │               │  0  │  1  │  2  │  3  │</span><br><span class="line">│     │     │     │     │               │     │     │     │     │</span><br><span class="line">└─────┴─────┴─────┴──┬──┘               └─────┴─────┴─────┴──┬──┘</span><br><span class="line">                     │                                       │</span><br><span class="line">   ┌─────────────────┘                               ┌───────┘</span><br><span class="line">   │                                                 │</span><br><span class="line">   ▼                                                 ▼</span><br><span class="line">┌────┐      ┌────┐     ┌────┐                     ┌────┐</span><br><span class="line">│bmap│   ┌─►│bmap│  ┌─►│bmap│                     │bmap│</span><br><span class="line">├────┴┐  │  ├────┴┐ │  ├────┴┐                    ├────┴┐</span><br><span class="line">│key:a│  │  │     │ │  │key:f│                    │key:a│</span><br><span class="line">│ 111 │  │  │     │ │  │ 111 │                    │ 111 │</span><br><span class="line">├─────┤  │  ├─────┤ │  ├─────┤                    ├─────┤</span><br><span class="line">│key:b│  │  │     │ │  │     │                    │key:b│</span><br><span class="line">│ 011 │  │  │     │ │  │     │                    │ 011 │</span><br><span class="line">├─────┤  │  ├─────┤ │  ├─────┤                    ├─────┤</span><br><span class="line">│     │  │  │key:d│ │  │     │                    │key:c│</span><br><span class="line">│     │  │  │ 111 │ │  │     │                    │ 011 │</span><br><span class="line">├─────┤  │  ├─────┤ │  ├─────┤                    ├─────┤</span><br><span class="line">│     │  │  │     │ │  │     │                    │key:d│</span><br><span class="line">│     │  │  │     │ │  │     │                    │ 111 │</span><br><span class="line">├─────┤  │  ├─────┤ │  ├─────┤                    ├─────┤</span><br><span class="line">│key:c│  │  │key:e│ │  │     │                    │key:e│</span><br><span class="line">│ 011 │  │  │ 111 │ │  │     │                    │ 111 │</span><br><span class="line">├─────┤  │  ├─────┤ │  ├─────┤                    ├─────┤</span><br><span class="line">│     │  │  │     │ │  │key:g│                    │key:f│</span><br><span class="line">│     │  │  │     │ │  │ 011 │                    │ 111 │</span><br><span class="line">├─────┤  │  ├─────┤ │  ├─────┤                    ├─────┤</span><br><span class="line">│     │  │  │     │ │  │     │                    │key:g│</span><br><span class="line">│     │  │  │     │ │  │     │                    │ 011 │</span><br><span class="line">├─────┤  │  ├─────┤ │  ├─────┤                    ├─────┤</span><br><span class="line">│     │  │  │     │ │  │     │                    │     │</span><br><span class="line">│     │  │  │     │ │  │     │                    │     │</span><br><span class="line">├─────┤  │  ├─────┤ │  ├─────┤                    ├─────┤</span><br><span class="line">│*over│  │  │*over│ │  │*over│                    │*over│</span><br><span class="line">│flow ├──┘  │flow ├─┘  │flow │                    │flow │</span><br><span class="line">└─────┘     └─────┘    └─────┘                    └─────┘</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go Map的基本结构和key的定位过程</title>
      <link href="2022/10/22/Go_Map/"/>
      <url>2022/10/22/Go_Map/</url>
      
        <content type="html"><![CDATA[<p>map由key-value对组成，并且一个key只会出现一次。对map可以进行增删改查一系列操作。在Go语言，map采用的是哈希查找表实现，解决哈希冲突的方式是链表法。记录一下学习过程中了解到的map基本结构和key的定位过程。</p><span id="more"></span><h2 id="0x0-map的基本结构"><a href="#0x0-map的基本结构" class="headerlink" title="0x0.map的基本结构"></a>0x0.map的基本结构</h2><p>附上源码(go1.18.2/src/runtime/map.go)</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A header for a Go map.</span></span><br><span class="line"><span class="keyword">type</span> hmap <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// Note: the format of the hmap is also encoded in</span></span><br><span class="line">  <span class="comment">// cmd/compile/internal/reflectdata/reflect.go.</span></span><br><span class="line"><span class="comment">// Make sure this stays in sync with the compiler&#x27;s definition.</span></span><br><span class="line">count     <span class="keyword">int</span> <span class="comment">// # live cells == size of map.  Must be first (used by len() builtin)</span></span><br><span class="line">flags     <span class="keyword">uint8</span></span><br><span class="line">B         <span class="keyword">uint8</span>  <span class="comment">// log_2 of # of buckets (can hold up to loadFactor * 2^B items)</span></span><br><span class="line">noverflow <span class="keyword">uint16</span> <span class="comment">// approximate number of overflow buckets; see incrnoverflow for details</span></span><br><span class="line">hash0     <span class="keyword">uint32</span> <span class="comment">// hash seed</span></span><br><span class="line"></span><br><span class="line">buckets    unsafe.Pointer <span class="comment">// array of 2^B Buckets. may be nil if count==0.</span></span><br><span class="line">oldbuckets unsafe.Pointer <span class="comment">// previous bucket array of half the size, non-nil only when growing</span></span><br><span class="line">nevacuate  <span class="keyword">uintptr</span>        <span class="comment">// progress counter for evacuation (buckets less than this have been evacuated)</span></span><br><span class="line"></span><br><span class="line">extra *mapextra <span class="comment">// optional fields</span></span><br><span class="line">&#125;                                                               </span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">┌──────┐</span><br><span class="line">│ hmap │</span><br><span class="line">├──────┴─────────────────────┐ ┌─────┐</span><br><span class="line">│          count int         │ │     │</span><br><span class="line">├────────────────────────────┤ │     ▼</span><br><span class="line">│          flags uint8       │ │  ┌──────┐      ┌───────┐</span><br><span class="line">├────────────────────────────┤ │  │[]bmap│    ┌►│ bmap  │</span><br><span class="line">│           B uint8          │ │  ├──────┴─┐  │ ├───────┴───────────────────────┐</span><br><span class="line">├────────────────────────────┤ │  │   0    ├──┘ │   tophash [bucketCnt]uint8    │</span><br><span class="line">│       noverflow uint16     │ │  ├────────┤    ├───────┬───────────────────────┤</span><br><span class="line">├────────────────────────────┤ │  │   1    │    │ key   │                       │</span><br><span class="line">│        hash0 uint32        │ │  ├────────┤    ├───┬───┼───┬───┬───┬───┬───┬───┤</span><br><span class="line">├────────────────────────────┤ │  │   2    │    │ 0 │ 1 │ 2 │ 3 │ 4 │ 5 │ 6 │ 7 │</span><br><span class="line">│   buckets unsafe.Pointer   ├─┘  ├────────┤    ├───┴───┼───┴───┴───┴───┴───┴───┤</span><br><span class="line">├────────────────────────────┤    │   3    │    │ values│                       │</span><br><span class="line">│  oldbuckets unsafe.Pointer │    ├────────┤    ├───┬───┼───┬───┬───┬───┬───┬───┤</span><br><span class="line">├────────────────────────────┤    │  ...   │    │ 0 │ 1 │ 2 │ 3 │ 4 │ 5 │ 6 │ 7 │</span><br><span class="line">│     nevacuates uintptr     │    ├────────┤    ├───┴───┴───┴───┴───┴───┴───┴───┤</span><br><span class="line">├────────────────────────────┤    │   62   │    │        overflow *bmap         │</span><br><span class="line">│       extra *mapextra      │    ├────────┤    └─────┬─────────────────────────┘</span><br><span class="line">└────┬───────────────────────┘    │   63   ├─┐        │</span><br><span class="line">     │                            └────────┘ │        │      ┌───────┐</span><br><span class="line">     ▼                             size&#x3D;2^B  │        └─────►│ bmap  │</span><br><span class="line">┌──────────┐                                 │               ├───────┴───────────────────────┐</span><br><span class="line">│ mapextra │                                 │               │   tophash [bucketCnt]uint8    │</span><br><span class="line">├──────────┴─────────┐                       │               ├───────┬───────────────────────┤</span><br><span class="line">│ overflow *[]*bmap  │   ┌───────┐ ◄─────────┘               │ key   │                       │</span><br><span class="line">├────────────────────┤   │ bmap  │                           ├───┬───┼───┬───┬───┬───┬───┬───┤</span><br><span class="line">│oldoverflow *[]*bmap│   ├───────┴───────────────────────┐   │ 0 │ 1 │ 2 │ 3 │ 4 │ 5 │ 6 │ 7 │</span><br><span class="line">├────────────────────┤   │   tophash [bucketCnt]uint8    │   ├───┴───┼───┴───┴───┴───┴───┴───┤</span><br><span class="line">│ nextoverflow *bmap │   ├───────┬───────────────────────┤   │ values│                       │</span><br><span class="line">└────────────────────┘   │ key   │                       │   ├───┬───┼───┬───┬───┬───┬───┬───┤</span><br><span class="line">                         ├───┬───┼───┬───┬───┬───┬───┬───┤   │ 0 │ 1 │ 2 │ 3 │ 4 │ 5 │ 6 │ 7 │</span><br><span class="line">                         │ 0 │ 1 │ 2 │ 3 │ 4 │ 5 │ 6 │ 7 │   ├───┴───┴───┴───┴───┴───┴───┴───┤</span><br><span class="line">                         ├───┴───┼───┴───┴───┴───┴───┴───┤   │        overflow *bmap         │</span><br><span class="line">                         │ values│                       │   └───────────────────────────────┘</span><br><span class="line">                         ├───┬───┼───┬───┬───┬───┬───┬───┤</span><br><span class="line">                         │ 0 │ 1 │ 2 │ 3 │ 4 │ 5 │ 6 │ 7 │</span><br><span class="line">                         ├───┴───┴───┴───┴───┴───┴───┴───┤       ┌────────┐</span><br><span class="line">                         │        overflow *bmap         ├──────►│  nil   │</span><br><span class="line">                         └───────────────────────────────┘       └────────┘</span><br></pre></td></tr></table></figure><p>其中B是bucket数组长度的对数，bucket里面存储了key和value。可以看见一个bucket里面最多能装8个key，这8个key在bucket里面的位置根据hash值的高8位决定。nevacuate表示扩容进度，小于此地址的 buckets 迁移完成。Ascii风格的map内存模型图是参考曹大github里的，曹大yyds。</p><p>其中bucket指针指向的结构体如下：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A bucket for a Go map.</span></span><br><span class="line"><span class="keyword">type</span> bmap <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// tophash generally contains the top byte of the hash value</span></span><br><span class="line"><span class="comment">// for each key in this bucket. If tophash[0] &lt; minTopHash,</span></span><br><span class="line"><span class="comment">// tophash[0] is a bucket evacuation state instead.</span></span><br><span class="line">tophash [bucketCnt]<span class="keyword">uint8</span></span><br><span class="line"><span class="comment">// Followed by bucketCnt keys and then bucketCnt elems.</span></span><br><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> packing all the keys together and then all the elems together makes the</span></span><br><span class="line"><span class="comment">// code a bit more complicated than alternating key/elem/key/elem/... but it allows</span></span><br><span class="line"><span class="comment">// us to eliminate padding which would be needed for, e.g., map[int64]int8.</span></span><br><span class="line"><span class="comment">// Followed by an overflow pointer.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">┌───────┐</span><br><span class="line">│ bmap  │</span><br><span class="line">├───────┴───────────────────────┐</span><br><span class="line">│   tophash [bucketCnt]uint8    │</span><br><span class="line">├───────┬───────────────────────┤</span><br><span class="line">│ key   │                       │</span><br><span class="line">├───┬───┼───┬───┬───┬───┬───┬───┤</span><br><span class="line">│ 0 │ 1 │ 2 │ 3 │ 4 │ 5 │ 6 │ 7 │</span><br><span class="line">├───┴───┼───┴───┴───┴───┴───┴───┤</span><br><span class="line">│ values│                       │</span><br><span class="line">├───┬───┼───┬───┬───┬───┬───┬───┤</span><br><span class="line">│ 0 │ 1 │ 2 │ 3 │ 4 │ 5 │ 6 │ 7 │</span><br><span class="line">├───┴───┴───┴───┴───┴───┴───┴───┤</span><br><span class="line">│        overflow *bmap         │</span><br><span class="line">└───────────────────────────────┘</span><br></pre></td></tr></table></figure><p>其中key和value是各自存放在一起的，为什么要这么做呢，以下是在注释中的官方解释。</p><blockquote><pre><code>NOTE: packing all the keys together and then all the elems together makes thecode a bit more complicated than alternating key/elem/key/elem/... but it allowsus to eliminate padding which would be needed for, e.g., map[int64]int8.</code></pre></blockquote><p>主要是为了减少内存对齐带来的padding。注释中给了一个例子<code>map[int64]int8</code>，如果是按照<code>key/elem/key/elem/</code>这种方式存储，相当于每一个<code>key/elem</code>都需要padding7个字节。64位的机器上，默认的对齐系数是8，同时<code>int8</code>的对齐系数是1，<code>int64</code>的对齐系数是8。以下是<code>key/elem</code>方式产生padding的过程：</p><ul><li>第一个key，key1(int64)的大小和对齐值是8，占据8位。暂且写做：kkkkkkkk</li><li>第一个value，value1(int8)的大小和对齐值是1，占据1位。写做：kkkkkkkk｜v</li><li>第二个key，key2(int64)的大小和对齐值是8，偏移量必须是8的倍数。也就产生了padding。不能直接接着value1后面写了，写作：kkkkkkkk｜vxxxxxxx｜kkkkkkkk。其中x表示padding。后面也就是依次类推了。</li></ul><p>如果是按照<code>key/key/key/.../key/elem/elem/.../elem</code>来进行存储的话，只需要在最后面添加padding就行。内存对齐一般好像不怎么会考虑，但是了解还是需要了解的，TODO List再加一项。</p><h2 id="0x1-map中key的位置"><a href="#0x1-map中key的位置" class="headerlink" title="0x1.map中key的位置"></a>0x1.map中key的位置</h2><p>在64位的机器上面，key经过hash计算后会得到一个64bit的哈希值。在key的定位过程中会用到哈希值的高8位和后B位。B就是hmap中的B，如果B=6，buckets数组的长度就是2^6=64。</p><p>举个🌰,现在有一个key的哈希值如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">00000111 | 00001111111011001111111111101010001000000001010000 | 000010</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">                                    key</span><br><span class="line"></span><br><span class="line">┌────────────────────────────────────────────────────────────────────────┐</span><br><span class="line">│ 00000111 | 00001111111011001111111111101010001000000001010000 | 000010 │</span><br><span class="line">└────┬──────────────────────────────────────────────────────────────┬────┘</span><br><span class="line">     │                                                              │</span><br><span class="line">     │                                                              ▼</span><br><span class="line">     │                                     B&#x3D;6          ┌────────────────┐</span><br><span class="line">     │                              bucketMask&#x3D;111111   │ 000010&amp;111111  │</span><br><span class="line">     │                                                  └────────────┬───┘</span><br><span class="line">     │ tophash                                                       │</span><br><span class="line">     │                                                               ▼</span><br><span class="line">     │                                                          ┌────────┐</span><br><span class="line">     │                                    ┌─────────────────────┤000010&#x3D;2│</span><br><span class="line">     ▼                                    │                     └────────┘</span><br><span class="line">┌────────────┐                 buckets    ▼</span><br><span class="line">│ 00000111&#x3D;7 │                  ┌───┬───┬───┬───┬──────────┬────┬────┬────┐</span><br><span class="line">└─────┬──────┘                  │ 0 │ 1 │ 2 │ 3 │    ...   │ 61 │ 62 │ 63 │</span><br><span class="line">      │                         └───┴───┴─┬─┴───┴──────────┴────┴────┴────┘</span><br><span class="line">      │                                   │</span><br><span class="line">      │                                   │</span><br><span class="line">      └─────────────────────────────┐     │</span><br><span class="line">                                    │     ▼</span><br><span class="line">           ┌────────────────────────┼────────────┬──────┐</span><br><span class="line">           │                        │            │bucket│</span><br><span class="line">           │  ┌───────┐             │            ├──────┘</span><br><span class="line">           │  │ bmap  │             ▼            │</span><br><span class="line">           │  ├───┬───┼───┬───┬───┬───┬───┬───┐  │</span><br><span class="line">           │  │111│ 9 │ 3 │ 5 │ 6 │ 7 │ 0 │ 0 │  │</span><br><span class="line">           │  ├───┴───┼───┴───┴───┴───┴───┴───┤  │</span><br><span class="line">           │  │ key   │                       │  │</span><br><span class="line">           │  ├───┬───┼───┬───┬───┬───┬───┬───┤  │</span><br><span class="line">           │  │ 5 │ 2 │ 1 │ 4 │ 3 │ 9 │ 0 │ 0 │  │</span><br><span class="line">           │  ├───┴───┼───┴───┴───┴───┴───┴───┤  │</span><br><span class="line">           │  │ values│                       │  │</span><br><span class="line">           │  ├───┬───┼───┬───┬───┬───┬───┬───┤  │</span><br><span class="line">           │  │ 3 │ 5 │ 4 │ 7 │ 9 │ 6 │ 0 │ 0 │  │</span><br><span class="line">           │  ├───┴───┴───┴───┴───┴───┴───┴───┤  │</span><br><span class="line">           │  │        overflow *bmap         │  │</span><br><span class="line">           │  └───────────────────────────────┘  │</span><br><span class="line">           │                                     │</span><br><span class="line">           └─────────────────────────────────────┘</span><br></pre></td></tr></table></figure><p>如果在 bucket 中没找到，并且 overflow 不为空，还要继续去 overflow bucket 中寻找，直到找到或是所有的 key 槽位都找遍了，包括所有的 overflow bucket。</p><p>实现上有 mapaccess1，mapaccess2，mapaccessK 几个方法，主要区别是在返回内容上。当要查询的 key 不在 map 里，mapaccess2的用法会返回一个 bool 型变量提示 key 是否在 map 中；而mapaccess1 的语句则会返回一个 key 对应 value 类型的零值。如果 value 是 int 型就会返回 0，如果 value 是 string 类型，就会返回空字符串。mapaccess2就是日常代码中<code>v, ok := map[k]</code>的底层函数。</p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go Slice的扩容策略</title>
      <link href="2022/10/15/Go_Slice_growup/"/>
      <url>2022/10/15/Go_Slice_growup/</url>
      
        <content type="html"><![CDATA[<p>在写Go的时候，对Slice的操作就很危险，特别是函数参数传的是Slice指针，一不小心就改了。切片支持子切片  和原本切片共享底层数组，那子切片和切片究竟会不会相互影响？ 就看他们是不是还共享底层数组。如果他们的结构没有变化，肯定是共享的。结构发生变化(扩容)，就可能不共享了。</p><p>对子切片的使用建议：只读不改</p><span id="more"></span><h2 id="0x0-Slice和Array的联系"><a href="#0x0-Slice和Array的联系" class="headerlink" title="0x0.Slice和Array的联系"></a>0x0.Slice和Array的联系</h2><p>slice 的底层数据是数组，slice 是对数组的封装。两者都可以通过下标来访问单个元素。</p><p>数组就是一片连续的内存，是定长的，其长度是类型的一部分，比如 [3]int 和 [4]int 就是不同的类型。</p><p>slice可以动态地扩容，切片的类型和长度无关。</p><p>slice 是一个结构体，包含三个字段：长度、容量、底层数组。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type slice struct &#123;</span><br><span class="line">array unsafe.Pointer &#x2F;&#x2F; 元素指针</span><br><span class="line">len   int &#x2F;&#x2F; 长度 </span><br><span class="line">cap   int &#x2F;&#x2F; 容量</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不是每一个Slice都有自己专属的底层数组，底层数组是可以被多个Slice同时指向的，也就是说在修改SliceA的数据时，有可能SliceB的数据也会发生改变。</p><h2 id="0x1-Slice扩容策略"><a href="#0x1-Slice扩容策略" class="headerlink" title="0x1.Slice扩容策略"></a>0x1.Slice扩容策略</h2><p>在golang1.18版本之前，Slice的扩容策略是当原 slice 容量小于 <code>1024</code> 的时候，新 slice 容量变成原来的 <code>2</code> 倍；原 slice 容量超过 <code>1024</code>，新 slice 容量变成原来的<code>1.25</code>倍。</p><p>在golang1.18版本之后，新的Slice扩容策略是当原slice容量(oldcap)小于<code>256</code>的时候，新slice(newcap)容量为原来的<code>2</code>倍；原slice容量超过<code>256</code>，新slice容量<code>newcap = oldcap+(oldcap+3*256)/4</code></p><blockquote><p>在实际的扩容过程中，还需要考虑内存对齐产生的影响，这个和内存分配策略相关。进行内存对齐之后，新 slice 的容量是要 <code>大于等于</code> 理论的扩容量。</p></blockquote><p>经典例题，来自<a href="https://jodezer.github.io/2017/05/golangSlice%E7%9A%84%E6%89%A9%E5%AE%B9%E8%A7%84%E5%88%99">golang Slice的扩容规则</a></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>&#125;</span><br><span class="line">s = <span class="built_in">append</span>(s,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;len=%d, cap=%d&quot;</span>,<span class="built_in">len</span>(s),<span class="built_in">cap</span>(s))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">len&#x3D;5, cap&#x3D;6</span><br></pre></td></tr></table></figure></blockquote>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C# GC机制(Garbage Collector)</title>
      <link href="2022/02/08/CSharp_GC_mechanism/"/>
      <url>2022/02/08/CSharp_GC_mechanism/</url>
      
        <content type="html"><![CDATA[<p>记录一下C#中GC的相关知识。不记下来，下次又找不到，就很烦。</p><p>主要针对的是C#中如何判定Garbage和GC的运作方式。</p><span id="more"></span><h2 id="0x0-资源概念"><a href="#0x0-资源概念" class="headerlink" title="0x0.资源概念"></a>0x0.资源概念</h2><p>所谓的资源其实就是程序中可以利用的数据。比如字符串、图片和任何的二进制数据。</p><p>托管资源，非托管资源：托管资源是由CLR全权负责的资源，CLR不负责的资源位非托管资源。<br><strong>对于托管资源通过GC自动清理回收。对于非托管的资源，一般就是Stream，数据库的连接，网络连接，GDI+的相关对象，还有Com对象等等这些操作系统资源，需要我们手动去释放，再由GC回收。</strong>  </p><h2 id="0x1-Garbage的判定"><a href="#0x1-Garbage的判定" class="headerlink" title="0x1.Garbage的判定"></a>0x1.Garbage的判定</h2><p>.Net类型分为两大类，<strong>一个就是值类型，另一个就是引用类型。前者是在堆栈中分配内存，它们有自身的生命周期，所以不用对它们进行管理，会自动分配和释放。后者是在堆中分配内存的。所以它的分配和释放就需要像回收机制来管理。</strong></p><p>GC的全称为“Garbage Collector”,顾名思义就是垃圾回收器，那么只有被称为垃圾的对象才能被GC回收。也就是说， 一个引用类型对象所占用的内存需要被GC回收，需要先成为垃圾。 <strong>.Net判定一个引用类型对象是垃圾，只需要判定此对象或者其包含的子对象没有任何引用是有效的，那么系统就认为它是垃圾。</strong></p><h2 id="0x2-非托管资源的释放方式"><a href="#0x2-非托管资源的释放方式" class="headerlink" title="0x2.非托管资源的释放方式"></a>0x2.非托管资源的释放方式</h2><h3 id="1-Close"><a href="#1-Close" class="headerlink" title="1).Close()"></a>1).Close()</h3><p>关闭对象资源，在显示调用时被调用。</p><h3 id="2-Dispose"><a href="#2-Dispose" class="headerlink" title="2).Dispose()"></a>2).Dispose()</h3><p>继承IDisposable接口，实现Dispose方法；<br>介绍：调用Dispose方法，销毁对象，需要显示调用或者通过using语句，在显示调用或者离开using程序块时被调用。<br>Dispose方法用于清理对象封装的非托管资源，而不是释放对象的内存，对象的内存依然由垃圾回收器控制。<br>Dispose方法调用，不但释放该类的非托管资源，还释放了引用的类的非托管资源。<br>Dispose模式就是一种强制资源清理所要遵守的约定；Dispose模式实现IDisposable接口，从而使得该类型提供一个公有的Dispose方法。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">而Close与Dispose这两种方法的区别在于，调用完了对象的Close方法后，此对象有可能被重新进</span><br><span class="line">行使用；而Dispose方法来说，此对象所占有的资源需要被标记为无用了，也就是此对象被销毁了，</span><br><span class="line">不能再被使用。</span><br></pre></td></tr></table></figure><h3 id="3-析构函数-Finalize"><a href="#3-析构函数-Finalize" class="headerlink" title="3).析构函数/Finalize()"></a>3).析构函数/Finalize()</h3><p>带有析构函数的类，生命周期会变长。内存空间需要两次垃圾回收才会被释放，导致性能下降。</p><p>一个正常情况的类是不会写析构函数的，而一旦一个类写了析构函数，就意味着GC会在不确定的时间调用该类的析构函数，判断该类的资源是否需要释放，然后调用Finalize方法，如果重写了Finalize方法则调用重写的Finalize方法。<br>Finalize方法的作用是保证.NET对象能在垃圾回收时清除非托管资源。<br>在.NET中，Object.Finalize()方法是无法重载的，编译器是根据类的析构函数来自动生成Object.Finalize()方法的<br>Finalize由垃圾回收器调用；dispose由对象调用。<br>Finalize无需担心因为没有调用Finalize而使非托管资源得不到释放，因为GC会在不确定时间调用，当然，你也可以手动调用Finalize方法，而dispose必须手动调用。<br>Finalize虽然无需担心因为没有调用Finalize而使非托管资源得不到释放，但因为由垃圾回收器管理，不能保证立即释放非托管资源；而dispose一调用便释放非托管资源。<br>只有类类型才能重写Finalize，而结构不能；类和结构都能实现IDispose</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">释放模式：是一种微软建议的写法，先手动显示去释放资源，如果忘记了，再让finalize释放资源。</span><br><span class="line">所以如果已经完成了析构函数该干的事情(例如释放非托管资源)，就应当使用SuppressFinalize</span><br><span class="line">方法告诉GC不需要再执行某个对象的析构函数。</span><br></pre></td></tr></table></figure><h2 id="0x3-GC的运作方式"><a href="#0x3-GC的运作方式" class="headerlink" title="0x3.GC的运作方式"></a>0x3.GC的运作方式</h2><p>内存的释放和回收需要伴随着程序的运行，因此系统为GC安排了独立的线程。那么GC的工作大致是，查询内存中对象是否成为垃圾，然后对垃圾进行释放和回收。那么对于GC对于内存回收采取了一定的优先算法进行轮循回收内存资源。</p><p>其次，<strong>对于内存中的垃圾分为两种，一种是需要调用对象的析构函数，另一种是不需要调用的。GC对于前者的回收需要通过两步完成，第一步是调用对象的析构函数，第二步是回收内存，但是要注意这两步不是在GC一次轮循完成，即需要两次轮循；相对于后者，则只是回收内存而已。</strong></p><p>C#中的GC使用了Generation的概念，它将分配的对象分为3代(可用GC.GetGeneration方法返回任意作为参数的对象当前所处的代)。</p><p>最近被分配内存的对象被放置于第0代，因为第0代很小，小到足以放进处理器的二级（L2)缓存，所以它能够提供对对象的快速存取。经过一轮垃圾回收后，仍然保留在第0代中的对象被移进第1代中，再经过一轮垃圾内存回收后，仍然保留在第1代中的对象则被移进第2代中，第2代中包含了生存期较长的对象。 当第0代中没有可以分配的有效内存时，就触发了第0代中的一轮垃圾回收，它将删除那些不再被引用的对象，并将当前正在使用的对象移至第1代。而当第0代垃圾回收后依然不能请求到充足的内存时，就启动第1代垃圾回收。如果对各代都进行了垃圾回收后仍没有可用的内存就会引发一个OutOfMemoryException异常。</p><table><thead><tr><th align="center"></th><th align="center">Close</th><th align="center">Dispose</th><th align="center">析构函数</th></tr></thead><tbody><tr><td align="center"></td><td align="center">关闭对象资源</td><td align="center">销毁对象</td><td align="center">销毁对象</td></tr><tr><td align="center">调用方式</td><td align="center">需要显示调用</td><td align="center">需要显示调用或者通过using语句</td><td align="center">不能被显示调用，会被GC调用</td></tr><tr><td align="center">调用时机</td><td align="center">在显示调用时</td><td align="center">在显示调用或者离开using程序块</td><td align="center">不确定</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 工作 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> GC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go版本切换</title>
      <link href="2022/01/05/Go_Version_switching/"/>
      <url>2022/01/05/Go_Version_switching/</url>
      
        <content type="html"><![CDATA[<p>线上的程序用的是老版本的Go(毕竟比较稳)，自己又想尝试新的版本特性。久而久之，电脑里面SDK的版本就越来越多了，每次切换起来就很麻烦。所以特此记录一下。</p><span id="more"></span><h2 id="0x0-手动管理-目前使用的切换方式"><a href="#0x0-手动管理-目前使用的切换方式" class="headerlink" title="0x0.手动管理(目前使用的切换方式)"></a>0x0.手动管理(目前使用的切换方式)</h2><p>官网下载最新版Archive文件go1.18beta1.darwin-amd64.tar.gz</p><p>解压缩重命名go1.18.beta1,拷贝一份放到默认安装路径<code>/usr/local/go1.18beta1</code></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo cp -R /User/egan/Sdks/go1.18beta1 /usr/local/go1.18beta1</span><br></pre></td></tr></table></figure><p>进入默认安装路径，创建软链</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /usr/local/</span><br><span class="line">sudo ln -s go1.18beta1 go</span><br></pre></td></tr></table></figure><h2 id="0x1-版本切换工具"><a href="#0x1-版本切换工具" class="headerlink" title="0x1.版本切换工具"></a>0x1.版本切换工具</h2><h3 id="1-g"><a href="#1-g" class="headerlink" title="1).g"></a>1).g</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GitHub:https:&#x2F;&#x2F;github.com&#x2F;voidint&#x2F;g</span><br></pre></td></tr></table></figure><h3 id="2-goup"><a href="#2-goup" class="headerlink" title="2).goup"></a>2).goup</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Github:https:&#x2F;&#x2F;github.com&#x2F;owenthereal&#x2F;goup</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> 版本切换 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C#内存泄露</title>
      <link href="2022/01/03/CSharp_OOM/"/>
      <url>2022/01/03/CSharp_OOM/</url>
      
        <content type="html"><![CDATA[<p>记录自己干的蠢事，这也是自己第一次在工作中写出来内存泄漏。幸亏程序没有直接上线，以后还是要多测试测试自己的代码。</p><span id="more"></span><h2 id="0x0-问题产生原因"><a href="#0x0-问题产生原因" class="headerlink" title="0x0.问题产生原因"></a>0x0.问题产生原因</h2><p>在<code>button1.Click += Button1_Click</code>中，(+=) 来为事件附加事件处理程序</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Form1</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    InitializeComponent();</span><br><span class="line">    button1.Click += Button1_Click;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Button1_Click</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line"><span class="function"></span> &#123;</span><br><span class="line">     System.Diagnostics.Debug.Print(<span class="string">&quot;x&quot;</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">event</span> EventHandler Click;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">EventHandler</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span>;</span><br></pre></td></tr></table></figure><p>给button1_Click的附加事件处理程序放在了心跳里面；</p><p>此次溢出是因为每次心跳，又进行了一次事件处理程序的附加，造成不断附件事件处理程序。</p><p>直至最后，点击一次，要运行2K+次的事件处理程序。</p><p>而事件处理程序的代码里面会使用创建新的线程，运行一次，创建大量的新线程，线程数直接飙升，内存崩掉。</p><h2 id="0x1-定位内存泄露发生的地方："><a href="#0x1-定位内存泄露发生的地方：" class="headerlink" title="0x1.定位内存泄露发生的地方："></a>0x1.定位内存泄露发生的地方：</h2><p>C#的代码可以使用内存分析工具dotMemory。dotMemory允许你分析各种.NET和.NET Core应用程序的内存使用情况；比如桌面应用程序、Windows服务、ASP.NET Web应用程序、IIS、IIS Express、任意.NET进程等。不过临时用一下可以，有30天的试用期，还是比较好用的。</p><p>溢出版本源码示例:</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">WindowsFormsApp1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">Form1</span> : <span class="title">Form</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Form1</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            InitializeComponent();</span><br><span class="line">            button1.Click += Button1_Click;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Cycle</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            button1.Click += Button1_Click;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Button1_Click</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            i += <span class="number">1</span>;</span><br><span class="line">            System.Diagnostics.Debug.Print(<span class="string">&quot;x:&#123;0&#125;&quot;</span>,i);</span><br><span class="line">            Cycle();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正常版本源码示例：</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">WindowsFormsApp1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">Form1</span> : <span class="title">Form</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Form1</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            InitializeComponent();</span><br><span class="line">            button1.Click += Button1_Click;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Button1_Click</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            i += <span class="number">1</span>;</span><br><span class="line">            System.Diagnostics.Debug.Print(<span class="string">&quot;x:&#123;0&#125;&quot;</span>,i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 工作 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> OOM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C#串口读写连续性问题</title>
      <link href="2022/01/01/CSharp_Serial_port_readwrite_continuity_problem/"/>
      <url>2022/01/01/CSharp_Serial_port_readwrite_continuity_problem/</url>
      
        <content type="html"><![CDATA[<p>在使用串口协议进行自定义协议读写的时候，一般使用Ascii编码。但是串口中读取到的数据并不能保证其完整性。一条指令有可能会被拆分成多条数据发送，读取到的字符串有可能只是其中的一部分。一般一条指令的末尾都会加上\n\r作为结束符。</p><span id="more"></span><h2 id="0x0-创建连接"><a href="#0x0-创建连接" class="headerlink" title="0x0.创建连接"></a>0x0.创建连接</h2><p>串口使用System.IO.Ports.SerialPort来创建连接</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 摘要:</span></span><br><span class="line"><span class="comment">//     使用指定的端口名、波特率、奇偶校验位、数据位和停止位初始化 System.IO.Ports.SerialPort 类的新实例。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 参数:</span></span><br><span class="line"><span class="comment">//   portName:</span></span><br><span class="line"><span class="comment">//     要使用的端口（例如 COM1）。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//   baudRate:</span></span><br><span class="line"><span class="comment">//     波特率。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//   parity:</span></span><br><span class="line"><span class="comment">//     System.IO.Ports.SerialPort.Parity 值之一。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//   dataBits:</span></span><br><span class="line"><span class="comment">//     数据位值。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//   stopBits:</span></span><br><span class="line"><span class="comment">//     System.IO.Ports.SerialPort.StopBits 值之一。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 异常:</span></span><br><span class="line"><span class="comment">//   T:System.IO.IOException:</span></span><br><span class="line"><span class="comment">//     未能找到或打开指定的端口。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SerialPort</span>(<span class="params"><span class="built_in">string</span> portName, <span class="built_in">int</span> baudRate, Parity parity, <span class="built_in">int</span> dataBits, StopBits stopBits</span>)</span>;</span><br></pre></td></tr></table></figure><p>其中Parity和StopBits的枚举分别为：</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 摘要:</span></span><br><span class="line"><span class="comment">// 指定 System.IO.Ports.SerialPort 对象的奇偶校验位。</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> Parity</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 摘要:</span></span><br><span class="line">    <span class="comment">// 不发生奇偶校验检查。</span></span><br><span class="line">    None = <span class="number">0</span>,</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 摘要:</span></span><br><span class="line">    <span class="comment">// 设置奇偶校验位，使位数等于奇数。</span></span><br><span class="line">    Odd = <span class="number">1</span>,</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 摘要:</span></span><br><span class="line">    <span class="comment">// 设置奇偶校验位，使位数等于偶数。</span></span><br><span class="line">    Even = <span class="number">2</span>,</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 摘要:</span></span><br><span class="line">    <span class="comment">// 将奇偶校验位保留为 1。</span></span><br><span class="line">    Mark = <span class="number">3</span>,</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 摘要:</span></span><br><span class="line">    <span class="comment">// 将奇偶校验位保留为 0。</span></span><br><span class="line">    Space = <span class="number">4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 摘要:</span></span><br><span class="line"><span class="comment">// 指定在 System.IO.Ports.SerialPort 对象上使用的停止位的数目。</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> StopBits</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 摘要:</span></span><br><span class="line">    <span class="comment">// 不使用停止位。 System.IO.Ports.SerialPort.StopBits 属性不支持此值。</span></span><br><span class="line">    None = <span class="number">0</span>,</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 摘要:</span></span><br><span class="line">    <span class="comment">// 使用一个停止位。</span></span><br><span class="line">    One = <span class="number">1</span>,</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 摘要:</span></span><br><span class="line">    <span class="comment">// 使用两个停止位。</span></span><br><span class="line">    Two = <span class="number">2</span>,</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 摘要:</span></span><br><span class="line">    <span class="comment">// 使用 1.5 个停止位。</span></span><br><span class="line">    OnePointFive = <span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>连接完成后需要保证端口的开启，可使用IsOpen参数进行判定。</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!Conn.IsOpen)</span><br><span class="line">&#123;</span><br><span class="line">    Conn.Open();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0x1-数据的读写部分"><a href="#0x1-数据的读写部分" class="headerlink" title="0x1.数据的读写部分"></a>0x1.数据的读写部分</h2><p>何时停止读写，可以根据NewLine的值进行判定。NewLine的默认值是”\n”换行符，可以根据自己的需求进行更改。”\r\n”也是比较常用的NewLine。</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 摘要:</span></span><br><span class="line"><span class="comment">//     获取或设置用于解释 System.IO.Ports.SerialPort.ReadLine 和 System.IO.Ports.SerialPort.WriteLine(System.String)</span></span><br><span class="line"><span class="comment">//     方法调用结束的值。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 返回结果:</span></span><br><span class="line"><span class="comment">//     表示行尾的值。 默认值为换行符，System.Environment.NewLine。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 异常:</span></span><br><span class="line"><span class="comment">//   T:System.ArgumentException:</span></span><br><span class="line"><span class="comment">//     属性值为空。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//   T:System.ArgumentNullException:</span></span><br><span class="line"><span class="comment">//     属性值为 null。</span></span><br><span class="line">[<span class="meta">Browsable(false)</span>]</span><br><span class="line">[<span class="meta">DefaultValue(<span class="meta-string">&quot;\n&quot;</span>)</span>]</span><br><span class="line">[<span class="meta">MonitoringDescription(<span class="meta-string">&quot;NewLine&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">string</span> NewLine &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br></pre></td></tr></table></figure><p>如果不想直接设置NewLine，也可以在读取串口数据时，根据自定义字符进行读取划分。</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 摘要:</span></span><br><span class="line"><span class="comment">//     一直读取到输入缓冲区中的指定 value 的字符串。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 参数:</span></span><br><span class="line"><span class="comment">//   value:</span></span><br><span class="line"><span class="comment">//     指示读取操作停止位置的值。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 返回结果:</span></span><br><span class="line"><span class="comment">//     输入缓冲区中直到指定 value 的内容。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 异常:</span></span><br><span class="line"><span class="comment">//   T:System.ArgumentException:</span></span><br><span class="line"><span class="comment">//     value 参数的长度为 0。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//   T:System.ArgumentNullException:</span></span><br><span class="line"><span class="comment">//     value 参数为 null。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//   T:System.InvalidOperationException:</span></span><br><span class="line"><span class="comment">//     指定的端口未打开。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//   T:System.TimeoutException:</span></span><br><span class="line"><span class="comment">//     该操作未在超时时间到期之前完成。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">ReadTo</span>(<span class="params"><span class="built_in">string</span> <span class="keyword">value</span></span>)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> reqStr = Conn.ReadTo(<span class="string">&quot;\r\n&quot;</span>);</span><br></pre></td></tr></table></figure><p>这样读取出来的数据就可以时一条条完整的指令，而不会出现被分隔的指令片段。</p>]]></content>
      
      
      <categories>
          
          <category> 工作 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> Serial </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>华为OD笔试</title>
      <link href="2021/03/09/Huawei_OD_exam/"/>
      <url>2021/03/09/Huawei_OD_exam/</url>
      
        <content type="html"><![CDATA[<p>第一次参加华为OD的笔试，作为参加过<del>精英</del>笔试的优秀青年。我还是想记录一下的。说实话题目还行，但是裸考还是有点难度的(个人观点，或许是我菜的过分了)。</p><span id="more"></span><h2 id="0x0-第一题"><a href="#0x0-第一题" class="headerlink" title="0x0.第一题"></a>0x0.第一题</h2><p>用一个数组A，代表程序员的工作能力。公司想通过结对编程的模式来提高员工的工作能力，假设成对后的能力是两个员工的能力之和，求一共有多少种结对方式，使结对后的能力为N。</p><p><strong>提示：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 第一行代表员工个数</span><br><span class="line">2. 第二行代表各个员工的能力值</span><br><span class="line">3. 第三行代表结对后的能力值N</span><br><span class="line">4. 输出为结对的组合方式的值</span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">5</span><br><span class="line">1 2 2 2 3</span><br><span class="line">4</span><br><span class="line">输出：</span><br><span class="line">4</span><br></pre></td></tr></table></figure><h3 id="1-解题思路"><a href="#1-解题思路" class="headerlink" title="1).解题思路"></a>1).解题思路</h3><p>说实话这题放在华为OD的笔试里面，应该是属于送分题，一个输入数组加两层for循环直接解就行，直接附上代码就算了。</p><h3 id="2-代码实现"><a href="#2-代码实现" class="headerlink" title="2).代码实现"></a>2).代码实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  main.cpp</span></span><br><span class="line"><span class="comment">//  Demo</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by Egan.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,N;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">1001</span>];</span><br><span class="line">    <span class="keyword">int</span> count =<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x =<span class="number">0</span>; x &lt; n; x++ )&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> y= x+<span class="number">1</span>; y &lt;n; y++ )&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[x]+arr[y] == N)</span><br><span class="line">                count += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; count &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0x1-错误的里程表"><a href="#0x1-错误的里程表" class="headerlink" title="0x1.错误的里程表"></a>0x1.错误的里程表</h2><p>一个汽车里程表，它以整数形式显示行驶的英里数。然而，里程表有一个缺陷:它从数字3转到数字5，总是跳过数字4。这个缺陷出现在所有的位置(1,10,100，等等)。例如，如果里程表显示为15339，而汽车行驶了1英里，里程表的读数将更改为15350(而不是15340)。</p><p><strong>提示：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 输入为里程表上的数值</span><br><span class="line">2. 输出为实际车子行驶的数值</span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入1：5</span><br><span class="line">输出1：3</span><br><span class="line">输入2：17</span><br><span class="line">输出2：15</span><br><span class="line">输入3：100</span><br><span class="line">输出3：81</span><br></pre></td></tr></table></figure><h3 id="1-解题思路-1"><a href="#1-解题思路-1" class="headerlink" title="1).解题思路"></a>1).解题思路</h3><p>遇到4则直接从3进位到5，所以这是一道典型的进制转化问题，遍历该数字的每一位（如果这一位的数字比4大，就要减去1，因为这个位跳过了一个4），然后再遍历该数字的每一位，将其转化为10进制。</p><h3 id="2-代码实现-1"><a href="#2-代码实现-1" class="headerlink" title="2).代码实现"></a>2).代码实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  main.cpp</span></span><br><span class="line"><span class="comment">//  Demo</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by Egan.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        <span class="keyword">if</span>(n[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> j = n.size;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> num = <span class="number">0</span>; ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> m = j<span class="number">-1</span>; m &gt;= <span class="number">0</span>; m--) &#123;</span><br><span class="line">            <span class="keyword">if</span>((n[m]-<span class="string">&#x27;0&#x27;</span>)&gt;<span class="number">4</span>)&#123;</span><br><span class="line">                num += ((n[m]-<span class="string">&#x27;0&#x27;</span>)<span class="number">-1</span>) * ans;</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                num += (n[m]-<span class="string">&#x27;0&#x27;</span>) * ans;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = ans * <span class="number">9</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="string">&quot;:&quot;</span>&lt;&lt;num&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="0x2-贪吃蛇算法"><a href="#0x2-贪吃蛇算法" class="headerlink" title="0x2.贪吃蛇算法"></a>0x2.贪吃蛇算法</h2><p>题目太长，具体的记不清楚了，只能大致的描述一下。。。。</p><p>输入一个字符矩阵，其中字符E是食物(蛇吃了长度+1的那种)，F是空白，H是蛇的位置(初始只占一个位置)</p><p>移动指令有5种，分别让贪吃蛇移动以及转向：G前进、U往上转、D往下转、L往左转、R往右转（初始方向为左）</p><p>结束条件是碰壁或者碰到自己就算死了。 </p><p>求按输入的指令执行之后的蛇的长度。</p><p><strong>输入输出示例：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">D G G</span><br><span class="line">3</span><br><span class="line">F E F</span><br><span class="line">E E H</span><br><span class="line">F F F</span><br><span class="line">输出：</span><br><span class="line">1</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 日常 </category>
          
          <category> 工作 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 华为OD </tag>
            
            <tag> 笔试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础计算器II (Basic calculator II)</title>
      <link href="2021/03/02/Basic_calculator_II/"/>
      <url>2021/03/02/Basic_calculator_II/</url>
      
        <content type="html"><![CDATA[<p>栈的经典应用：</p><p>给一个字符串表达式 <code>s</code> ，实现一个基本计算器来计算并返回它的值。(整数除法仅保留整数部分)</p><span id="more"></span><p><strong>提示：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 1 &lt;&#x3D; s.length &lt;&#x3D; 3 * 10^5</span><br><span class="line">2. s 由整数和算符(&#39;+&#39;, &#39;-&#39;, &#39;*&#39;, &#39;&#x2F;&#39;)组成,中间由一些空格隔开</span><br><span class="line">3. s 表示一个有效表达式</span><br><span class="line">4. 表达式中的所有整数都是非负整数,且在范围[0, 231 - 1]内</span><br><span class="line">5. 题目数据保证答案是一个32-bit整数</span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;3+2*2&quot;</span><br><span class="line">输出：7</span><br></pre></td></tr></table></figure><h2 id="0x0-解题思路"><a href="#0x0-解题思路" class="headerlink" title="0x0.解题思路"></a>0x0.解题思路</h2><p>栈的经典应用，此题没有括号，不需要进行括号匹配，相对来说简单一点，可以直接进行暴力求解。</p><ol><li><p>需要考虑运算符的优先级问题。乘除的优先级大于加减，可以先进行乘除运算，用一个栈，保存进行乘除运算后的整数的值。对于加减号后的数字，将其直接压入栈中；对于乘除号后的数字，直接与栈顶元素计算，并替换栈顶元素为计算后的结果。</p></li><li><p>遍历字符串 s，并用变量preSign记录每个数字之前的运算符，对于第一个数字，其之前的运算符视为加号。遍历到运算符或者字符串最后一位时，根据preSign来决定计算方式:</p><ul><li><p>加号：数字直接入栈；</p></li><li><p>减号：num变(-num)入栈；</p></li><li><p>乘除：num ( * or / ) stack.back()，并将栈顶元素替换为运算结果。</p></li></ul></li></ol><h2 id="0x1-复杂度分析"><a href="#0x1-复杂度分析" class="headerlink" title="0x1.复杂度分析"></a>0x1.复杂度分析</h2><ul><li><p>时间复杂度：O(n)，其中n为字符串s的长度。需要遍历字符串s一次，计算表达式的值。</p></li><li><p>空间复杂度：O(n)，其中n为字符串s的长度。空间复杂度主要取决于栈的空间，栈的元素个数不超过n。</p></li></ul><p>需要注意的是</p><ul><li>在运算的时候，判断字符是数字还是运算符的时候，需要使用<code>isdigit()</code>函数，此函数包含在头文件<code>#include &lt;cctype&gt;</code>中。</li><li>运算的时候，如果遇到的数是大数(两位数及以上的)，需要进行处理。大数在字符串中是两个字符，需要在遍历字符串时，使用<code>num = num * 10 + int (s[i] - &#39;0&#39;);</code>对大数进行处理。</li><li>在乘除运算的结果都模拟入栈之后，使用累加函数<code>accumulate(st.begin(), st.end(), 0);</code>对数组进行累加处理，<code>accumulate()</code>函数包含在头文件<code>#include &lt;numeric&gt;</code>中，累加过程中，正负数都可以处理。</li></ul><h2 id="0x2-代码实现"><a href="#0x2-代码实现" class="headerlink" title="0x2.代码实现"></a>0x2.代码实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  main.cpp</span></span><br><span class="line"><span class="comment">//  Demo</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by Egan.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calculate</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; st; <span class="comment">//digits</span></span><br><span class="line">        <span class="keyword">char</span> ps = <span class="string">&#x27;+&#x27;</span>; <span class="comment">//presign</span></span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isdigit</span>(s[i]))&#123; <span class="comment">//#include &lt;cctype&gt;</span></span><br><span class="line">                num = num * <span class="number">10</span> + <span class="keyword">int</span> (s[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">isdigit</span>(s[i]) &amp;&amp; s[i] != <span class="string">&#x27; &#x27;</span> || i == s.length()<span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="keyword">switch</span>(ps)&#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span> :</span><br><span class="line">                        st.push_back(num);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span> :</span><br><span class="line">                        st.push_back(-num);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span> :</span><br><span class="line">                        st.back() *= num;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span> :</span><br><span class="line">                        st.back() /= num;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ps = s[i];</span><br><span class="line">                num = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> accumulate(st.begin(), st.end(), <span class="number">0</span>); <span class="comment">//#include&lt;numeric&gt;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日常 </tag>
            
            <tag> C++ </tag>
            
            <tag> Leetcode </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逆波兰表示法(Reverse Polish notation)</title>
      <link href="2021/03/01/Reverse%20Polish%20notation/"/>
      <url>2021/03/01/Reverse%20Polish%20notation/</url>
      
        <content type="html"><![CDATA[<p>根据逆波兰表示法，求表达式的值。</p><p>有效的运算符包括 <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code> 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。</p><span id="more"></span><h2 id="0x0-解题思路"><a href="#0x0-解题思路" class="headerlink" title="0x0.解题思路"></a>0x0.解题思路</h2><p>逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。</p><p>逆波兰表达式主要有以下两个优点：</p><ul><li><p>去掉括号后表达式无歧义，<code>( 1 + 2 ) * ( 3 + 4 )</code>即便写成 <code>1 2 + 3 4 + * </code>也可以依据次序计算出正确结果。</p></li><li><p>适合用栈操作运算</p></li></ul><p>逆波兰表达式的求解是栈的经典应用。所以此题采用栈来解决，遇到数字则入栈，遇到运算符则取出<strong>栈顶两个数字</strong>进行运算，<strong>并将结果压入栈中</strong>。</p><p>需要注意的是</p><ul><li><p>在运算的时候，需要后取出的数字在前，先取出的数字在后，即num2在前。</p></li><li><p><code>stoi</code>表示<code>string to int</code>，即字符串转整数</p></li></ul><h2 id="0x1-代码实现"><a href="#0x1-代码实现" class="headerlink" title="0x1.代码实现"></a>0x1.代码实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  main.cpp</span></span><br><span class="line"><span class="comment">//  Demo</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by Egan.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">evalRPN</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; tokens)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;tokens.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(tokens[i] == <span class="string">&quot;+&quot;</span>||tokens[i] == <span class="string">&quot;-&quot;</span>||tokens[i] == <span class="string">&quot;*&quot;</span>||tokens[i] == <span class="string">&quot;/&quot;</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> num1 = s.top();</span><br><span class="line">                s.pop();</span><br><span class="line">                <span class="keyword">int</span> num2 = s.top();</span><br><span class="line">                s.pop();</span><br><span class="line">                <span class="keyword">if</span>(tokens[i] == <span class="string">&quot;+&quot;</span>) s.push(num2 + num1);</span><br><span class="line">                <span class="keyword">if</span>(tokens[i] == <span class="string">&quot;-&quot;</span>) s.push(num2 - num1);</span><br><span class="line">                <span class="keyword">if</span>(tokens[i] == <span class="string">&quot;*&quot;</span>) s.push(num2 * num1);</span><br><span class="line">                <span class="keyword">if</span>(tokens[i] == <span class="string">&quot;/&quot;</span>) s.push(num2 / num1);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                s.push(stoi(tokens[i]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> result = s.top();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日常 </tag>
            
            <tag> C++ </tag>
            
            <tag> Leetcode </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>明明的随机数(Ming&#39;s random numbers)</title>
      <link href="2021/02/22/Ming&#39;s_random_numbers/"/>
      <url>2021/02/22/Ming&#39;s_random_numbers/</url>
      
        <content type="html"><![CDATA[<p>明明想在学校中请一些同学一起做一项问卷调查，为了实验的客观性，他先用计算机生成了N个1到1000之间的随机整数（N≤1000），对于其中重复的数字，只保留一个，把其余相同的数去掉，不同的数对应着不同的学生的学号。然后再把这些数从小到大排序，按照排好的顺序去找同学做调查。请你协助明明完成“去重”与“排序”的工作(同一个测试用例里可能会有多组数据(用于不同的调查)，希望大家能正确处理)</p><span id="more"></span><h2 id="0x0-解题思路"><a href="#0x0-解题思路" class="headerlink" title="0x0.解题思路"></a>0x0.解题思路</h2><p>这是华为的一道面试题。在原文中已经明确点出了所需的一些函数，分别是排序和去重。C++有现成的排序函数<code>sort()</code>，以及去重函数<code>unique()</code>。其中<code>unique()</code>,<code>sort()</code>都是属于头文件<code>#include &lt;algorithm&gt;</code></p><p><code>auto end_un = unique(vec.begin(),vec.end());</code></p><p>这里的<code>unique()</code>返回的值是<font color="#dd0000">最后一个不重复数字的下标。</font></p><p>sort函数有三个参数：</p><ul><li><p>第一个是要排序的数组的起始地址</p></li><li><p>第二个是结束的地址（最后一位要排序的地址)</p></li><li><p>第三个参数是排序的方法，可以是升序也可是降序。如果不写第三个参数，则默认的排序方法是升序排列</p></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//升序</span></span><br><span class="line">sort( a, b, less&lt;<span class="keyword">int</span>&gt;() );</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//降序</span></span><br><span class="line">sort( a, b, greater&lt;<span class="keyword">int</span>&gt;() );</span><br></pre></td></tr></table></figure><p>如果先<code>去重</code>再<code>排序</code>，那么<code>去重</code>就有可能不会发挥作用。因为<code>去重</code>再<code>排序</code>排序时会把重复的数字又放在了一起，所以要先<code>排序</code>再<code>去重</code>。</p><h2 id="0x1-代码实现"><a href="#0x1-代码实现" class="headerlink" title="0x1.代码实现"></a>0x1.代码实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  main.cpp</span></span><br><span class="line"><span class="comment">//  Demo</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by Egan.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">int</span> n= <span class="number">0</span>,num = <span class="number">0</span>;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//input</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; num;</span><br><span class="line">            vec.push_back(num);</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//sort</span></span><br><span class="line">        sort(vec.begin(), vec.end());</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//unique</span></span><br><span class="line">        <span class="keyword">auto</span> end_un = unique(vec.begin(),vec.end());</span><br><span class="line">        vec.erase(end_un, vec.end());</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> m = vec.begin(); m != vec.end(); m ++) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; *m &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日常 </tag>
            
            <tag> C++ </tag>
            
            <tag> Leetcode </tag>
            
            <tag> sort </tag>
            
            <tag> unique </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>毕业半年的自己</title>
      <link href="2020/12/22/Six_months_after_graduation/"/>
      <url>2020/12/22/Six_months_after_graduation/</url>
      
        <content type="html"><![CDATA[<h2 id="0x0-半年之后"><a href="#0x0-半年之后" class="headerlink" title="0x0.半年之后"></a>0x0.半年之后</h2><p>&emsp;我们这届的毕业生，大学只上了三年半，最后半年的时光都是在家里渡过。拿毕业证学位证、拍毕业照以及收拾行李，加起来不过两天时间。一切都是匆匆忙忙，匆忙到连一顿散伙饭都没法进行。<br><br>&emsp;还差几日，自己也就毕业半年了，也算是有了半年的<del>工作经验</del>(划水经验)，学软件的我，毕业之后进了一家偏自动化的公司，工业4.0时代嘛，天天代码倒是不多，感觉还不错。</p>]]></content>
      
      
      <categories>
          
          <category> 日常 </category>
          
          <category> 工作 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日常 </tag>
            
            <tag> 杂记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Test</title>
      <link href="2020/10/22/firstPage/"/>
      <url>2020/10/22/firstPage/</url>
      
        <content type="html"><![CDATA[<p><strong>测试文档</strong></p><pre><code>从这一篇测试文档开始，希望自己能够收起懒惰，重拾激情</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Test </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
