<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"blog.eganx.cn","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"remove","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="2023开年第一篇面经。部分答案由ChatGPT补充">
<meta property="og:type" content="article">
<meta property="og:title" content="2023第一篇面经">
<meta property="og:url" content="https://blog.eganx.cn/2023/02/26/2023_Interviews_No.1/index.html">
<meta property="og:site_name" content="Egan&#39;s Blog">
<meta property="og:description" content="2023开年第一篇面经。部分答案由ChatGPT补充">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-02-26T07:40:11.000Z">
<meta property="article:modified_time" content="2023-03-07T08:49:52.961Z">
<meta property="article:author" content="Egan Dong">
<meta property="article:tag" content="Go">
<meta property="article:tag" content="面试">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://blog.eganx.cn/2023/02/26/2023_Interviews_No.1/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>2023第一篇面经 | Egan's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Egan's Blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <h1 class="site-title">Egan's Blog</h1>
    </a>
      <p class="site-subtitle" itemprop="description">The winter is coming</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
				<!-- Matomo -->
				<script>
						var _paq = window._paq = window._paq || [];
						/* tracker methods like "setCustomDimension" should be called before "trackPageView" */
					  _paq.push(['trackPageView']);
					  _paq.push(['enableLinkTracking']);
					  (function() {
							 var u="https://matomo.eganx.cn:7003/matomo/";
							 _paq.push(['setTrackerUrl', u+'matomo.php']);
							 _paq.push(['setSiteId', '1']);
							 var d=document, g=d.createElement('script'), s=d.getElementsByTagName('script')[0];
							 g.async=true; g.src=u+'matomo.js'; s.parentNode.insertBefore(g,s);
					 })();
			 </script>
			 <!-- End Matomo Code -->
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.eganx.cn/2023/02/26/2023_Interviews_No.1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Egan Dong">
      <meta itemprop="description" content="You are more than what you have become">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Egan's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          2023第一篇面经
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-02-26 15:40:11" itemprop="dateCreated datePublished" datetime="2023-02-26T15:40:11+08:00">2023-02-26</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Work/" itemprop="url" rel="index"><span itemprop="name">Work</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>2023开年第一篇面经。部分答案由ChatGPT补充</p>
<span id="more"></span>

<h3 id="0x0-谈谈go的内存对齐"><a href="#0x0-谈谈go的内存对齐" class="headerlink" title="0x0.谈谈go的内存对齐"></a>0x0.谈谈go的内存对齐</h3><p>在 Go 语言中，内存对齐是指结构体成员（字段）在内存中的对齐方式。具体来说，它决定了一个结构体成员在内存中的起始地址，以及在内存中占用的字节数。</p>
<p>Go 语言会自动为结构体成员进行内存对齐，并根据需要在结构体成员之间填充空闲字节，以确保结构体成员在内存中的地址和长度都符合硬件要求。这种自动化的内存对齐机制可以提高内存读写效率，减少 CPU 访问内存时的等待时间。</p>
<p>在 Go 语言中，一个结构体成员的对齐方式取决于其类型和大小。具体来说，一个结构体成员的对齐方式必须满足以下条件：</p>
<ol>
<li> 结构体成员的首地址必须是其大小（即占用的字节数）的倍数。</li>
<li> 结构体成员的大小必须是 2 的整数次幂（即 1、2、4、8 等）。</li>
</ol>
<p>如果结构体成员的大小不是 2 的整数次幂，则需要填充额外的空间以满足对齐的要求。例如，在一个结构体中定义了一个 int8 类型的成员和一个 int32 类型的成员，那么在 int8 成员后面就需要填充 3 个字节的空闲空间，才能让 int32 成员的地址满足对齐的要求。</p>
<pre><code>需要注意的是，在 Go 语言中，结构体成员之间的空闲字节是不能被使用的，因此它们只是为了填充内存而存在。如果想要更精细地控制结构体成员的内存布局，可以使用 `unsafe` 包中的相关函数来手动调整内存对齐方式，但需要注意安全性问题。
</code></pre>
<p>在 Go 语言中，各个类型在内存对齐中所占大小如下：</p>
<ol>
<li><p>bool：1 字节。</p>
</li>
<li><p>int8、uint8（即 byte）、int16、uint16：2 字节。</p>
</li>
<li><p>int32、uint32、float32：4 字节。</p>
</li>
<li><p>int64、uint64、float64、complex64：8 字节。</p>
</li>
<li><p>complex128：16 字节。</p>
</li>
<li><p>string、slice、指针、map、channel 等引用类型：8 字节（在 64 位架构中）或 4 字节（在 32 位架构中），其中包含的是一个指向底层数据结构的指针。</p>
</li>
<li><p>struct 类型的大小取决于其成员变量的大小和排列方式，由编译器自动进行内存对齐。</p>
</li>
</ol>
<p><font color = LigBlue>这里给出的是一个基本的规则，实际上不同的编译器和操作系统可能会有不同的对齐方式和字节数。</font></p>
<p>Go语言的unsafe包提供了一些底层操作，包括调整内存对齐。可以使用unsafe包中的Alignof和Offsetof函数来获取结构体中字段的对齐方式和偏移量，然后使用uintptr类型的指针进行指针运算和内存地址计算。使用unsafe.Pointer类型的指针可以将任何类型的指针转换为通用指针类型，从而进行底层操作。但是需要注意，在使用unsafe包时要特别小心，因为它可能会导致程序不安全或不可移植。</p>
<h3 id="0x1-谈谈TCP和UDP的区别"><a href="#0x1-谈谈TCP和UDP的区别" class="headerlink" title="0x1. 谈谈TCP和UDP的区别"></a>0x1. 谈谈TCP和UDP的区别</h3><p>TCP（Transmission Control Protocol）和UDP（User Datagram Protocol）是两种网络协议，用于在计算机上运行的应用程序之间传输数据。它们有以下几个主要区别：</p>
<ol>
<li>连接：TCP是面向连接的协议，而UDP是无连接的协议。TCP通过三次握手建立连接，然后在发送和接收数据之前进行验证和确认。而UDP直接发送数据，没有连接的建立和维护过程。</li>
<li>可靠性：TCP提供可靠的数据传输，确保数据按照发送顺序到达目标地址，并且不会丢失或重复。它通过重传丢失的数据包、流量控制和拥塞控制等机制来保证数据传输的可靠性。而UDP不提供可靠性保证，数据包可能会丢失、重复、乱序等，需要应用层自己处理。</li>
<li>效率：由于TCP提供了可靠的数据传输和额外的控制协议，因此它通常比UDP慢一些，但比较稳定。而UDP没有这些额外的控制协议，因此速度比TCP快，但不够稳定。</li>
<li> 适用场景：TCP适用于需要可靠数据传输且需要顺序传输的应用程序，如文件传输、电子邮件、网页浏览等；而UDP适用于实时性要求高、对数据完整性和顺序性要求不高的应用程序，如音频、视频、游戏等。</li>
</ol>
<p>补充：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TCP的三次握手是指在建立TCP连接时，客户端和服务器之间需要进行三次交互来确认双方的通信状态。具体过程如下：</span><br><span class="line">1.  客户端向服务器发送SYN（同步）报文，表示客户端请求建立连接，并给这个数据包分配一个随机的初始序列号（ISN）。</span><br><span class="line">2.  服务器收到客户端的SYN报文后，回复一个SYN+ACK（同步&#x2F;确认）报文，表示接收到了客户端的连接请求，并确认自己也希望建立连接。同时，在这个SYN+ACK报文中也会分配一个随机的初始序列号。</span><br><span class="line">3.  客户端再次回复一个ACK（确认）报文，表示已经收到了服务器的确认，可以开始传输数据了。此时，TCP连接就建立完成了。</span><br><span class="line"></span><br><span class="line">在这个过程中，第一次握手是客户端向服务器发起连接请求，第二次握手是服务器接收客户端的请求并回复确认，第三次握手是客户端回复服务器的确认。这样，双方都确认了自己和对方的状态，保证了数据传输的可靠性。</span><br></pre></td></tr></table></figure>

<h3 id="0x2-谈一下golang死锁"><a href="#0x2-谈一下golang死锁" class="headerlink" title="0x2. 谈一下golang死锁"></a>0x2. 谈一下golang死锁</h3><p>在golang中，死锁指的是一种场景，即所有goroutine都被互相等待，导致程序无法继续执行。这种情况通常出现在使用channel进行通信时，并且没有正确地管理好goroutine之间的通信流程。</p>
<p>一个常见的例子是两个goroutine相互等待对方释放锁的情况，如下面的代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        &lt;-ch <span class="comment">// 1. 等待从通道中读取数据</span></span><br><span class="line">        ch &lt;- <span class="number">1</span> <span class="comment">// 3. 向通道中写入数据</span></span><br><span class="line">    &#125;()</span><br><span class="line">    ch &lt;- <span class="number">1</span> <span class="comment">// 2. 向通道中写入数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这段代码中，第一个goroutine等待从通道中读取数据（步骤1），但是在这之前它必须等待第二个goroutine向通道中写入数据（步骤2）。而第二个goroutine同样需要等待第一个goroutine从通道中读取数据后才能向通道中写入数据（步骤3）。因此，在这种情况下，两个goroutine将会陷入无限期的等待，导致程序无法继续执行，最终出现死锁。</p>
<pre><code>为了避免死锁的发生，需要合理地设计和管理goroutine之间的通信流程，确保每个goroutine在正确的时间点上释放锁并等待其它goroutine的响应。此外，可以使用go语言内置的工具来帮助检测和解决死锁问题，例如`go vet`、`go tool vet`等。
</code></pre>
<h3 id="0x3-Go的并发机制"><a href="#0x3-Go的并发机制" class="headerlink" title="0x3. Go的并发机制"></a>0x3. Go的并发机制</h3><p>Go语言的并发机制是一种基于Goroutine和Channel的轻量级协程模型，具有高效、简洁、安全等特点，可用于实现高并发、分布式、异步和并行计算等场景。下面详细介绍Go语言的并发机制。</p>
<ol>
<li> Goroutine<br>Goroutine是一种轻量级的用户态线程，由Go运行时系统调度，在单个操作系统线程上并发执行多个任务。Goroutine的创建非常简单，只需使用关键字go后跟需要执行的函数即可：</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Hello, Goroutine!&quot;</span>)</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，使用go关键字启动一个新的Goroutine，执行匿名函数并输出”Hello, Goroutine!”。与传统的线程相比，Goroutine更加轻量级、灵活、高效，因为它们可以在需要时自动伸缩，并且可以通过通信来共享数据和协调行为，无需显式的锁或条件变量等同步机制。</p>
<ol start="2">
<li><p>Channel</p>
<p>Channel是Goroutine之间进行通信的一种方式，它类似于UNIX中的管道，可以将数据从一个Goroutine发送到另一个Goroutine。Channel有以下几个特点：</p>
</li>
</ol>
<ul>
<li>  Channel是类型化的，必须指定传输数据的类型；</li>
<li>  Channel是同步的，发送和接收操作都会阻塞，直到对应的另一个Goroutine完成了配对操作；</li>
<li>  Channel是并发安全的，多个Goroutine同时操作同一个Channel时不会出现竞态条件或死锁等问题。</li>
</ul>
<p>可以通过make函数创建Channel示例：<br><code>ch := make(chan int)  // 创建一个int类型的Channel</code></p>
<p>通过&lt;-符号进行发送和接收操作：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch &lt;- <span class="number">1</span>     <span class="comment">// 向Channel中发送数据</span></span><br><span class="line">value := &lt;-ch   <span class="comment">// 从Channel中接收数据</span></span><br></pre></td></tr></table></figure>
<p>同时，可以使用range关键字遍历Channel中的所有数据，或者使用select结构体实现多路复用等操作。</p>
<ol start="3">
<li> 共享内存</li>
</ol>
<p>除了使用Channel进行通信外，Go语言也支持传统的共享内存并发模型，例如使用sync包中提供的锁（Mutex）和条件变量（Cond）等机制。这些机制可以在多个Goroutine之间共享访问同一份数据，并进行同步和互斥等操作。</p>
<ol start="4">
<li> 原子操作</li>
</ol>
<p>为了避免竞态条件等问题，Go语言还提供了原子操作（atomic）机制，用于保证对共享资源的并发访问的原子性和一致性。原子操作包括原子增减、原子比较交换、原子读写等操作，可以有效地解决多个Goroutine同时对同一份数据进行操作的问题。</p>
<p>总体来说，Go语言的并发机制具有高效、简洁、安全等优点，使得它成为了开发高并发、分布式、异步和并行计算等应用程序的理想语言和工具。</p>
<h3 id="0x4-MVC-和-MVVM的异同"><a href="#0x4-MVC-和-MVVM的异同" class="headerlink" title="0x4. MVC 和 MVVM的异同"></a>0x4. MVC 和 MVVM的异同</h3><p>MVC (Model-View-Controller) 和 MVVM (Model-View-ViewModel) 是两种常见的应用程序设计模式，其目的都是在应用程序中清晰地分离数据、用户界面和业务逻辑。虽然这两种模式都有类似的架构，但它们之间存在一些重要的区别。</p>
<p><strong>MVC 模式：</strong><br>MVC 模式是一种传统的模式，最早用于桌面应用程序的设计。在 MVC 中，软件应用程序被划分为三个部分：模型（Model）、视图（View）和控制器（Controller）。</p>
<ul>
<li>  Model是应用程序中的数据和状态的主要表示。它与数据库或其他持久性存储解耦，并提供了一个简单的接口来获取和设置数据。</li>
<li>  View是用户界面的呈现，它负责显示 Model 对象的当前状态。</li>
<li>  Controller 接收用户输入并根据需要更新 Model 和 View。 它充当 View 和 Model 之间的协调者，并包含适当的逻辑和算法来更新它们。</li>
</ul>
<p>MVC 模式的优点是强制实现代码的分离和组织方式，使得代码更加清晰和易于维护。但是，MVC 模式可能会导致控制器变得过于复杂，因为它承担了太多的责任。</p>
<p><strong>MVVM 模式：</strong><br>MVVM 模式是一种比较新的模式，最初用于 Windows Presentation Foundation (WPF) 的设计。在 MVVM 中，应用程序也被划分为三个部分：模型（Model）、视图（View）和视图模型（ViewModel）。</p>
<ul>
<li>  Model 与 MVC 模式相同，表示应用程序中的数据和状态。</li>
<li>  View 是用户界面的呈现，它负责显示视图模型（ViewModel）所公开的属性和命令。</li>
<li>  ViewModel 是 View 和 Model 之间的连接器，它充当模型和视图之间的协调者。ViewModel 将 Model 对象转换为 View 可以直接使用的格式，并将数据绑定到 View 上。</li>
</ul>
<p>MVVM 模式的优点是更好的可扩展性和可维护性，因为 ViewModel 在处理显示逻辑时不会像控制器那样过于复杂，而且数据绑定功能可以减少代码的重复和冗余。然而，MVVM 模式需要更多的学习和实践，特别是在处理大量异步操作和复杂 UI 逻辑时。</p>
<h3 id="0x5-进程、线程、协程的区别"><a href="#0x5-进程、线程、协程的区别" class="headerlink" title="0x5. 进程、线程、协程的区别"></a>0x5. 进程、线程、协程的区别</h3><p>进程、线程和协程的区别主要表现在以下几个方面：</p>
<ol>
<li><p>调度方式：进程和线程都由操作系统进行调度，而协程的调度是由程序员手动控制。</p>
</li>
<li><p>系统开销：每个进程都有独立的内存空间和系统资源，所以创建和撤销进程的代价比较大。线程共享相同的内存空间和资源，所以创建和撤销线程的代价比进程要小一些。而协程则更加轻量级，创建和撤销协程的代价最小。</p>
</li>
<li><p>内存空间：每个进程都有自己独立的内存空间，不同进程之间的内存无法共享。线程共享相同的内存空间，但是需要考虑线程安全问题。协程也共享相同的内存空间，但是可以通过控制协程的执行顺序来避免线程安全问题。</p>
</li>
<li><p>执行速度：由于每个进程都有独立的内存空间和资源，因此进程之间的通信和同步比较慢。线程共享相同的内存空间和资源，因此线程之间的通信和同步比进程快一些。协程更快速和高效，因为它们不需要像线程那样切换上下文。</p>
</li>
</ol>
<h3 id="0x6-Go的GC机制"><a href="#0x6-Go的GC机制" class="headerlink" title="0x6. Go的GC机制"></a>0x6. Go的GC机制</h3><p>三色标记法、混合读写屏障。<a href="https://blog.eganx.cn/2022/11/16/Go_GC/">之前的笔记📒balabalabala</a></p>
<h3 id="0x7-如何连通两个互不相连的局域网"><a href="#0x7-如何连通两个互不相连的局域网" class="headerlink" title="0x7. 如何连通两个互不相连的局域网"></a>0x7. 如何连通两个互不相连的局域网</h3><p>两个互不相连的局域网要进行通信，可以通过以下几种方式实现：</p>
<ol>
<li>VPN（Virtual Private Network）：通过在公共网络上建立虚拟专用网络来连接两个局域网。VPN 可以使用安全的加密协议来保护通信数据的安全性。</li>
<li>隧道（Tunneling）：通过在公共网络上建立一个隧道来连接两个局域网。隧道可以使用加密协议来保护通信数据的机密性和完整性。</li>
<li>NAT（Network Address Translation）转换：使用 NAT 转换器将两个局域网中的 IP 地址转换为公网 IP 地址，从而使它们可以相互访问。</li>
<li>代理服务器（Proxy Server）：在两个局域网之间放置一个代理服务器，通过代理服务器进行通信。</li>
<li>公共云服务（Public Cloud Service）：将两个局域网连接到同一个公共云服务中，并使用该服务提供的网络功能进行通信。</li>
</ol>
<p>总的来说，连接两个互不相连的局域网需要考虑数据安全性、通信速度、成本等因素，选择合适的方法进行连接。</p>
<h3 id="0x7-开放式讨论"><a href="#0x7-开放式讨论" class="headerlink" title="0x7. 开放式讨论"></a>0x7. 开放式讨论</h3><ul>
<li><input disabled="" type="checkbox"> C#和Go的区别  开放式  随便说</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Go/" rel="tag"># Go</a>
              <a href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag"># 面试</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/02/04/1.%20Two_sum/" rel="prev" title="1. 两数之和">
      <i class="fa fa-chevron-left"></i> 1. 两数之和
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  Copyright&copy; 2020–
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class=""></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Egan Dong</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
