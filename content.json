{"meta":{"title":"Egan's Blog","subtitle":"一个人的小破站","description":"You are more than what you have become","author":"Egan Dong","url":"https://blog.eganx.cn","root":"/"},"pages":[{"title":"关于","date":"2020-12-22T08:06:06.000Z","updated":"2022-11-14T09:10:49.916Z","comments":true,"path":"about/index.html","permalink":"https://blog.eganx.cn/about/index.html","excerpt":"","text":"一个写C#客户端的小垃圾，偶尔用Go写点服务端。毕业两年多，啥也不是…… 附上我的垃圾Github 个人说明： 该用户很宅 该用户不吸烟 该用户使用Linux 该用户支持言论自由 该用户认为知易行难 该用户日常靠咖啡续命 该用户反对读书无用论 该用户不喜欢微信和QQ 该用户对电脑程序感兴趣 该用户谢绝使用百度搜索引擎 该用户正在为了旅行自由努力赚钱 该用户认为自己可以成为一个还不错的厨子"},{"title":"分类","date":"2020-12-22T08:07:23.000Z","updated":"2020-12-22T08:08:17.000Z","comments":true,"path":"categories/index.html","permalink":"https://blog.eganx.cn/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2020-12-22T08:08:32.000Z","updated":"2020-12-22T08:09:05.000Z","comments":true,"path":"link/index.html","permalink":"https://blog.eganx.cn/link/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-12-22T08:06:06.000Z","updated":"2020-12-22T08:07:11.000Z","comments":true,"path":"tags/index.html","permalink":"https://blog.eganx.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"C# GC机制(Garbage Collector)","slug":"CSharp_GC_mechanism","date":"2022-02-08T13:31:19.000Z","updated":"2022-11-15T08:11:29.503Z","comments":true,"path":"2022/02/08/CSharp_GC_mechanism/","link":"","permalink":"https://blog.eganx.cn/2022/02/08/CSharp_GC_mechanism/","excerpt":"记录一下C#中GC的相关知识。不记下来，下次又找不到，就很烦。 主要针对的是C#中如何判定Garbage和GC的运作方式。","text":"记录一下C#中GC的相关知识。不记下来，下次又找不到，就很烦。 主要针对的是C#中如何判定Garbage和GC的运作方式。 0x0.资源概念所谓的资源其实就是程序中可以利用的数据。比如字符串、图片和任何的二进制数据。 托管资源，非托管资源：托管资源是由CLR全权负责的资源，CLR不负责的资源位非托管资源。对于托管资源通过GC自动清理回收。对于非托管的资源，一般就是Stream，数据库的连接，网络连接，GDI+的相关对象，还有Com对象等等这些操作系统资源，需要我们手动去释放，再由GC回收。 0x1.Garbage的判定.Net类型分为两大类，一个就是值类型，另一个就是引用类型。前者是在堆栈中分配内存，它们有自身的生命周期，所以不用对它们进行管理，会自动分配和释放。后者是在堆中分配内存的。所以它的分配和释放就需要像回收机制来管理。 GC的全称为“Garbage Collector”,顾名思义就是垃圾回收器，那么只有被称为垃圾的对象才能被GC回收。也就是说， 一个引用类型对象所占用的内存需要被GC回收，需要先成为垃圾。 .Net判定一个引用类型对象是垃圾，只需要判定此对象或者其包含的子对象没有任何引用是有效的，那么系统就认为它是垃圾。 0x2.非托管资源的释放方式1).Close()关闭对象资源，在显示调用时被调用。 2).Dispose()继承IDisposable接口，实现Dispose方法；介绍：调用Dispose方法，销毁对象，需要显示调用或者通过using语句，在显示调用或者离开using程序块时被调用。Dispose方法用于清理对象封装的非托管资源，而不是释放对象的内存，对象的内存依然由垃圾回收器控制。Dispose方法调用，不但释放该类的非托管资源，还释放了引用的类的非托管资源。Dispose模式就是一种强制资源清理所要遵守的约定；Dispose模式实现IDisposable接口，从而使得该类型提供一个公有的Dispose方法。 而Close与Dispose这两种方法的区别在于，调用完了对象的Close方法后，此对象有可能被重新进行使用；而Dispose方法来说，此对象所占有的资源需要被标记为无用了，也就是此对象被销毁了，不能再被使用。 3).析构函数/Finalize()带有析构函数的类，生命周期会变长。内存空间需要两次垃圾回收才会被释放，导致性能下降。 一个正常情况的类是不会写析构函数的，而一旦一个类写了析构函数，就意味着GC会在不确定的时间调用该类的析构函数，判断该类的资源是否需要释放，然后调用Finalize方法，如果重写了Finalize方法则调用重写的Finalize方法。Finalize方法的作用是保证.NET对象能在垃圾回收时清除非托管资源。在.NET中，Object.Finalize()方法是无法重载的，编译器是根据类的析构函数来自动生成Object.Finalize()方法的Finalize由垃圾回收器调用；dispose由对象调用。Finalize无需担心因为没有调用Finalize而使非托管资源得不到释放，因为GC会在不确定时间调用，当然，你也可以手动调用Finalize方法，而dispose必须手动调用。Finalize虽然无需担心因为没有调用Finalize而使非托管资源得不到释放，但因为由垃圾回收器管理，不能保证立即释放非托管资源；而dispose一调用便释放非托管资源。只有类类型才能重写Finalize，而结构不能；类和结构都能实现IDispose 释放模式：是一种微软建议的写法，先手动显示去释放资源，如果忘记了，再让finalize释放资源。所以如果已经完成了析构函数该干的事情(例如释放非托管资源)，就应当使用SuppressFinalize方法告诉GC不需要再执行某个对象的析构函数。 0x3.GC的运作方式内存的释放和回收需要伴随着程序的运行，因此系统为GC安排了独立的线程。那么GC的工作大致是，查询内存中对象是否成为垃圾，然后对垃圾进行释放和回收。那么对于GC对于内存回收采取了一定的优先算法进行轮循回收内存资源。 其次，对于内存中的垃圾分为两种，一种是需要调用对象的析构函数，另一种是不需要调用的。GC对于前者的回收需要通过两步完成，第一步是调用对象的析构函数，第二步是回收内存，但是要注意这两步不是在GC一次轮循完成，即需要两次轮循；相对于后者，则只是回收内存而已。 C#中的GC使用了Generation的概念，它将分配的对象分为3代(可用GC.GetGeneration方法返回任意作为参数的对象当前所处的代)。 最近被分配内存的对象被放置于第0代，因为第0代很小，小到足以放进处理器的二级（L2)缓存，所以它能够提供对对象的快速存取。经过一轮垃圾回收后，仍然保留在第0代中的对象被移进第1代中，再经过一轮垃圾内存回收后，仍然保留在第1代中的对象则被移进第2代中，第2代中包含了生存期较长的对象。 当第0代中没有可以分配的有效内存时，就触发了第0代中的一轮垃圾回收，它将删除那些不再被引用的对象，并将当前正在使用的对象移至第1代。而当第0代垃圾回收后依然不能请求到充足的内存时，就启动第1代垃圾回收。如果对各代都进行了垃圾回收后仍没有可用的内存就会引发一个OutOfMemoryException异常。 Close Dispose 析构函数 关闭对象资源 销毁对象 销毁对象 调用方式 需要显示调用 需要显示调用或者通过using语句 不能被显示调用，会被GC调用 调用时机 在显示调用时 在显示调用或者离开using程序块 不确定","categories":[{"name":"工作","slug":"工作","permalink":"https://blog.eganx.cn/categories/%E5%B7%A5%E4%BD%9C/"}],"tags":[{"name":"C#","slug":"C","permalink":"https://blog.eganx.cn/tags/C/"},{"name":"GC","slug":"GC","permalink":"https://blog.eganx.cn/tags/GC/"}]},{"title":"Go版本切换","slug":"Go_Version_switching","date":"2022-01-05T13:06:11.000Z","updated":"2022-11-15T08:12:48.589Z","comments":true,"path":"2022/01/05/Go_Version_switching/","link":"","permalink":"https://blog.eganx.cn/2022/01/05/Go_Version_switching/","excerpt":"线上的程序用的是老版本的Go(毕竟比较稳)，自己又想尝试新的版本特性。久而久之，电脑里面SDK的版本就越来越多了，每次切换起来就很麻烦。所以特此记录一下。","text":"线上的程序用的是老版本的Go(毕竟比较稳)，自己又想尝试新的版本特性。久而久之，电脑里面SDK的版本就越来越多了，每次切换起来就很麻烦。所以特此记录一下。 0x0.手动管理(目前使用的切换方式)官网下载最新版Archive文件go1.18beta1.darwin-amd64.tar.gz 解压缩重命名go1.18.beta1,拷贝一份放到默认安装路径/usr/local/go1.18beta1 sudo cp -R /User/egan/Sdks/go1.18beta1 /usr/local/go1.18beta1 进入默认安装路径，创建软链 cd /usr/local/sudo ln -s go1.18beta1 go 0x1.版本切换工具1).gGitHub: https:&#x2F;&#x2F;github.com&#x2F;voidint&#x2F;g 2).goupGithub: https:&#x2F;&#x2F;github.com&#x2F;owenthereal&#x2F;goup","categories":[{"name":"工作","slug":"工作","permalink":"https://blog.eganx.cn/categories/%E5%B7%A5%E4%BD%9C/"}],"tags":[{"name":"go","slug":"go","permalink":"https://blog.eganx.cn/tags/go/"},{"name":"版本切换","slug":"版本切换","permalink":"https://blog.eganx.cn/tags/%E7%89%88%E6%9C%AC%E5%88%87%E6%8D%A2/"}]},{"title":"C#内存泄露","slug":"CSharp_OOM","date":"2022-01-03T04:31:19.000Z","updated":"2022-11-15T08:12:21.125Z","comments":true,"path":"2022/01/03/CSharp_OOM/","link":"","permalink":"https://blog.eganx.cn/2022/01/03/CSharp_OOM/","excerpt":"记录自己干的蠢事，这也是自己第一次在工作中写出来内存泄漏。幸亏程序没有直接上线，以后还是要多测试测试自己的代码。","text":"记录自己干的蠢事，这也是自己第一次在工作中写出来内存泄漏。幸亏程序没有直接上线，以后还是要多测试测试自己的代码。 0x0.问题产生原因在button1.Click += Button1_Click中，(+=) 来为事件附加事件处理程序 public Form1()&#123; InitializeComponent(); button1.Click += Button1_Click;&#125;private void Button1_Click(object sender, EventArgs e) &#123; System.Diagnostics.Debug.Print(&quot;x&quot;); &#125; public event EventHandler Click;public delegate void EventHandler(object sender, EventArgs e); 给button1_Click的附加事件处理程序放在了心跳里面； 此次溢出是因为每次心跳，又进行了一次事件处理程序的附加，造成不断附件事件处理程序。 直至最后，点击一次，要运行2K+次的事件处理程序。 而事件处理程序的代码里面会使用创建新的线程，运行一次，创建大量的新线程，线程数直接飙升，内存崩掉。 0x1.定位内存泄露发生的地方：C#的代码可以使用内存分析工具dotMemory。dotMemory允许你分析各种.NET和.NET Core应用程序的内存使用情况；比如桌面应用程序、Windows服务、ASP.NET Web应用程序、IIS、IIS Express、任意.NET进程等。不过临时用一下可以，有30天的试用期，还是比较好用的。 溢出版本源码示例: namespace WindowsFormsApp1&#123; public partial class Form1 : Form &#123; private static int i = 0; public Form1() &#123; InitializeComponent(); button1.Click += Button1_Click; &#125; private void Cycle() &#123; button1.Click += Button1_Click; &#125; private void Button1_Click(object sender, EventArgs e) &#123; i += 1; System.Diagnostics.Debug.Print(&quot;x:&#123;0&#125;&quot;,i); Cycle(); &#125; &#125;&#125; 正常版本源码示例： namespace WindowsFormsApp1&#123; public partial class Form1 : Form &#123; private static int i = 0; public Form1() &#123; InitializeComponent(); button1.Click += Button1_Click; &#125; private void Button1_Click(object sender, EventArgs e) &#123; i += 1; System.Diagnostics.Debug.Print(&quot;x:&#123;0&#125;&quot;,i); &#125; &#125;&#125;","categories":[{"name":"工作","slug":"工作","permalink":"https://blog.eganx.cn/categories/%E5%B7%A5%E4%BD%9C/"}],"tags":[{"name":"C#","slug":"C","permalink":"https://blog.eganx.cn/tags/C/"},{"name":"OOM","slug":"OOM","permalink":"https://blog.eganx.cn/tags/OOM/"}]},{"title":"C#串口读写连续性问题","slug":"CSharp_Serial_port_readwrite_continuity_problem","date":"2022-01-01T03:31:19.000Z","updated":"2022-11-15T08:12:32.889Z","comments":true,"path":"2022/01/01/CSharp_Serial_port_readwrite_continuity_problem/","link":"","permalink":"https://blog.eganx.cn/2022/01/01/CSharp_Serial_port_readwrite_continuity_problem/","excerpt":"在使用串口协议进行自定义协议读写的时候，一般使用Ascii编码。但是串口中读取到的数据并不能保证其完整性。一条指令有可能会被拆分成多条数据发送，读取到的字符串有可能只是其中的一部分。一般一条指令的末尾都会加上\\n\\r作为结束符。","text":"在使用串口协议进行自定义协议读写的时候，一般使用Ascii编码。但是串口中读取到的数据并不能保证其完整性。一条指令有可能会被拆分成多条数据发送，读取到的字符串有可能只是其中的一部分。一般一条指令的末尾都会加上\\n\\r作为结束符。 0x0.创建连接串口使用System.IO.Ports.SerialPort来创建连接 //// 摘要:// 使用指定的端口名、波特率、奇偶校验位、数据位和停止位初始化 System.IO.Ports.SerialPort 类的新实例。//// 参数:// portName:// 要使用的端口（例如 COM1）。//// baudRate:// 波特率。//// parity:// System.IO.Ports.SerialPort.Parity 值之一。//// dataBits:// 数据位值。//// stopBits:// System.IO.Ports.SerialPort.StopBits 值之一。//// 异常:// T:System.IO.IOException:// 未能找到或打开指定的端口。public SerialPort(string portName, int baudRate, Parity parity, int dataBits, StopBits stopBits); 其中Parity和StopBits的枚举分别为： //// 摘要:// 指定 System.IO.Ports.SerialPort 对象的奇偶校验位。public enum Parity&#123; // // 摘要: // 不发生奇偶校验检查。 None = 0, // // 摘要: // 设置奇偶校验位，使位数等于奇数。 Odd = 1, // // 摘要: // 设置奇偶校验位，使位数等于偶数。 Even = 2, // // 摘要: // 将奇偶校验位保留为 1。 Mark = 3, // // 摘要: // 将奇偶校验位保留为 0。 Space = 4&#125; //// 摘要:// 指定在 System.IO.Ports.SerialPort 对象上使用的停止位的数目。public enum StopBits&#123; // // 摘要: // 不使用停止位。 System.IO.Ports.SerialPort.StopBits 属性不支持此值。 None = 0, // // 摘要: // 使用一个停止位。 One = 1, // // 摘要: // 使用两个停止位。 Two = 2, // // 摘要: // 使用 1.5 个停止位。 OnePointFive = 3&#125; 连接完成后需要保证端口的开启，可使用IsOpen参数进行判定。 if (!Conn.IsOpen)&#123; Conn.Open();&#125; 0x1.数据的读写部分何时停止读写，可以根据NewLine的值进行判定。NewLine的默认值是”\\n”换行符，可以根据自己的需求进行更改。”\\r\\n”也是比较常用的NewLine。 //// 摘要:// 获取或设置用于解释 System.IO.Ports.SerialPort.ReadLine 和 System.IO.Ports.SerialPort.WriteLine(System.String)// 方法调用结束的值。//// 返回结果:// 表示行尾的值。 默认值为换行符，System.Environment.NewLine。//// 异常:// T:System.ArgumentException:// 属性值为空。//// T:System.ArgumentNullException:// 属性值为 null。[Browsable(false)][DefaultValue(&quot;\\n&quot;)][MonitoringDescription(&quot;NewLine&quot;)]public string NewLine &#123; get; set; &#125; 如果不想直接设置NewLine，也可以在读取串口数据时，根据自定义字符进行读取划分。 //// 摘要:// 一直读取到输入缓冲区中的指定 value 的字符串。//// 参数:// value:// 指示读取操作停止位置的值。//// 返回结果:// 输入缓冲区中直到指定 value 的内容。//// 异常:// T:System.ArgumentException:// value 参数的长度为 0。//// T:System.ArgumentNullException:// value 参数为 null。//// T:System.InvalidOperationException:// 指定的端口未打开。//// T:System.TimeoutException:// 该操作未在超时时间到期之前完成。public string ReadTo(string value); string reqStr = Conn.ReadTo(&quot;\\r\\n&quot;); 这样读取出来的数据就可以时一条条完整的指令，而不会出现被分隔的指令片段。","categories":[{"name":"工作","slug":"工作","permalink":"https://blog.eganx.cn/categories/%E5%B7%A5%E4%BD%9C/"}],"tags":[{"name":"C#","slug":"C","permalink":"https://blog.eganx.cn/tags/C/"},{"name":"Serial","slug":"Serial","permalink":"https://blog.eganx.cn/tags/Serial/"}]},{"title":"华为OD笔试","slug":"Huawei_OD_exam","date":"2021-03-09T03:30:12.000Z","updated":"2022-11-15T08:13:18.780Z","comments":true,"path":"2021/03/09/Huawei_OD_exam/","link":"","permalink":"https://blog.eganx.cn/2021/03/09/Huawei_OD_exam/","excerpt":"第一次参加华为OD的笔试，作为参加过精英笔试的优秀青年。我还是想记录一下的。说实话题目还行，但是裸考还是有点难度的(个人观点，或许是我菜的过分了)。","text":"第一次参加华为OD的笔试，作为参加过精英笔试的优秀青年。我还是想记录一下的。说实话题目还行，但是裸考还是有点难度的(个人观点，或许是我菜的过分了)。 0x0.第一题用一个数组A，代表程序员的工作能力。公司想通过结对编程的模式来提高员工的工作能力，假设成对后的能力是两个员工的能力之和，求一共有多少种结对方式，使结对后的能力为N。 提示： 1. 第一行代表员工个数2. 第二行代表各个员工的能力值3. 第三行代表结对后的能力值N4. 输出为结对的组合方式的值 示例： 输入：51 2 2 2 34输出：4 1).解题思路说实话这题放在华为OD的笔试里面，应该是属于送分题，一个输入数组加两层for循环直接解就行，直接附上代码就算了。 2).代码实现//// main.cpp// Demo//// Created by Egan.// #include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;numeric&gt;#include &lt;cctype&gt;using namespace std; int main() &#123; int n,N; int arr[1001]; int count =0; cin &gt;&gt; n; for(int i = 0; i &lt; n; i++)&#123; cin &gt;&gt; arr[i]; &#125; cin &gt;&gt; N; for(int x =0; x &lt; n; x++ )&#123; for(int y= x+1; y &lt;n; y++ )&#123; if(arr[x]+arr[y] == N) count += 1; &#125; &#125; cout &lt;&lt; count &lt;&lt;endl;&#125; 0x1.错误的里程表一个汽车里程表，它以整数形式显示行驶的英里数。然而，里程表有一个缺陷:它从数字3转到数字5，总是跳过数字4。这个缺陷出现在所有的位置(1,10,100，等等)。例如，如果里程表显示为15339，而汽车行驶了1英里，里程表的读数将更改为15350(而不是15340)。 提示： 1. 输入为里程表上的数值2. 输出为实际车子行驶的数值 示例： 输入1：5输出1：3输入2：17输出2：15输入3：100输出3：81 1).解题思路遇到4则直接从3进位到5，所以这是一道典型的进制转化问题，遍历该数字的每一位（如果这一位的数字比4大，就要减去1，因为这个位跳过了一个4），然后再遍历该数字的每一位，将其转化为10进制。 2).代码实现//// main.cpp// Demo//// Created by Egan.//#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;cstdio&gt;using namespace std;int main()&#123; string n; for (int i = 0;; i++) &#123; cin &gt;&gt; n; if(n[0] == &#x27;0&#x27;)&#123; break; &#125; int j = n.size; long long num = 0; ans = 1; for (int m = j-1; m &gt;= 0; m--) &#123; if((n[m]-&#x27;0&#x27;)&gt;4)&#123; num += ((n[m]-&#x27;0&#x27;)-1) * ans; &#125; else&#123; num += (n[m]-&#x27;0&#x27;) * ans; &#125; ans = ans * 9; &#125; cout &lt;&lt; n &lt;&lt; &quot;:&quot;&lt;&lt;num&lt;&lt;endl; &#125;&#125; 0x2.贪吃蛇算法题目太长，具体的记不清楚了，只能大致的描述一下。。。。 输入一个字符矩阵，其中字符E是食物(蛇吃了长度+1的那种)，F是空白，H是蛇的位置(初始只占一个位置) 移动指令有5种，分别让贪吃蛇移动以及转向：G前进、U往上转、D往下转、L往左转、R往右转（初始方向为左） 结束条件是碰壁或者碰到自己就算死了。 求按输入的指令执行之后的蛇的长度。 输入输出示例： 输入：D G G3F E FE E HF F F输出：1","categories":[{"name":"日常","slug":"日常","permalink":"https://blog.eganx.cn/categories/%E6%97%A5%E5%B8%B8/"},{"name":"工作","slug":"日常/工作","permalink":"https://blog.eganx.cn/categories/%E6%97%A5%E5%B8%B8/%E5%B7%A5%E4%BD%9C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://blog.eganx.cn/tags/C/"},{"name":"华为OD","slug":"华为OD","permalink":"https://blog.eganx.cn/tags/%E5%8D%8E%E4%B8%BAOD/"},{"name":"笔试","slug":"笔试","permalink":"https://blog.eganx.cn/tags/%E7%AC%94%E8%AF%95/"}]},{"title":"基础计算器II (Basic calculator II)","slug":"Basic_calculator_II","date":"2021-03-02T02:22:11.000Z","updated":"2022-11-15T08:11:05.471Z","comments":true,"path":"2021/03/02/Basic_calculator_II/","link":"","permalink":"https://blog.eganx.cn/2021/03/02/Basic_calculator_II/","excerpt":"栈的经典应用： 给一个字符串表达式 s ，实现一个基本计算器来计算并返回它的值。(整数除法仅保留整数部分)","text":"栈的经典应用： 给一个字符串表达式 s ，实现一个基本计算器来计算并返回它的值。(整数除法仅保留整数部分) 提示： 1. 1 &lt;&#x3D; s.length &lt;&#x3D; 3 * 10^52. s 由整数和算符(&#39;+&#39;, &#39;-&#39;, &#39;*&#39;, &#39;&#x2F;&#39;)组成,中间由一些空格隔开3. s 表示一个有效表达式4. 表达式中的所有整数都是非负整数,且在范围[0, 231 - 1]内5. 题目数据保证答案是一个32-bit整数 示例： 输入：s &#x3D; &quot;3+2*2&quot;输出：7 0x0.解题思路栈的经典应用，此题没有括号，不需要进行括号匹配，相对来说简单一点，可以直接进行暴力求解。 需要考虑运算符的优先级问题。乘除的优先级大于加减，可以先进行乘除运算，用一个栈，保存进行乘除运算后的整数的值。对于加减号后的数字，将其直接压入栈中；对于乘除号后的数字，直接与栈顶元素计算，并替换栈顶元素为计算后的结果。 遍历字符串 s，并用变量preSign记录每个数字之前的运算符，对于第一个数字，其之前的运算符视为加号。遍历到运算符或者字符串最后一位时，根据preSign来决定计算方式: 加号：数字直接入栈； 减号：num变(-num)入栈； 乘除：num ( * or / ) stack.back()，并将栈顶元素替换为运算结果。 0x1.复杂度分析 时间复杂度：O(n)，其中n为字符串s的长度。需要遍历字符串s一次，计算表达式的值。 空间复杂度：O(n)，其中n为字符串s的长度。空间复杂度主要取决于栈的空间，栈的元素个数不超过n。 需要注意的是 在运算的时候，判断字符是数字还是运算符的时候，需要使用isdigit()函数，此函数包含在头文件#include &lt;cctype&gt;中。 运算的时候，如果遇到的数是大数(两位数及以上的)，需要进行处理。大数在字符串中是两个字符，需要在遍历字符串时，使用num = num * 10 + int (s[i] - &#39;0&#39;);对大数进行处理。 在乘除运算的结果都模拟入栈之后，使用累加函数accumulate(st.begin(), st.end(), 0);对数组进行累加处理，accumulate()函数包含在头文件#include &lt;numeric&gt;中，累加过程中，正负数都可以处理。 0x2.代码实现//// main.cpp// Demo//// Created by Egan.// #include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;numeric&gt;#include &lt;cctype&gt;using namespace std; int main() &#123; class Solution &#123; public: int calculate(string s) &#123; vector&lt;int&gt; st; //digits char ps = &#x27;+&#x27;; //presign int num = 0; for(int i = 0; i &lt; s.length(); i++)&#123; if (isdigit(s[i]))&#123; //#include &lt;cctype&gt; num = num * 10 + int (s[i] - &#x27;0&#x27;); &#125; if (!isdigit(s[i]) &amp;&amp; s[i] != &#x27; &#x27; || i == s.length()-1)&#123; switch(ps)&#123; case &#x27;+&#x27; : st.push_back(num); break; case &#x27;-&#x27; : st.push_back(-num); break; case &#x27;*&#x27; : st.back() *= num; break; case &#x27;/&#x27; : st.back() /= num; break; &#125; ps = s[i]; num = 0; &#125; &#125; return accumulate(st.begin(), st.end(), 0); //#include&lt;numeric&gt; &#125;&#125;;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.eganx.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"算法/Leetcode","permalink":"https://blog.eganx.cn/categories/%E7%AE%97%E6%B3%95/Leetcode/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.eganx.cn/tags/%E6%97%A5%E5%B8%B8/"},{"name":"C++","slug":"C","permalink":"https://blog.eganx.cn/tags/C/"},{"name":"Leetcode","slug":"Leetcode","permalink":"https://blog.eganx.cn/tags/Leetcode/"},{"name":"栈","slug":"栈","permalink":"https://blog.eganx.cn/tags/%E6%A0%88/"}]},{"title":"逆波兰表示法(Reverse Polish notation)","slug":"Reverse Polish notation","date":"2021-03-01T08:12:14.000Z","updated":"2022-11-15T08:13:37.950Z","comments":true,"path":"2021/03/01/Reverse Polish notation/","link":"","permalink":"https://blog.eganx.cn/2021/03/01/Reverse%20Polish%20notation/","excerpt":"根据逆波兰表示法，求表达式的值。 有效的运算符包括 +, -, *, / 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。","text":"根据逆波兰表示法，求表达式的值。 有效的运算符包括 +, -, *, / 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。 0x0.解题思路逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。 逆波兰表达式主要有以下两个优点： 去掉括号后表达式无歧义，( 1 + 2 ) * ( 3 + 4 )即便写成 1 2 + 3 4 + * 也可以依据次序计算出正确结果。 适合用栈操作运算 逆波兰表达式的求解是栈的经典应用。所以此题采用栈来解决，遇到数字则入栈，遇到运算符则取出栈顶两个数字进行运算，并将结果压入栈中。 需要注意的是 在运算的时候，需要后取出的数字在前，先取出的数字在后，即num2在前。 stoi表示string to int，即字符串转整数 0x1.代码实现//// main.cpp// Demo//// Created by Egan.// #include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;stack&gt;#include &lt;cstring&gt;using namespace std; int main() &#123; class Solution &#123; public: int evalRPN(vector&lt;string&gt;&amp; tokens) &#123; stack&lt;int&gt; s; for(int i=0; i&lt;tokens.size(); i++)&#123; if(tokens[i] == &quot;+&quot;||tokens[i] == &quot;-&quot;||tokens[i] == &quot;*&quot;||tokens[i] == &quot;/&quot;)&#123; int num1 = s.top(); s.pop(); int num2 = s.top(); s.pop(); if(tokens[i] == &quot;+&quot;) s.push(num2 + num1); if(tokens[i] == &quot;-&quot;) s.push(num2 - num1); if(tokens[i] == &quot;*&quot;) s.push(num2 * num1); if(tokens[i] == &quot;/&quot;) s.push(num2 / num1); &#125; else &#123; s.push(stoi(tokens[i])); &#125; &#125; int result = s.top(); return result; &#125;&#125;;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.eganx.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"算法/Leetcode","permalink":"https://blog.eganx.cn/categories/%E7%AE%97%E6%B3%95/Leetcode/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.eganx.cn/tags/%E6%97%A5%E5%B8%B8/"},{"name":"C++","slug":"C","permalink":"https://blog.eganx.cn/tags/C/"},{"name":"Leetcode","slug":"Leetcode","permalink":"https://blog.eganx.cn/tags/Leetcode/"},{"name":"栈","slug":"栈","permalink":"https://blog.eganx.cn/tags/%E6%A0%88/"}]},{"title":"明明的随机数(Ming's random numbers)","slug":"Ming's_random_numbers","date":"2021-02-22T05:46:57.000Z","updated":"2022-11-15T08:13:28.769Z","comments":true,"path":"2021/02/22/Ming's_random_numbers/","link":"","permalink":"https://blog.eganx.cn/2021/02/22/Ming's_random_numbers/","excerpt":"明明想在学校中请一些同学一起做一项问卷调查，为了实验的客观性，他先用计算机生成了N个1到1000之间的随机整数（N≤1000），对于其中重复的数字，只保留一个，把其余相同的数去掉，不同的数对应着不同的学生的学号。然后再把这些数从小到大排序，按照排好的顺序去找同学做调查。请你协助明明完成“去重”与“排序”的工作(同一个测试用例里可能会有多组数据(用于不同的调查)，希望大家能正确处理)","text":"明明想在学校中请一些同学一起做一项问卷调查，为了实验的客观性，他先用计算机生成了N个1到1000之间的随机整数（N≤1000），对于其中重复的数字，只保留一个，把其余相同的数去掉，不同的数对应着不同的学生的学号。然后再把这些数从小到大排序，按照排好的顺序去找同学做调查。请你协助明明完成“去重”与“排序”的工作(同一个测试用例里可能会有多组数据(用于不同的调查)，希望大家能正确处理) 0x0.解题思路这是华为的一道面试题。在原文中已经明确点出了所需的一些函数，分别是排序和去重。C++有现成的排序函数sort()，以及去重函数unique()。其中unique(),sort()都是属于头文件#include &lt;algorithm&gt; auto end_un = unique(vec.begin(),vec.end()); 这里的unique()返回的值是最后一个不重复数字的下标。 sort函数有三个参数： 第一个是要排序的数组的起始地址 第二个是结束的地址（最后一位要排序的地址) 第三个参数是排序的方法，可以是升序也可是降序。如果不写第三个参数，则默认的排序方法是升序排列 //升序sort( a, b, less&lt;int&gt;() ); //降序sort( a, b, greater&lt;int&gt;() ); 如果先去重再排序，那么去重就有可能不会发挥作用。因为去重再排序排序时会把重复的数字又放在了一起，所以要先排序再去重。 0x1.代码实现//// main.cpp// Demo//// Created by Egan.// #include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std; int main() &#123; int n= 0,num = 0; while (cin &gt;&gt; n) &#123; vector&lt;int&gt; vec; //input for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; num; vec.push_back(num); &#125; //sort sort(vec.begin(), vec.end()); //unique auto end_un = unique(vec.begin(),vec.end()); vec.erase(end_un, vec.end()); for (auto m = vec.begin(); m != vec.end(); m ++) &#123; cout &lt;&lt; *m &lt;&lt; endl; &#125; &#125; return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.eganx.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"算法/Leetcode","permalink":"https://blog.eganx.cn/categories/%E7%AE%97%E6%B3%95/Leetcode/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.eganx.cn/tags/%E6%97%A5%E5%B8%B8/"},{"name":"C++","slug":"C","permalink":"https://blog.eganx.cn/tags/C/"},{"name":"Leetcode","slug":"Leetcode","permalink":"https://blog.eganx.cn/tags/Leetcode/"},{"name":"sort","slug":"sort","permalink":"https://blog.eganx.cn/tags/sort/"},{"name":"unique","slug":"unique","permalink":"https://blog.eganx.cn/tags/unique/"}]},{"title":"毕业半年的自己","slug":"Six_months_after_graduation","date":"2020-12-22T05:46:57.000Z","updated":"2022-11-15T08:13:43.992Z","comments":true,"path":"2020/12/22/Six_months_after_graduation/","link":"","permalink":"https://blog.eganx.cn/2020/12/22/Six_months_after_graduation/","excerpt":"","text":"0x0.半年之后&emsp;我们这届的毕业生，大学只上了三年半，最后半年的时光都是在家里渡过。拿毕业证学位证、拍毕业照以及收拾行李，加起来不过两天时间。一切都是匆匆忙忙，匆忙到连一顿散伙饭都没法进行。&emsp;还差几日，自己也就毕业半年了，也算是有了半年的工作经验(划水经验)，学软件的我，毕业之后进了一家偏自动化的公司，工业4.0时代嘛，天天代码倒是不多，感觉还不错。","categories":[{"name":"日常","slug":"日常","permalink":"https://blog.eganx.cn/categories/%E6%97%A5%E5%B8%B8/"},{"name":"工作","slug":"日常/工作","permalink":"https://blog.eganx.cn/categories/%E6%97%A5%E5%B8%B8/%E5%B7%A5%E4%BD%9C/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.eganx.cn/tags/%E6%97%A5%E5%B8%B8/"},{"name":"杂记","slug":"杂记","permalink":"https://blog.eganx.cn/tags/%E6%9D%82%E8%AE%B0/"}]},{"title":"Test","slug":"firstPage","date":"2020-10-22T03:10:47.000Z","updated":"2022-01-20T11:36:20.632Z","comments":true,"path":"2020/10/22/firstPage/","link":"","permalink":"https://blog.eganx.cn/2020/10/22/firstPage/","excerpt":"","text":"测试文档 从这一篇测试文档开始，希望自己能够收起懒惰，重拾激情","categories":[],"tags":[{"name":"Test","slug":"Test","permalink":"https://blog.eganx.cn/tags/Test/"}]}],"categories":[{"name":"工作","slug":"工作","permalink":"https://blog.eganx.cn/categories/%E5%B7%A5%E4%BD%9C/"},{"name":"日常","slug":"日常","permalink":"https://blog.eganx.cn/categories/%E6%97%A5%E5%B8%B8/"},{"name":"工作","slug":"日常/工作","permalink":"https://blog.eganx.cn/categories/%E6%97%A5%E5%B8%B8/%E5%B7%A5%E4%BD%9C/"},{"name":"算法","slug":"算法","permalink":"https://blog.eganx.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"算法/Leetcode","permalink":"https://blog.eganx.cn/categories/%E7%AE%97%E6%B3%95/Leetcode/"}],"tags":[{"name":"C#","slug":"C","permalink":"https://blog.eganx.cn/tags/C/"},{"name":"GC","slug":"GC","permalink":"https://blog.eganx.cn/tags/GC/"},{"name":"go","slug":"go","permalink":"https://blog.eganx.cn/tags/go/"},{"name":"版本切换","slug":"版本切换","permalink":"https://blog.eganx.cn/tags/%E7%89%88%E6%9C%AC%E5%88%87%E6%8D%A2/"},{"name":"OOM","slug":"OOM","permalink":"https://blog.eganx.cn/tags/OOM/"},{"name":"Serial","slug":"Serial","permalink":"https://blog.eganx.cn/tags/Serial/"},{"name":"C++","slug":"C","permalink":"https://blog.eganx.cn/tags/C/"},{"name":"华为OD","slug":"华为OD","permalink":"https://blog.eganx.cn/tags/%E5%8D%8E%E4%B8%BAOD/"},{"name":"笔试","slug":"笔试","permalink":"https://blog.eganx.cn/tags/%E7%AC%94%E8%AF%95/"},{"name":"日常","slug":"日常","permalink":"https://blog.eganx.cn/tags/%E6%97%A5%E5%B8%B8/"},{"name":"Leetcode","slug":"Leetcode","permalink":"https://blog.eganx.cn/tags/Leetcode/"},{"name":"栈","slug":"栈","permalink":"https://blog.eganx.cn/tags/%E6%A0%88/"},{"name":"sort","slug":"sort","permalink":"https://blog.eganx.cn/tags/sort/"},{"name":"unique","slug":"unique","permalink":"https://blog.eganx.cn/tags/unique/"},{"name":"杂记","slug":"杂记","permalink":"https://blog.eganx.cn/tags/%E6%9D%82%E8%AE%B0/"},{"name":"Test","slug":"Test","permalink":"https://blog.eganx.cn/tags/Test/"}]}