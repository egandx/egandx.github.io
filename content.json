{"meta":{"title":"Egan's Blog","subtitle":"The winter is coming","description":"You are more than what you have become","author":"Egan Dong","url":"https://blog.eganx.cn","root":"/"},"pages":[{"title":"分类","date":"2020-12-22T08:07:23.000Z","updated":"2020-12-22T08:08:17.000Z","comments":true,"path":"categories/index.html","permalink":"https://blog.eganx.cn/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2020-12-22T08:08:32.000Z","updated":"2020-12-22T08:09:05.000Z","comments":true,"path":"link/index.html","permalink":"https://blog.eganx.cn/link/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-12-22T08:06:06.000Z","updated":"2020-12-22T08:07:11.000Z","comments":true,"path":"tags/index.html","permalink":"https://blog.eganx.cn/tags/index.html","excerpt":"","text":""},{"title":"关于","date":"2020-12-22T08:06:06.000Z","updated":"2022-11-20T02:34:31.036Z","comments":true,"path":"about/index.html","permalink":"https://blog.eganx.cn/about/index.html","excerpt":"","text":"一个写C#客户端和Go服务端的小垃圾。毕业两年多，啥也不是…… 个人说明： 该用户很宅 该用户不吸烟 该用户使用Linux 该用户支持言论自由 该用户认为知易行难 该用户日常靠咖啡续命 该用户反对读书无用论 该用户不喜欢微信和QQ 该用户对电脑程序感兴趣 该用户谢绝使用百度搜索引擎"}],"posts":[{"title":"Go Interface理解(2)","slug":"Go_Interface_2","date":"2022-10-30T13:45:56.000Z","updated":"2022-11-22T06:15:48.152Z","comments":true,"path":"2022/10/30/Go_Interface_2/","link":"","permalink":"https://blog.eganx.cn/2022/10/30/Go_Interface_2/","excerpt":"接口有动态值和动态类型，只有当两者都是nil的时候，才有接口值==nil。这很重要‼️ 接口变量时常需要进行类型断言，找到真实类型。这也很重要‼️","text":"接口有动态值和动态类型，只有当两者都是nil的时候，才有接口值==nil。这很重要‼️ 接口变量时常需要进行类型断言，找到真实类型。这也很重要‼️ 0x0.空接口&amp;nil上来一个经典问题：一个包含nil指针的接口是不是nil接口？这个是真坑，在判空的时候，有可能就中招了。 空接口(interface&#123;&#125;)不包含任何的方法，但与此同时，所有的类型都实现了interface&#123;&#125;。在存储任意类型的时候，interface&#123;&#125;相当的有用。 nil 不是关键字，是一个预先声明的标识符，指针、通道、函数、接口、map、切片的零值就是nil，nil 是没有默认类型的，他的类型具有不确定性，我们在使用它时必须要提供足够的信息能够让编译器 推断nil期望的类型; 两个nil不能进行比较，因为nil是无类型的; 声明一个nil的map，map可以读数据，但是不能写数据 关闭一个nil的channel会引发panic nil切片不能进行索引访问，会引发panic 方法接收者为nil时，如果在方法内使用到了会引发panic 空指针一个没有任何值的指针 接口的底层结构体有iface、eface两种不同的表示。前者是有方法的接口，后者是无任何方法的空接口：interface&#123;&#125;。 //src/runtime/runtime2.gotype iface struct &#123; tab *itab data unsafe.Pointer&#125;type eface struct &#123; _type *_type data unsafe.Pointer&#125;type itab struct &#123; inter *interfacetype _type *_type hash uint32 // copy of _type.hash. Used for type switches. _ [4]byte fun [1]uintptr // variable sized. fun[0]==0 means _type does not implement inter.&#125; iface 内部维护两个指针，tab 指向一个 itab 实体， 它表示接口的类型以及赋给这个接口的实体类型。data 则指向接口具体的值，一般而言是一个指向堆内存的指针。tab和data也分别被称为动态类型和动态值，接口值包括动态类型和动态值。只有当接口的动态类型和动态值都为nil的时候，才有接口值==nil。 0x1.接口类型断言隐士类型转换在Go中是不允许的，这个时候类型就需要进行转换成另一个类型。有两种方式实现：类型转换，类型断言。两者的不同之处在于类型断言是针对接口变量。 1).类型转换&lt;结果&gt; := &lt;目标类型&gt;(&lt;表达式&gt;) f = 10.101i := int(f)fmt.Printf(&quot;%T, %v\\n&quot;, i, i) //output: int, 10 类型转换前后的两个类型需要相互兼容才可以，不然编译器会报错。 2).类型断言因为空接口 interface&#123;&#125; 没有定义任何函数，因此 Go 中所有类型都实现了空接口。当一个函数的形参是 interface&#123;&#125;，那么在函数中，需要对形参进行断言，从而得到它的真实类型。 &lt;目标类型的值&gt; :&#x3D; &lt;表达式&gt;.( 目标类型 ) &#x2F;&#x2F;非安全类型断言 type Duck struct &#123; age int&#125;func main() &#123; var d interface&#123;&#125; = new(Duck) s := d.(Duck) fmt.Println(s)&#125;//run main.go//panic: &quot;interface conversion: interface &#123;&#125; is *main.Duck, not main.Duck&quot; &lt;目标类型的值&gt;，&lt;布尔参数&gt; :&#x3D; &lt;表达式&gt;.( 目标类型 ) &#x2F;&#x2F; comma-ok断言,安全类型断言 type Duck struct &#123; age int&#125;func main() &#123; var d interface&#123;&#125; = new(Duck) s, ok := d.(Duck) if ok &#123; fmt.Println(s) &#125; fmt.Printf(&quot;d type is %T&quot;, d)&#125;//run main.go//d type is *main.Duck 尽量使用comma-ok断言，即使断言失败也不会panic。 断言其实也可以使用 switch 语句判断接口的类型，每一个 case 会被顺序地考虑。当命中一个 case 时，就会执行 case 中的语句，因此 case 语句的顺序是很重要的，因为很有可能会有多个 case 匹配的情况。 switch m := m.(type) &#123; case nil: case Duck: case *Duck: default:&#125;","categories":[{"name":"Golang","slug":"Golang","permalink":"https://blog.eganx.cn/categories/Golang/"}],"tags":[{"name":"go","slug":"go","permalink":"https://blog.eganx.cn/tags/go/"},{"name":"interface","slug":"interface","permalink":"https://blog.eganx.cn/tags/interface/"}]},{"title":"Go Interface理解(1)","slug":"Go_Interface_1","date":"2022-10-29T11:23:19.000Z","updated":"2022-11-22T06:10:18.113Z","comments":true,"path":"2022/10/29/Go_Interface_1/","link":"","permalink":"https://blog.eganx.cn/2022/10/29/Go_Interface_1/","excerpt":"Go语言中，接口是不需要像传统的静态编程语言一样进行声明后才能使用。它引用了动态语言的接口使用方式，只需要实现接口要求的相关方法就行，同时还会在编译阶段进行类型匹配，个人觉得非常好用。","text":"Go语言中，接口是不需要像传统的静态编程语言一样进行声明后才能使用。它引用了动态语言的接口使用方式，只需要实现接口要求的相关方法就行，同时还会在编译阶段进行类型匹配，个人觉得非常好用。 0x0.Interface &amp; Duck Typing所谓Go语言式的接口，就是不用显示声明类型T实现了接口I，只要类型T的公开方法完全满足接口I的要求，就可以把类型T的对象用在需要接口I的地方。这种做法的学名叫做Structural Typing，也有人称它为一种静态的Duck Typing。 Duck Typing一般常见于动态语言中（比如python），但是动态语言不会在编译阶段去进行类型匹配，只有在运行到当前行代码的时候才会报错。而传统的静态语言（比如Java），必须显示地去声明实现了某个接口，然后才可以去使用。这跟动态语言静态语言的讨论类似，可以讨论优缺点，但是不能以好坏去下结论。 Go语言本身作为一种静态语言，静态语言的类型检查是肯定有的。但是在接口的使用上，引用了动态语言的接口使用方式。即不要求类型显示地去声明实现了某个接口，只需要实现接口要求的相关方法就行，编译阶段会去进行类型检查。如果没有实现相关方法，编译是会报错的。 举个🌰： type IDuck interface &#123; gaga() swimming()&#125;type Duck struct&#123;&#125;func (d Duck) gaga() &#123; fmt.Println(&quot;Duck gaga&quot;)&#125;func (d *Duck) swimming() &#123; fmt.Println(&quot;Duck swimming&quot;)&#125;func main() &#123; var _ IDuck = (*Duck)(nil)&#125; var _ IDuck = (*Duck)(nil) //这个很实用，编译器会由此检查 *Duck类型是否实现了 IDuck 接口。 以上的代码编译可以通过，表示A实现了Duck接口，那么A就是一只鸭子🦆。 但是当注释了A的游泳方法时，就会出现编译器会直接爆出以下错误，表示A并没有完全实现Duck接口，A不是一只鸭子🦆。 // func (d *Duck) swimming() &#123;// fmt.Println(&quot;Duck swimming&quot;)// &#125;func main() &#123; var _ IDuck = (*Duck)(nil) //编译报错：cannot use (*A)(nil) (value of type *A) as Duck value in variable declaration: *A does not implement Duck (missing method swimming) compiler(InvalidIfaceAssign)&#125; 0x1.方法接口方法方便接口添加新的行为。方法有接收者，当没有了接收者，方法就变成了函数。接收者有两种类型，一种是值接收者，另一种是指针接收者。 方法的调用者不必满足接收者类型。换句话说，无论方法的接收者是什么类型，该类型的值和指针都可以调用。 func main() &#123; var _ IDuck = (*Duck)(nil) d := Duck&#123;&#125; //d := &amp;Duck&#123;&#125; 也是可以的 d.gaga() d.swimming()&#125; 当方法的接收者是值类型的时候，无论调用者是值类型还是指针类型，该方法操作的都是对应接收者的值的副本。即使你用指针类型去调用，方法内部操作还是对副本的操作，而不是指针操作。同理，当接收者是指针时，即使用值类型调用，方法内部也是对指针的操作，修改的是值指针指向的值本身。 0x2.接口实现type IDuck interface &#123; gaga() swimming()&#125;type Duck struct&#123;&#125;func (d Duck) gaga() &#123; fmt.Println(&quot;A gaga&quot;)&#125;func (d *Duck) swimming() &#123; fmt.Println(&quot;A swimming&quot;)&#125;func main() &#123; d := &amp;Duck&#123;&#125; dd := Duck&#123;&#125; var _ IDuck = (*Duck)(d) //OK var _ IDuck = (Duck)(dd) //编译报错：cannot use (Duck)(dd) (value of type Duck) as IDuck value in variable declaration: Duck does not implement IDuck (method swimming has pointer receiver)compilerInvalidIfaceAssign&#125; 编译器不考虑我们的值是实现该接口的类型，接口的调用规则是建立在这些方法的接受者和接口如何被调用的基础上。下面的是语言规范里定义的规则，这些规则用来说明是否我们一个类型的值或者指针该接口： 接收者是指针 *T 时，接口的实例必须是指针 接收者是值 T 时，接口的实例可以是指针也可以是值 也就是说：实现了接收者是值类型的方法，相当于自动实现了接收者是指针类型的方法；而实现了接收者是指针类型的方法，不会自动生成对应接收者是值类型的方法。 Q&amp;A：既然实现接收者是值类型的方法时，会自动实现接收者是指针类型的方法，那么为啥要用指针类型去做接收者？什么时候会去使用指针作为方法的接收者？ 方法的接收者是值类型的时候，修改的永远是对象的副本，不会对调用者有影响。但是接收者是指针的时候，在方法里修改，就是修改了指针指向的对象本身。当类型是大型的结构体或者不能被安全的复制时，就定义指针接收者方法，例如文件结构体（struct File）。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://blog.eganx.cn/categories/Golang/"}],"tags":[{"name":"go","slug":"go","permalink":"https://blog.eganx.cn/tags/go/"},{"name":"interface","slug":"interface","permalink":"https://blog.eganx.cn/tags/interface/"}]},{"title":"Go Map的遍历","slug":"Go_Map_Range","date":"2022-10-26T13:33:01.000Z","updated":"2022-11-20T04:33:57.713Z","comments":true,"path":"2022/10/26/Go_Map_Range/","link":"","permalink":"https://blog.eganx.cn/2022/10/26/Go_Map_Range/","excerpt":"Map的遍历过程是便利所有的bucket(一般称之为桶)以及挂载的overflow bucket，然后逐一遍历bucket的所有cell，从有key的cell中取出key和value，遍历完成。实际在遍历的时候，有可能map处于扩容过程中,这时候map的状态就相当于是处于一个中间态，即有些bucket已经迁移，有些bucket还在原来的位置。也就是说遍历如果发生在扩容的过程中，就会涉及到遍历新老 bucket 的过程，就比较麻烦。","text":"Map的遍历过程是便利所有的bucket(一般称之为桶)以及挂载的overflow bucket，然后逐一遍历bucket的所有cell，从有key的cell中取出key和value，遍历完成。实际在遍历的时候，有可能map处于扩容过程中,这时候map的状态就相当于是处于一个中间态，即有些bucket已经迁移，有些bucket还在原来的位置。也就是说遍历如果发生在扩容的过程中，就会涉及到遍历新老 bucket 的过程，就比较麻烦。 0x0.Map遍历是无序的在遍历map的时候，可以发现key是无序的。正常来说从一个固定Map的第一个bucket的第一个cell逐步遍历取出key的话，key应该是有序的。因为扩容会带来某些key的bucket或者cell发生变化，Go为了避免我们误认为遍历map会得到有序key，在遍历开始的时候，不是从0号bucket开始，而是会给一个随机数，从一个随机的bucket开始，更绝的是在开始bucket中的开始cell也是随机选择的。这样的话，就算是一个写死的map在遍历的时候依旧不会返回一个固定序列的key集合。 // decide where to start r := uintptr(fastrand()) if h.B &gt; 31-bucketCntBits &#123; r += uintptr(fastrand()) &lt;&lt; 31 &#125; // start bucket it.startBucket = r &amp; bucketMask(h.B) // start cell it.offset = uint8(r &gt;&gt; h.B &amp; (bucketCnt - 1)) 0x1.遍历过程假如有一个起始B=1的map（有0号和1号两个bucket），现在触发扩容，B变成了2（有0-3号4个bucket）。假设现在老0号bucket已经迁移到新0号和新2号bucket中，老1号中的bucket尚未开始迁移。此时开始对map的遍历，假设startBucket = 2,offset = 4，遍历的起点就是2号bucket中第4个cell。bucket的遍历顺序就是：2-&gt;3-&gt;0-&gt;1。 2号bucket对应的是老0号bucket，检查老0号bucket的迁移状态，发现完成已经完成迁移，从4号cell依次遍历2号bucket中所有cell。如果2号bucket返回的key是非空的，就会继续遍历2号bucket的overflow bucket。 完成2号bucket的遍历后，开始3号bucket的遍历，检查后发现3号bucket对应的老1号bucket并没有迁移，这个时候就会去遍历老1号bucket。但是并不会取出老1号bucket的全部key，只会取出hash值后两位为11的key，因为这些key最终会迁移进新3号bucket。 完成3号bucket的遍历，继续0号bucket的遍历，已迁移，取出新0号bucket中的key。 继续1号bucket的遍历，未迁移，遍历老1号bucket，取出hash值后两位为01的key。 再次到2号bucket的时候，表示所有bucket遍历完成，map的遍历也就结束了。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://blog.eganx.cn/categories/Golang/"}],"tags":[{"name":"go","slug":"go","permalink":"https://blog.eganx.cn/tags/go/"},{"name":"map","slug":"map","permalink":"https://blog.eganx.cn/tags/map/"}]},{"title":"Go Map的扩容","slug":"Go_Map_Grow","date":"2022-10-24T07:53:19.000Z","updated":"2022-11-20T04:33:16.832Z","comments":true,"path":"2022/10/24/Go_Map_Grow/","link":"","permalink":"https://blog.eganx.cn/2022/10/24/Go_Map_Grow/","excerpt":"在使用slice的时候，如果向slice中追加元素的时候，导致元素数量大于cap，这时候就会发生slice的扩容。那么在go语言中，什么时候map会发生扩容呢？扩容的策略有哪些呢？扩容的过程是怎样的呢？很是好奇，心动不如行动。开始学习，又是收获满满的一天。","text":"在使用slice的时候，如果向slice中追加元素的时候，导致元素数量大于cap，这时候就会发生slice的扩容。那么在go语言中，什么时候map会发生扩容呢？扩容的策略有哪些呢？扩容的过程是怎样的呢？很是好奇，心动不如行动。开始学习，又是收获满满的一天。 0x0.触发扩容的条件众所周知，map是使用hash表的。使用hash表的目的就是追求更加快速的找到key，但是当map中key的数量逐渐增加，逐渐离谱的时候，那么碰撞的几率就越来越大，效率也就随之下降了。最离谱的时候就是所有的key都在一个bucket里面 (这是碳基生物能干出来的事?这和链表有个锤子的区别吗？)，最好就是一个bucket里面就一个key，找到了bucket就找到了key，效率贼高，直接拉到o(1)。但是空间不允许啊，为了效率用空间换时间不寒碜？(很寒碜，贼TM寒碜)。 最好最坏都属于极端，其实都很难遇到，只是在举🌰的时候夸张表述才会用到。在go语言中，有一个loadFactor指标来对上面的两种情况进行衡量。废话不多说，直接上源码(/go1.18.2/src/runtime/map.go) // 判断条件在mapassign函数中。// If we hit the max load factor or we have too many overflow buckets,// and we&#x27;re not already in the middle of growing, start growing.if !h.growing() &amp;&amp; (overLoadFactor(h.count+1, h.B) || tooManyOverflowBuckets(h.noverflow, h.B)) &#123; hashGrow(t, h) goto again // Growing the table invalidates everything, so try again&#125; 从上面的条件可以看出，map扩容一个是在overLoadFactor的时候，一个是在tooManyOverflowBuckets。下面是这两个函数所用到的常量以及主要的引用函数。 const (// Maximum number of key/elem pairs a bucket can hold. bucketCntBits = 3 bucketCnt = 1 &lt;&lt; bucketCntBits //8 // Maximum average load of a bucket that triggers growth is 6.5. // Represent as loadFactorNum/loadFactorDen, to allow integer math. loadFactorNum = 13 loadFactorDen = 2)// PtrSize is the size of a pointer in bytes - unsafe.Sizeof(uintptr(0)) but as an ideal constant.// It is also the size of the machine&#x27;s native word size (that is, 4 on 32-bit systems, 8 on 64-bit).const PtrSize = 4 &lt;&lt; (^uintptr(0) &gt;&gt; 63)// bucketShift returns 1&lt;&lt;b, optimized for code generation.func bucketShift(b uint8) uintptr &#123; // Masking the shift amount allows overflow checks to be elided. return uintptr(1) &lt;&lt; (b &amp; (goarch.PtrSize*8 - 1))&#125;// overLoadFactor reports whether count items placed in 1&lt;&lt;B buckets is over loadFactor.func overLoadFactor(count int, B uint8) bool &#123; return count &gt; bucketCnt &amp;&amp; uintptr(count) &gt; loadFactorNum*(bucketShift(B)/loadFactorDen)&#125;// tooManyOverflowBuckets reports whether noverflow buckets is too many for a map with 1&lt;&lt;B buckets.// Note that most of these overflow buckets must be in sparse use;// if use was dense, then we&#x27;d have already triggered regular map growth.func tooManyOverflowBuckets(noverflow uint16, B uint8) bool &#123; // If the threshold is too low, we do extraneous work. // If the threshold is too high, maps that grow and shrink can hold on to lots of unused memory. // &quot;too many&quot; means (approximately) as many overflow buckets as regular buckets. // See incrnoverflow for more details. if B &gt; 15 &#123; B = 15 &#125; // The compiler doesn&#x27;t see here that B &lt; 16; mask B to generate shorter shift code. return noverflow &gt;= uint16(1)&lt;&lt;(B&amp;15)&#125; 1）第一种情况// overLoadFactor reports whether count items placed in 1&lt;&lt;B buckets is over loadFactor.func overLoadFactor(count int, B uint8) bool &#123; // 换算一下下: count &gt; 8 &amp;&amp; count &gt; 13*((2^B)/2) // loadFactor = count/(2^B) &gt; 6.5 return count &gt; bucketCnt &amp;&amp; uintptr(count) &gt; loadFactorNum*(bucketShift(B)/loadFactorDen)&#125; 其中count是map的元素个数，1&lt;&lt;B表示bucket数组长度。也就是说在loadFactor := count/(2^B)超过6.5的时候，会触发map的扩容。按照loadFactor的计算方式，当所有bucket都满的时候是8。达到6.5的时候也就差不多算是满了大半了，无论查找还是插入，这个时候碰撞的几率很高，效率也会下降的厉害，所以这是触发扩容的时机。 如果不停的插入元素、删除元素，然后在插入元素。刚开始插入元素的时候会创建大量bucket。但是只要没有达到第一种扩容情况，也就是说loadFactor的值低于6.5。这个时候进行删除元素的操作，降低loadFactor的分子。然后重复操作，就会产生大量overflow bucket。这个时候key就会过于分散，导致查找和插入的效率过低。为了避免这种情况的发生，就有了下面第二种触发扩容的条件。 2) 第二种情况// tooManyOverflowBuckets reports whether noverflow buckets is too many for a map with 1&lt;&lt;B buckets.// Note that most of these overflow buckets must be in sparse use;// if use was dense, then we&#x27;d have already triggered regular map growth.func tooManyOverflowBuckets(noverflow uint16, B uint8) bool &#123; // If the threshold is too low, we do extraneous work. // If the threshold is too high, maps that grow and shrink can hold on to lots of unused memory. // &quot;too many&quot; means (approximately) as many overflow buckets as regular buckets. // See incrnoverflow for more details. if B &gt; 15 &#123; B = 15 &#125; // The compiler doesn&#x27;t see here that B &lt; 16; mask B to generate shorter shift code. return noverflow &gt;= uint16(1)&lt;&lt;(B&amp;15)&#125; 翻译成人话：overflow的bucket数量太多了。当B &gt;= 15的时候，如果overflow的bucket数量超过2^15就触发扩容；当B &lt; 15的时候，如果overflow的bucket数量超过2^B就触发扩容。第二种的这个情况主要是为了避免loadFactor的分子小的时候，却有大量的bucket(包括大量的overflow bucket)。 0x1.扩容策略针对两种不同的触发扩容的条件，进行扩容的策略也有所不同。 第一种情况是由于元素数量过多，导致了bucket数组快满了。这个时候采用的扩容策略就是B+1，bucket的数组长度变成之前的2倍（2倍扩容） 第二种情况是由于flowbucket的过多造成，元素没有那么多，主要是位置分散，造成查找和插入的效率较低。采用第一种的扩容策略肯定是不行的，解决的办法是采用等量扩容，创建一个和老buckets数组相同长度的新buckets数组。将老buckets中处于同一个bucket的元素进行紧密排列，尽可能的消除overflow bucket，节省空间，提高效率。 map的扩容不是原子操作，不会一步到位。扩容需要将原本的键值对迁移到新bucket得内存地址中，大量键值对同时迁移会影响性能，所以Go map的扩容是采用“渐进式”方式。每次最多只会迁移2个bucket。 0x2.迁移过程第一种扩容策略，因为B+1会导致key的hash值需要重新计算，才能确定它会落入那个bucket中，毕竟确定bucket位置的是根据hash值的后B位。这样的话就会导致某些key在迁移前后的bucket序号是不一样的。 举个🌰：初始状态下B=2，3号bucket里有两个key的hash值后3位值011,111，经过B+1扩容之后，这两个原本处于3号bucket的key会分别落入3号和7号bucket。key在迁移前后是否还是处于原本的bucket取决于倒数第3位是0还是1。 ┌───────────────────────┐ │ │ ┌─────┼─────────────────┐ │ │ │ │ │ ┌─────┼─────┼───────────┐ │ │ │ │ │ │ │ │ ┌─────┼─────┼─────┼─────┐ │ │ │ │ │ │ │ │ │ │ │┌──┴──┬──┴──┬──┴──┬──┴──┐ │ │ │ ││ │ │ │ │ │ │ │ ││ 0 │ 1 │ 2 │ 3 │ │ │ │ ││ │ │ │ │ │ │ │ │└──┬──┴──┬──┴──┬──┴──┬──┘ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ ▼ ▼ ▼ ▼ ▼ ▼ ▼ ▼┌─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┐│ │ │ │ │ │ │ │ ││ 0 │ 1 │ 2 │ 3 │ 4 │ 5 │ 6 │ 7 ││ │ │ │ │ │ │ │ │└─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┘ 第二种扩容策略，等量扩容因为B是不变的，所以key还是在原来的bucket。主要是为了收拢过于分散的key(大多数都分散在overflow bucket中)。下面的图是迁移完成的情况。 buckets B&#x3D;2 buckets B&#x3D;2┌─────┬─────┬─────┬─────┐ ┌─────┬─────┬─────┬─────┐│ │ │ │ │ │ │ │ │ ││ 0 │ 1 │ 2 │ 3 │ │ 0 │ 1 │ 2 │ 3 ││ │ │ │ │ │ │ │ │ │└─────┴─────┴─────┴──┬──┘ └─────┴─────┴─────┴──┬──┘ │ │ ┌─────────────────┘ ┌───────┘ │ │ ▼ ▼┌────┐ ┌────┐ ┌────┐ ┌────┐│bmap│ ┌─►│bmap│ ┌─►│bmap│ │bmap│├────┴┐ │ ├────┴┐ │ ├────┴┐ ├────┴┐│key:a│ │ │ │ │ │key:f│ │key:a││ 111 │ │ │ │ │ │ 111 │ │ 111 │├─────┤ │ ├─────┤ │ ├─────┤ ├─────┤│key:b│ │ │ │ │ │ │ │key:b││ 011 │ │ │ │ │ │ │ │ 011 │├─────┤ │ ├─────┤ │ ├─────┤ ├─────┤│ │ │ │key:d│ │ │ │ │key:c││ │ │ │ 111 │ │ │ │ │ 011 │├─────┤ │ ├─────┤ │ ├─────┤ ├─────┤│ │ │ │ │ │ │ │ │key:d││ │ │ │ │ │ │ │ │ 111 │├─────┤ │ ├─────┤ │ ├─────┤ ├─────┤│key:c│ │ │key:e│ │ │ │ │key:e││ 011 │ │ │ 111 │ │ │ │ │ 111 │├─────┤ │ ├─────┤ │ ├─────┤ ├─────┤│ │ │ │ │ │ │key:g│ │key:f││ │ │ │ │ │ │ 011 │ │ 111 │├─────┤ │ ├─────┤ │ ├─────┤ ├─────┤│ │ │ │ │ │ │ │ │key:g││ │ │ │ │ │ │ │ │ 011 │├─────┤ │ ├─────┤ │ ├─────┤ ├─────┤│ │ │ │ │ │ │ │ │ ││ │ │ │ │ │ │ │ │ │├─────┤ │ ├─────┤ │ ├─────┤ ├─────┤│*over│ │ │*over│ │ │*over│ │*over││flow ├──┘ │flow ├─┘ │flow │ │flow │└─────┘ └─────┘ └─────┘ └─────┘","categories":[{"name":"Golang","slug":"Golang","permalink":"https://blog.eganx.cn/categories/Golang/"}],"tags":[{"name":"go","slug":"go","permalink":"https://blog.eganx.cn/tags/go/"},{"name":"map","slug":"map","permalink":"https://blog.eganx.cn/tags/map/"}]},{"title":"Go Map的基本介绍","slug":"Go_Map","date":"2022-10-22T06:53:19.000Z","updated":"2022-11-20T04:33:23.564Z","comments":true,"path":"2022/10/22/Go_Map/","link":"","permalink":"https://blog.eganx.cn/2022/10/22/Go_Map/","excerpt":"map由key-value对组成，并且一个key只会出现一次。对map可以进行增删改查一系列操作。在Go语言，map采用的是哈希查找表实现，解决哈希冲突的方式是链表法。记录一下学习过程中了解到的map基本结构和key的定位过程。","text":"map由key-value对组成，并且一个key只会出现一次。对map可以进行增删改查一系列操作。在Go语言，map采用的是哈希查找表实现，解决哈希冲突的方式是链表法。记录一下学习过程中了解到的map基本结构和key的定位过程。 0x0.map的基本结构附上源码(go1.18.2/src/runtime/map.go) // A header for a Go map.type hmap struct &#123; // Note: the format of the hmap is also encoded in // cmd/compile/internal/reflectdata/reflect.go. // Make sure this stays in sync with the compiler&#x27;s definition. count int // # live cells == size of map. Must be first (used by len() builtin) flags uint8 B uint8 // log_2 of # of buckets (can hold up to loadFactor * 2^B items) noverflow uint16 // approximate number of overflow buckets; see incrnoverflow for details hash0 uint32 // hash seed buckets unsafe.Pointer // array of 2^B Buckets. may be nil if count==0. oldbuckets unsafe.Pointer // previous bucket array of half the size, non-nil only when growing nevacuate uintptr // progress counter for evacuation (buckets less than this have been evacuated) extra *mapextra // optional fields&#125; ┌──────┐│ hmap │├──────┴─────────────────────┐ ┌─────┐│ count int │ │ │├────────────────────────────┤ │ ▼│ flags uint8 │ │ ┌──────┐ ┌───────┐├────────────────────────────┤ │ │[]bmap│ ┌►│ bmap ││ B uint8 │ │ ├──────┴─┐ │ ├───────┴───────────────────────┐├────────────────────────────┤ │ │ 0 ├──┘ │ tophash [bucketCnt]uint8 ││ noverflow uint16 │ │ ├────────┤ ├───────┬───────────────────────┤├────────────────────────────┤ │ │ 1 │ │ key │ ││ hash0 uint32 │ │ ├────────┤ ├───┬───┼───┬───┬───┬───┬───┬───┤├────────────────────────────┤ │ │ 2 │ │ 0 │ 1 │ 2 │ 3 │ 4 │ 5 │ 6 │ 7 ││ buckets unsafe.Pointer ├─┘ ├────────┤ ├───┴───┼───┴───┴───┴───┴───┴───┤├────────────────────────────┤ │ 3 │ │ values│ ││ oldbuckets unsafe.Pointer │ ├────────┤ ├───┬───┼───┬───┬───┬───┬───┬───┤├────────────────────────────┤ │ ... │ │ 0 │ 1 │ 2 │ 3 │ 4 │ 5 │ 6 │ 7 ││ nevacuates uintptr │ ├────────┤ ├───┴───┴───┴───┴───┴───┴───┴───┤├────────────────────────────┤ │ 62 │ │ overflow *bmap ││ extra *mapextra │ ├────────┤ └─────┬─────────────────────────┘└────┬───────────────────────┘ │ 63 ├─┐ │ │ └────────┘ │ │ ┌───────┐ ▼ size&#x3D;2^B │ └─────►│ bmap │┌──────────┐ │ ├───────┴───────────────────────┐│ mapextra │ │ │ tophash [bucketCnt]uint8 │├──────────┴─────────┐ │ ├───────┬───────────────────────┤│ overflow *[]*bmap │ ┌───────┐ ◄─────────┘ │ key │ │├────────────────────┤ │ bmap │ ├───┬───┼───┬───┬───┬───┬───┬───┤│oldoverflow *[]*bmap│ ├───────┴───────────────────────┐ │ 0 │ 1 │ 2 │ 3 │ 4 │ 5 │ 6 │ 7 │├────────────────────┤ │ tophash [bucketCnt]uint8 │ ├───┴───┼───┴───┴───┴───┴───┴───┤│ nextoverflow *bmap │ ├───────┬───────────────────────┤ │ values│ │└────────────────────┘ │ key │ │ ├───┬───┼───┬───┬───┬───┬───┬───┤ ├───┬───┼───┬───┬───┬───┬───┬───┤ │ 0 │ 1 │ 2 │ 3 │ 4 │ 5 │ 6 │ 7 │ │ 0 │ 1 │ 2 │ 3 │ 4 │ 5 │ 6 │ 7 │ ├───┴───┴───┴───┴───┴───┴───┴───┤ ├───┴───┼───┴───┴───┴───┴───┴───┤ │ overflow *bmap │ │ values│ │ └───────────────────────────────┘ ├───┬───┼───┬───┬───┬───┬───┬───┤ │ 0 │ 1 │ 2 │ 3 │ 4 │ 5 │ 6 │ 7 │ ├───┴───┴───┴───┴───┴───┴───┴───┤ ┌────────┐ │ overflow *bmap ├──────►│ nil │ └───────────────────────────────┘ └────────┘ 其中B是bucket数组长度的对数，bucket里面存储了key和value。可以看见一个bucket里面最多能装8个key，这8个key在bucket里面的位置根据hash值的高8位决定。nevacuate表示扩容进度，小于此地址的 buckets 迁移完成。Ascii风格的map内存模型图是参考曹大github里的，曹大yyds。 其中bucket指针指向的结构体如下： // A bucket for a Go map.type bmap struct &#123; // tophash generally contains the top byte of the hash value // for each key in this bucket. If tophash[0] &lt; minTopHash, // tophash[0] is a bucket evacuation state instead. tophash [bucketCnt]uint8 // Followed by bucketCnt keys and then bucketCnt elems. // NOTE: packing all the keys together and then all the elems together makes the // code a bit more complicated than alternating key/elem/key/elem/... but it allows // us to eliminate padding which would be needed for, e.g., map[int64]int8. // Followed by an overflow pointer.&#125; ┌───────┐│ bmap │├───────┴───────────────────────┐│ tophash [bucketCnt]uint8 │├───────┬───────────────────────┤│ key │ │├───┬───┼───┬───┬───┬───┬───┬───┤│ 0 │ 1 │ 2 │ 3 │ 4 │ 5 │ 6 │ 7 │├───┴───┼───┴───┴───┴───┴───┴───┤│ values│ │├───┬───┼───┬───┬───┬───┬───┬───┤│ 0 │ 1 │ 2 │ 3 │ 4 │ 5 │ 6 │ 7 │├───┴───┴───┴───┴───┴───┴───┴───┤│ overflow *bmap │└───────────────────────────────┘ 其中key和value是各自存放在一起的，为什么要这么做呢，以下是在注释中的官方解释。 NOTE: packing all the keys together and then all the elems together makes the code a bit more complicated than alternating key/elem/key/elem/... but it allows us to eliminate padding which would be needed for, e.g., map[int64]int8. 主要是为了减少内存对齐带来的padding。注释中给了一个例子map[int64]int8，如果是按照key/elem/key/elem/这种方式存储，相当于每一个key/elem都需要padding7个字节。64位的机器上，默认的对齐系数是8，同时int8的对齐系数是1，int64的对齐系数是8。以下是key/elem方式产生padding的过程： 第一个key，key1(int64)的大小和对齐值是8，占据8位。暂且写做：kkkkkkkk 第一个value，value1(int8)的大小和对齐值是1，占据1位。写做：kkkkkkkk｜v 第二个key，key2(int64)的大小和对齐值是8，偏移量必须是8的倍数。也就产生了padding。不能直接接着value1后面写了，写作：kkkkkkkk｜vxxxxxxx｜kkkkkkkk。其中x表示padding。后面也就是依次类推了。 如果是按照key/key/key/.../key/elem/elem/.../elem来进行存储的话，只需要在最后面添加padding就行。内存对齐一般好像不怎么会考虑，但是了解还是需要了解的，TODO List再加一项。 0x1.map中key的位置在64位的机器上面，key经过hash计算后会得到一个64bit的哈希值。在key的定位过程中会用到哈希值的高8位和后B位。B就是hmap中的B，如果B=6，buckets数组的长度就是2^6=64。 举个🌰,现在有一个key的哈希值如下： 00000111 | 00001111111011001111111111101010001000000001010000 | 000010 key┌────────────────────────────────────────────────────────────────────────┐│ 00000111 | 00001111111011001111111111101010001000000001010000 | 000010 │└────┬──────────────────────────────────────────────────────────────┬────┘ │ │ │ ▼ │ B&#x3D;6 ┌────────────────┐ │ bucketMask&#x3D;111111 │ 000010&amp;111111 │ │ └────────────┬───┘ │ tophash │ │ ▼ │ ┌────────┐ │ ┌─────────────────────┤000010&#x3D;2│ ▼ │ └────────┘┌────────────┐ buckets ▼│ 00000111&#x3D;7 │ ┌───┬───┬───┬───┬──────────┬────┬────┬────┐└─────┬──────┘ │ 0 │ 1 │ 2 │ 3 │ ... │ 61 │ 62 │ 63 │ │ └───┴───┴─┬─┴───┴──────────┴────┴────┴────┘ │ │ │ │ └─────────────────────────────┐ │ │ ▼ ┌────────────────────────┼────────────┬──────┐ │ │ │bucket│ │ ┌───────┐ │ ├──────┘ │ │ bmap │ ▼ │ │ ├───┬───┼───┬───┬───┬───┬───┬───┐ │ │ │111│ 9 │ 3 │ 5 │ 6 │ 7 │ 0 │ 0 │ │ │ ├───┴───┼───┴───┴───┴───┴───┴───┤ │ │ │ key │ │ │ │ ├───┬───┼───┬───┬───┬───┬───┬───┤ │ │ │ 5 │ 2 │ 1 │ 4 │ 3 │ 9 │ 0 │ 0 │ │ │ ├───┴───┼───┴───┴───┴───┴───┴───┤ │ │ │ values│ │ │ │ ├───┬───┼───┬───┬───┬───┬───┬───┤ │ │ │ 3 │ 5 │ 4 │ 7 │ 9 │ 6 │ 0 │ 0 │ │ │ ├───┴───┴───┴───┴───┴───┴───┴───┤ │ │ │ overflow *bmap │ │ │ └───────────────────────────────┘ │ │ │ └─────────────────────────────────────┘ 如果在 bucket 中没找到，并且 overflow 不为空，还要继续去 overflow bucket 中寻找，直到找到或是所有的 key 槽位都找遍了，包括所有的 overflow bucket。 实现上有 mapaccess1，mapaccess2，mapaccessK 几个方法，主要区别是在返回内容上。当要查询的 key 不在 map 里，mapaccess2的用法会返回一个 bool 型变量提示 key 是否在 map 中；而mapaccess1 的语句则会返回一个 key 对应 value 类型的零值。如果 value 是 int 型就会返回 0，如果 value 是 string 类型，就会返回空字符串。mapaccess2就是日常代码中v, ok := map[k]的底层函数。 0x2.Go Map是线程安全的吗？map不是线程安全的。在对map进行读写操作的时候都会先检测写标志，发现写标志位置1，会panic。所以不能一边写入一边遍历。 一个协程内一边删除一边遍历的操作是允许的，但是真的这么干了，大概率会被打。毕竟遍历出来的结果有可能会包含已经删除的元素。 上面的两种情况看看就行，真要写的时候一般都会加读写锁：sync.RWMutex。 map不是线程安全的，但是sync.Map是线程安全。 0x3.如何判断两个map是否相等两个map是否相等不能直接通过==判断，编译报错。 引用书里的map深度相等的条件： 1、都为nil 2、非空，长度相等，指向同一个map实体 3、相同的key指向的value“深度”相等 var m map[int]intvar n map[int]intfmt.Println(m == nil) //OKfmt.Println(n == nil) //OKfmt.Println(m == n) //编译报错 因此只能是遍历map 的每个元素，比较元素是否都是深度相等。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://blog.eganx.cn/categories/Golang/"}],"tags":[{"name":"go","slug":"go","permalink":"https://blog.eganx.cn/tags/go/"},{"name":"map","slug":"map","permalink":"https://blog.eganx.cn/tags/map/"}]},{"title":"Go Slice的扩容策略","slug":"Go_Slice_growup","date":"2022-10-15T04:56:11.000Z","updated":"2022-11-20T04:33:01.426Z","comments":true,"path":"2022/10/15/Go_Slice_growup/","link":"","permalink":"https://blog.eganx.cn/2022/10/15/Go_Slice_growup/","excerpt":"在写Go的时候，对Slice的操作就很危险，特别是函数参数传的是Slice指针，一不小心就改了。切片支持子切片 和原本切片共享底层数组，那子切片和切片究竟会不会相互影响？ 就看他们是不是还共享底层数组。如果他们的结构没有变化，肯定是共享的。结构发生变化(扩容)，就可能不共享了。 对子切片的使用建议：只读不改","text":"在写Go的时候，对Slice的操作就很危险，特别是函数参数传的是Slice指针，一不小心就改了。切片支持子切片 和原本切片共享底层数组，那子切片和切片究竟会不会相互影响？ 就看他们是不是还共享底层数组。如果他们的结构没有变化，肯定是共享的。结构发生变化(扩容)，就可能不共享了。 对子切片的使用建议：只读不改 0x0.Slice和Array的联系slice 的底层数据是数组，slice 是对数组的封装。两者都可以通过下标来访问单个元素。 数组就是一片连续的内存，是定长的，其长度是类型的一部分，比如 [3]int 和 [4]int 就是不同的类型。 slice可以动态地扩容，切片的类型和长度无关。 slice 是一个结构体，包含三个字段：长度、容量、底层数组。 type slice struct &#123; array unsafe.Pointer &#x2F;&#x2F; 元素指针 len int &#x2F;&#x2F; 长度 cap int &#x2F;&#x2F; 容量&#125; 不是每一个Slice都有自己专属的底层数组，底层数组是可以被多个Slice同时指向的，也就是说在修改SliceA的数据时，有可能SliceB的数据也会发生改变。 0x1.Slice扩容策略在golang1.18版本之前，Slice的扩容策略是当原 slice 容量小于 1024 的时候，新 slice 容量变成原来的 2 倍；原 slice 容量超过 1024，新 slice 容量变成原来的1.25倍。 在golang1.18版本之后，新的Slice扩容策略是当原slice容量(oldcap)小于256的时候，新slice(newcap)容量为原来的2倍；原slice容量超过256，新slice容量newcap = oldcap+(oldcap+3*256)/4 在实际的扩容过程中，还需要考虑内存对齐产生的影响，这个和内存分配策略相关。进行内存对齐之后，新 slice 的容量是要 大于等于 理论的扩容量。 经典例题，来自golang Slice的扩容规则 package mainimport &quot;fmt&quot;func main() &#123; s := []int&#123;1,2&#125; s = append(s,4,5,6) fmt.Printf(&quot;len=%d, cap=%d&quot;,len(s),cap(s))&#125; 运行结果： len&#x3D;5, cap&#x3D;6","categories":[{"name":"Golang","slug":"Golang","permalink":"https://blog.eganx.cn/categories/Golang/"}],"tags":[{"name":"go","slug":"go","permalink":"https://blog.eganx.cn/tags/go/"},{"name":"slice","slug":"slice","permalink":"https://blog.eganx.cn/tags/slice/"}]},{"title":"C# GC机制(Garbage Collector)","slug":"CSharp_GC_mechanism","date":"2022-02-08T13:31:19.000Z","updated":"2022-11-20T02:42:11.675Z","comments":true,"path":"2022/02/08/CSharp_GC_mechanism/","link":"","permalink":"https://blog.eganx.cn/2022/02/08/CSharp_GC_mechanism/","excerpt":"记录一下C#中GC的相关知识。不记下来，下次又找不到，就很烦。 主要针对的是C#中如何判定Garbage和GC的运作方式。","text":"记录一下C#中GC的相关知识。不记下来，下次又找不到，就很烦。 主要针对的是C#中如何判定Garbage和GC的运作方式。 0x0.资源概念所谓的资源其实就是程序中可以利用的数据。比如字符串、图片和任何的二进制数据。 托管资源，非托管资源：托管资源是由CLR全权负责的资源，CLR不负责的资源位非托管资源。对于托管资源通过GC自动清理回收。对于非托管的资源，一般就是Stream，数据库的连接，网络连接，GDI+的相关对象，还有Com对象等等这些操作系统资源，需要我们手动去释放，再由GC回收。 0x1.Garbage的判定.Net类型分为两大类，一个就是值类型，另一个就是引用类型。前者是在堆栈中分配内存，它们有自身的生命周期，所以不用对它们进行管理，会自动分配和释放。后者是在堆中分配内存的。所以它的分配和释放就需要像回收机制来管理。 GC的全称为“Garbage Collector”,顾名思义就是垃圾回收器，那么只有被称为垃圾的对象才能被GC回收。也就是说， 一个引用类型对象所占用的内存需要被GC回收，需要先成为垃圾。 .Net判定一个引用类型对象是垃圾，只需要判定此对象或者其包含的子对象没有任何引用是有效的，那么系统就认为它是垃圾。 0x2.非托管资源的释放方式1).Close()关闭对象资源，在显示调用时被调用。 2).Dispose()继承IDisposable接口，实现Dispose方法；介绍：调用Dispose方法，销毁对象，需要显示调用或者通过using语句，在显示调用或者离开using程序块时被调用。Dispose方法用于清理对象封装的非托管资源，而不是释放对象的内存，对象的内存依然由垃圾回收器控制。Dispose方法调用，不但释放该类的非托管资源，还释放了引用的类的非托管资源。Dispose模式就是一种强制资源清理所要遵守的约定；Dispose模式实现IDisposable接口，从而使得该类型提供一个公有的Dispose方法。 而Close与Dispose这两种方法的区别在于，调用完了对象的Close方法后，此对象有可能被重新进行使用；而Dispose方法来说，此对象所占有的资源需要被标记为无用了，也就是此对象被销毁了，不能再被使用。 3).析构函数/Finalize()带有析构函数的类，生命周期会变长。内存空间需要两次垃圾回收才会被释放，导致性能下降。 一个正常情况的类是不会写析构函数的，而一旦一个类写了析构函数，就意味着GC会在不确定的时间调用该类的析构函数，判断该类的资源是否需要释放，然后调用Finalize方法，如果重写了Finalize方法则调用重写的Finalize方法。Finalize方法的作用是保证.NET对象能在垃圾回收时清除非托管资源。在.NET中，Object.Finalize()方法是无法重载的，编译器是根据类的析构函数来自动生成Object.Finalize()方法的Finalize由垃圾回收器调用；dispose由对象调用。Finalize无需担心因为没有调用Finalize而使非托管资源得不到释放，因为GC会在不确定时间调用，当然，你也可以手动调用Finalize方法，而dispose必须手动调用。Finalize虽然无需担心因为没有调用Finalize而使非托管资源得不到释放，但因为由垃圾回收器管理，不能保证立即释放非托管资源；而dispose一调用便释放非托管资源。只有类类型才能重写Finalize，而结构不能；类和结构都能实现IDispose 释放模式：是一种微软建议的写法，先手动显示去释放资源，如果忘记了，再让finalize释放资源。所以如果已经完成了析构函数该干的事情(例如释放非托管资源)，就应当使用SuppressFinalize方法告诉GC不需要再执行某个对象的析构函数。 0x3.GC的运作方式内存的释放和回收需要伴随着程序的运行，因此系统为GC安排了独立的线程。那么GC的工作大致是，查询内存中对象是否成为垃圾，然后对垃圾进行释放和回收。那么对于GC对于内存回收采取了一定的优先算法进行轮循回收内存资源。 其次，对于内存中的垃圾分为两种，一种是需要调用对象的析构函数，另一种是不需要调用的。GC对于前者的回收需要通过两步完成，第一步是调用对象的析构函数，第二步是回收内存，但是要注意这两步不是在GC一次轮循完成，即需要两次轮循；相对于后者，则只是回收内存而已。 C#中的GC使用了Generation的概念，它将分配的对象分为3代(可用GC.GetGeneration方法返回任意作为参数的对象当前所处的代)。 最近被分配内存的对象被放置于第0代，因为第0代很小，小到足以放进处理器的二级（L2)缓存，所以它能够提供对对象的快速存取。经过一轮垃圾回收后，仍然保留在第0代中的对象被移进第1代中，再经过一轮垃圾内存回收后，仍然保留在第1代中的对象则被移进第2代中，第2代中包含了生存期较长的对象。 当第0代中没有可以分配的有效内存时，就触发了第0代中的一轮垃圾回收，它将删除那些不再被引用的对象，并将当前正在使用的对象移至第1代。而当第0代垃圾回收后依然不能请求到充足的内存时，就启动第1代垃圾回收。如果对各代都进行了垃圾回收后仍没有可用的内存就会引发一个OutOfMemoryException异常。 Close Dispose 析构函数 关闭对象资源 销毁对象 销毁对象 调用方式 需要显示调用 需要显示调用或者通过using语句 不能被显示调用，会被GC调用 调用时机 在显示调用时 在显示调用或者离开using程序块 不确定","categories":[{"name":"Work","slug":"Work","permalink":"https://blog.eganx.cn/categories/Work/"},{"name":"C#","slug":"Work/C","permalink":"https://blog.eganx.cn/categories/Work/C/"}],"tags":[{"name":"C#","slug":"C","permalink":"https://blog.eganx.cn/tags/C/"},{"name":"GC","slug":"GC","permalink":"https://blog.eganx.cn/tags/GC/"}]},{"title":"Go版本切换","slug":"Go_Version_switching","date":"2022-01-05T13:06:11.000Z","updated":"2022-11-15T09:02:25.162Z","comments":true,"path":"2022/01/05/Go_Version_switching/","link":"","permalink":"https://blog.eganx.cn/2022/01/05/Go_Version_switching/","excerpt":"线上的程序用的是老版本的Go(毕竟比较稳)，自己又想尝试新的版本特性。久而久之，电脑里面SDK的版本就越来越多了，每次切换起来就很麻烦。所以特此记录一下。","text":"线上的程序用的是老版本的Go(毕竟比较稳)，自己又想尝试新的版本特性。久而久之，电脑里面SDK的版本就越来越多了，每次切换起来就很麻烦。所以特此记录一下。 0x0.手动管理(目前使用的切换方式)官网下载最新版Archive文件go1.18beta1.darwin-amd64.tar.gz 解压缩重命名go1.18.beta1,拷贝一份放到默认安装路径/usr/local/go1.18beta1 sudo cp -R /User/egan/Sdks/go1.18beta1 /usr/local/go1.18beta1 进入默认安装路径，创建软链 cd /usr/local/sudo ln -s go1.18beta1 go 0x1.版本切换工具1).gGitHub: https:&#x2F;&#x2F;github.com&#x2F;voidint&#x2F;g 2).goupGithub: https:&#x2F;&#x2F;github.com&#x2F;owenthereal&#x2F;goup","categories":[{"name":"Golang","slug":"Golang","permalink":"https://blog.eganx.cn/categories/Golang/"}],"tags":[{"name":"go","slug":"go","permalink":"https://blog.eganx.cn/tags/go/"},{"name":"版本切换","slug":"版本切换","permalink":"https://blog.eganx.cn/tags/%E7%89%88%E6%9C%AC%E5%88%87%E6%8D%A2/"}]},{"title":"C#内存泄露","slug":"CSharp_OOM","date":"2022-01-03T04:31:19.000Z","updated":"2022-11-20T02:42:25.089Z","comments":true,"path":"2022/01/03/CSharp_OOM/","link":"","permalink":"https://blog.eganx.cn/2022/01/03/CSharp_OOM/","excerpt":"记录自己干的蠢事，这也是自己第一次在工作中写出来内存泄漏。幸亏程序没有直接上线，以后还是要多测试测试自己的代码。","text":"记录自己干的蠢事，这也是自己第一次在工作中写出来内存泄漏。幸亏程序没有直接上线，以后还是要多测试测试自己的代码。 0x0.问题产生原因在button1.Click += Button1_Click中，(+=) 来为事件附加事件处理程序 public Form1()&#123; InitializeComponent(); button1.Click += Button1_Click;&#125;private void Button1_Click(object sender, EventArgs e) &#123; System.Diagnostics.Debug.Print(&quot;x&quot;); &#125; public event EventHandler Click;public delegate void EventHandler(object sender, EventArgs e); 给button1_Click的附加事件处理程序放在了心跳里面； 此次溢出是因为每次心跳，又进行了一次事件处理程序的附加，造成不断附件事件处理程序。 直至最后，点击一次，要运行2K+次的事件处理程序。 而事件处理程序的代码里面会使用创建新的线程，运行一次，创建大量的新线程，线程数直接飙升，内存崩掉。 0x1.定位内存泄露发生的地方：C#的代码可以使用内存分析工具dotMemory。dotMemory允许你分析各种.NET和.NET Core应用程序的内存使用情况；比如桌面应用程序、Windows服务、ASP.NET Web应用程序、IIS、IIS Express、任意.NET进程等。不过临时用一下可以，有30天的试用期，还是比较好用的。 溢出版本源码示例: namespace WindowsFormsApp1&#123; public partial class Form1 : Form &#123; private static int i = 0; public Form1() &#123; InitializeComponent(); button1.Click += Button1_Click; &#125; private void Cycle() &#123; button1.Click += Button1_Click; &#125; private void Button1_Click(object sender, EventArgs e) &#123; i += 1; System.Diagnostics.Debug.Print(&quot;x:&#123;0&#125;&quot;,i); Cycle(); &#125; &#125;&#125; 正常版本源码示例： namespace WindowsFormsApp1&#123; public partial class Form1 : Form &#123; private static int i = 0; public Form1() &#123; InitializeComponent(); button1.Click += Button1_Click; &#125; private void Button1_Click(object sender, EventArgs e) &#123; i += 1; System.Diagnostics.Debug.Print(&quot;x:&#123;0&#125;&quot;,i); &#125; &#125;&#125;","categories":[{"name":"Work","slug":"Work","permalink":"https://blog.eganx.cn/categories/Work/"},{"name":"C#","slug":"Work/C","permalink":"https://blog.eganx.cn/categories/Work/C/"}],"tags":[{"name":"C#","slug":"C","permalink":"https://blog.eganx.cn/tags/C/"},{"name":"OOM","slug":"OOM","permalink":"https://blog.eganx.cn/tags/OOM/"}]},{"title":"C#串口读写连续性问题","slug":"CSharp_Serial_port_readwrite_continuity_problem","date":"2022-01-01T03:31:19.000Z","updated":"2022-11-20T02:42:29.078Z","comments":true,"path":"2022/01/01/CSharp_Serial_port_readwrite_continuity_problem/","link":"","permalink":"https://blog.eganx.cn/2022/01/01/CSharp_Serial_port_readwrite_continuity_problem/","excerpt":"在使用串口协议进行自定义协议读写的时候，一般使用Ascii编码。但是串口中读取到的数据并不能保证其完整性。一条指令有可能会被拆分成多条数据发送，读取到的字符串有可能只是其中的一部分。一般一条指令的末尾都会加上\\n\\r作为结束符。","text":"在使用串口协议进行自定义协议读写的时候，一般使用Ascii编码。但是串口中读取到的数据并不能保证其完整性。一条指令有可能会被拆分成多条数据发送，读取到的字符串有可能只是其中的一部分。一般一条指令的末尾都会加上\\n\\r作为结束符。 0x0.创建连接串口使用System.IO.Ports.SerialPort来创建连接 //// 摘要:// 使用指定的端口名、波特率、奇偶校验位、数据位和停止位初始化 System.IO.Ports.SerialPort 类的新实例。//// 参数:// portName:// 要使用的端口（例如 COM1）。//// baudRate:// 波特率。//// parity:// System.IO.Ports.SerialPort.Parity 值之一。//// dataBits:// 数据位值。//// stopBits:// System.IO.Ports.SerialPort.StopBits 值之一。//// 异常:// T:System.IO.IOException:// 未能找到或打开指定的端口。public SerialPort(string portName, int baudRate, Parity parity, int dataBits, StopBits stopBits); 其中Parity和StopBits的枚举分别为： //// 摘要:// 指定 System.IO.Ports.SerialPort 对象的奇偶校验位。public enum Parity&#123; // // 摘要: // 不发生奇偶校验检查。 None = 0, // // 摘要: // 设置奇偶校验位，使位数等于奇数。 Odd = 1, // // 摘要: // 设置奇偶校验位，使位数等于偶数。 Even = 2, // // 摘要: // 将奇偶校验位保留为 1。 Mark = 3, // // 摘要: // 将奇偶校验位保留为 0。 Space = 4&#125; //// 摘要:// 指定在 System.IO.Ports.SerialPort 对象上使用的停止位的数目。public enum StopBits&#123; // // 摘要: // 不使用停止位。 System.IO.Ports.SerialPort.StopBits 属性不支持此值。 None = 0, // // 摘要: // 使用一个停止位。 One = 1, // // 摘要: // 使用两个停止位。 Two = 2, // // 摘要: // 使用 1.5 个停止位。 OnePointFive = 3&#125; 连接完成后需要保证端口的开启，可使用IsOpen参数进行判定。 if (!Conn.IsOpen)&#123; Conn.Open();&#125; 0x1.数据的读写部分何时停止读写，可以根据NewLine的值进行判定。NewLine的默认值是”\\n”换行符，可以根据自己的需求进行更改。”\\r\\n”也是比较常用的NewLine。 //// 摘要:// 获取或设置用于解释 System.IO.Ports.SerialPort.ReadLine 和 System.IO.Ports.SerialPort.WriteLine(System.String)// 方法调用结束的值。//// 返回结果:// 表示行尾的值。 默认值为换行符，System.Environment.NewLine。//// 异常:// T:System.ArgumentException:// 属性值为空。//// T:System.ArgumentNullException:// 属性值为 null。[Browsable(false)][DefaultValue(&quot;\\n&quot;)][MonitoringDescription(&quot;NewLine&quot;)]public string NewLine &#123; get; set; &#125; 如果不想直接设置NewLine，也可以在读取串口数据时，根据自定义字符进行读取划分。 //// 摘要:// 一直读取到输入缓冲区中的指定 value 的字符串。//// 参数:// value:// 指示读取操作停止位置的值。//// 返回结果:// 输入缓冲区中直到指定 value 的内容。//// 异常:// T:System.ArgumentException:// value 参数的长度为 0。//// T:System.ArgumentNullException:// value 参数为 null。//// T:System.InvalidOperationException:// 指定的端口未打开。//// T:System.TimeoutException:// 该操作未在超时时间到期之前完成。public string ReadTo(string value); string reqStr = Conn.ReadTo(&quot;\\r\\n&quot;); 这样读取出来的数据就可以时一条条完整的指令，而不会出现被分隔的指令片段。","categories":[{"name":"Work","slug":"Work","permalink":"https://blog.eganx.cn/categories/Work/"},{"name":"C#","slug":"Work/C","permalink":"https://blog.eganx.cn/categories/Work/C/"}],"tags":[{"name":"C#","slug":"C","permalink":"https://blog.eganx.cn/tags/C/"},{"name":"Serial","slug":"Serial","permalink":"https://blog.eganx.cn/tags/Serial/"}]},{"title":"华为OD笔试","slug":"Huawei_OD_exam","date":"2021-03-09T03:30:12.000Z","updated":"2022-11-20T02:40:46.138Z","comments":true,"path":"2021/03/09/Huawei_OD_exam/","link":"","permalink":"https://blog.eganx.cn/2021/03/09/Huawei_OD_exam/","excerpt":"第一次参加华为OD的笔试，作为参加过精英笔试的优秀青年。我还是想记录一下的。说实话题目还行，但是裸考还是有点难度的(个人观点，或许是我菜的过分了)。","text":"第一次参加华为OD的笔试，作为参加过精英笔试的优秀青年。我还是想记录一下的。说实话题目还行，但是裸考还是有点难度的(个人观点，或许是我菜的过分了)。 0x0.第一题用一个数组A，代表程序员的工作能力。公司想通过结对编程的模式来提高员工的工作能力，假设成对后的能力是两个员工的能力之和，求一共有多少种结对方式，使结对后的能力为N。 提示： 1. 第一行代表员工个数2. 第二行代表各个员工的能力值3. 第三行代表结对后的能力值N4. 输出为结对的组合方式的值 示例： 输入：51 2 2 2 34输出：4 1).解题思路说实话这题放在华为OD的笔试里面，应该是属于送分题，一个输入数组加两层for循环直接解就行，直接附上代码就算了。 2).代码实现//// main.cpp// Demo//// Created by Egan.// #include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;numeric&gt;#include &lt;cctype&gt;using namespace std; int main() &#123; int n,N; int arr[1001]; int count =0; cin &gt;&gt; n; for(int i = 0; i &lt; n; i++)&#123; cin &gt;&gt; arr[i]; &#125; cin &gt;&gt; N; for(int x =0; x &lt; n; x++ )&#123; for(int y= x+1; y &lt;n; y++ )&#123; if(arr[x]+arr[y] == N) count += 1; &#125; &#125; cout &lt;&lt; count &lt;&lt;endl;&#125; 0x1.错误的里程表一个汽车里程表，它以整数形式显示行驶的英里数。然而，里程表有一个缺陷:它从数字3转到数字5，总是跳过数字4。这个缺陷出现在所有的位置(1,10,100，等等)。例如，如果里程表显示为15339，而汽车行驶了1英里，里程表的读数将更改为15350(而不是15340)。 提示： 1. 输入为里程表上的数值2. 输出为实际车子行驶的数值 示例： 输入1：5输出1：3输入2：17输出2：15输入3：100输出3：81 1).解题思路遇到4则直接从3进位到5，所以这是一道典型的进制转化问题，遍历该数字的每一位（如果这一位的数字比4大，就要减去1，因为这个位跳过了一个4），然后再遍历该数字的每一位，将其转化为10进制。 2).代码实现//// main.cpp// Demo//// Created by Egan.//#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;cstdio&gt;using namespace std;int main()&#123; string n; for (int i = 0;; i++) &#123; cin &gt;&gt; n; if(n[0] == &#x27;0&#x27;)&#123; break; &#125; int j = n.size; long long num = 0; ans = 1; for (int m = j-1; m &gt;= 0; m--) &#123; if((n[m]-&#x27;0&#x27;)&gt;4)&#123; num += ((n[m]-&#x27;0&#x27;)-1) * ans; &#125; else&#123; num += (n[m]-&#x27;0&#x27;) * ans; &#125; ans = ans * 9; &#125; cout &lt;&lt; n &lt;&lt; &quot;:&quot;&lt;&lt;num&lt;&lt;endl; &#125;&#125; 0x2.贪吃蛇算法题目太长，具体的记不清楚了，只能大致的描述一下。。。。 输入一个字符矩阵，其中字符E是食物(蛇吃了长度+1的那种)，F是空白，H是蛇的位置(初始只占一个位置) 移动指令有5种，分别让贪吃蛇移动以及转向：G前进、U往上转、D往下转、L往左转、R往右转（初始方向为左） 结束条件是碰壁或者碰到自己就算死了。 求按输入的指令执行之后的蛇的长度。 输入输出示例： 输入：D G G3F E FE E HF F F输出：1","categories":[{"name":"Work","slug":"Work","permalink":"https://blog.eganx.cn/categories/Work/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://blog.eganx.cn/tags/C/"},{"name":"华为OD","slug":"华为OD","permalink":"https://blog.eganx.cn/tags/%E5%8D%8E%E4%B8%BAOD/"},{"name":"笔试","slug":"笔试","permalink":"https://blog.eganx.cn/tags/%E7%AC%94%E8%AF%95/"}]},{"title":"基础计算器II (Basic calculator II)","slug":"Basic_calculator_II","date":"2021-03-02T02:22:11.000Z","updated":"2022-11-20T02:41:25.456Z","comments":true,"path":"2021/03/02/Basic_calculator_II/","link":"","permalink":"https://blog.eganx.cn/2021/03/02/Basic_calculator_II/","excerpt":"栈的经典应用： 给一个字符串表达式 s ，实现一个基本计算器来计算并返回它的值。(整数除法仅保留整数部分)","text":"栈的经典应用： 给一个字符串表达式 s ，实现一个基本计算器来计算并返回它的值。(整数除法仅保留整数部分) 提示： 1. 1 &lt;&#x3D; s.length &lt;&#x3D; 3 * 10^52. s 由整数和算符(&#39;+&#39;, &#39;-&#39;, &#39;*&#39;, &#39;&#x2F;&#39;)组成,中间由一些空格隔开3. s 表示一个有效表达式4. 表达式中的所有整数都是非负整数,且在范围[0, 231 - 1]内5. 题目数据保证答案是一个32-bit整数 示例： 输入：s &#x3D; &quot;3+2*2&quot;输出：7 0x0.解题思路栈的经典应用，此题没有括号，不需要进行括号匹配，相对来说简单一点，可以直接进行暴力求解。 需要考虑运算符的优先级问题。乘除的优先级大于加减，可以先进行乘除运算，用一个栈，保存进行乘除运算后的整数的值。对于加减号后的数字，将其直接压入栈中；对于乘除号后的数字，直接与栈顶元素计算，并替换栈顶元素为计算后的结果。 遍历字符串 s，并用变量preSign记录每个数字之前的运算符，对于第一个数字，其之前的运算符视为加号。遍历到运算符或者字符串最后一位时，根据preSign来决定计算方式: 加号：数字直接入栈； 减号：num变(-num)入栈； 乘除：num ( * or / ) stack.back()，并将栈顶元素替换为运算结果。 0x1.复杂度分析 时间复杂度：O(n)，其中n为字符串s的长度。需要遍历字符串s一次，计算表达式的值。 空间复杂度：O(n)，其中n为字符串s的长度。空间复杂度主要取决于栈的空间，栈的元素个数不超过n。 需要注意的是 在运算的时候，判断字符是数字还是运算符的时候，需要使用isdigit()函数，此函数包含在头文件#include &lt;cctype&gt;中。 运算的时候，如果遇到的数是大数(两位数及以上的)，需要进行处理。大数在字符串中是两个字符，需要在遍历字符串时，使用num = num * 10 + int (s[i] - &#39;0&#39;);对大数进行处理。 在乘除运算的结果都模拟入栈之后，使用累加函数accumulate(st.begin(), st.end(), 0);对数组进行累加处理，accumulate()函数包含在头文件#include &lt;numeric&gt;中，累加过程中，正负数都可以处理。 0x2.代码实现//// main.cpp// Demo//// Created by Egan.// #include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;numeric&gt;#include &lt;cctype&gt;using namespace std; int main() &#123; class Solution &#123; public: int calculate(string s) &#123; vector&lt;int&gt; st; //digits char ps = &#x27;+&#x27;; //presign int num = 0; for(int i = 0; i &lt; s.length(); i++)&#123; if (isdigit(s[i]))&#123; //#include &lt;cctype&gt; num = num * 10 + int (s[i] - &#x27;0&#x27;); &#125; if (!isdigit(s[i]) &amp;&amp; s[i] != &#x27; &#x27; || i == s.length()-1)&#123; switch(ps)&#123; case &#x27;+&#x27; : st.push_back(num); break; case &#x27;-&#x27; : st.push_back(-num); break; case &#x27;*&#x27; : st.back() *= num; break; case &#x27;/&#x27; : st.back() /= num; break; &#125; ps = s[i]; num = 0; &#125; &#125; return accumulate(st.begin(), st.end(), 0); //#include&lt;numeric&gt; &#125;&#125;;&#125;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://blog.eganx.cn/categories/Leetcode/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://blog.eganx.cn/tags/C/"},{"name":"栈","slug":"栈","permalink":"https://blog.eganx.cn/tags/%E6%A0%88/"}]},{"title":"逆波兰表示法(Reverse Polish notation)","slug":"Reverse Polish notation","date":"2021-03-01T08:12:14.000Z","updated":"2022-11-20T02:41:34.945Z","comments":true,"path":"2021/03/01/Reverse Polish notation/","link":"","permalink":"https://blog.eganx.cn/2021/03/01/Reverse%20Polish%20notation/","excerpt":"根据逆波兰表示法，求表达式的值。 有效的运算符包括 +, -, *, / 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。","text":"根据逆波兰表示法，求表达式的值。 有效的运算符包括 +, -, *, / 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。 0x0.解题思路逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。 逆波兰表达式主要有以下两个优点： 去掉括号后表达式无歧义，( 1 + 2 ) * ( 3 + 4 )即便写成 1 2 + 3 4 + * 也可以依据次序计算出正确结果。 适合用栈操作运算 逆波兰表达式的求解是栈的经典应用。所以此题采用栈来解决，遇到数字则入栈，遇到运算符则取出栈顶两个数字进行运算，并将结果压入栈中。 需要注意的是 在运算的时候，需要后取出的数字在前，先取出的数字在后，即num2在前。 stoi表示string to int，即字符串转整数 0x1.代码实现//// main.cpp// Demo//// Created by Egan.// #include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;stack&gt;#include &lt;cstring&gt;using namespace std; int main() &#123; class Solution &#123; public: int evalRPN(vector&lt;string&gt;&amp; tokens) &#123; stack&lt;int&gt; s; for(int i=0; i&lt;tokens.size(); i++)&#123; if(tokens[i] == &quot;+&quot;||tokens[i] == &quot;-&quot;||tokens[i] == &quot;*&quot;||tokens[i] == &quot;/&quot;)&#123; int num1 = s.top(); s.pop(); int num2 = s.top(); s.pop(); if(tokens[i] == &quot;+&quot;) s.push(num2 + num1); if(tokens[i] == &quot;-&quot;) s.push(num2 - num1); if(tokens[i] == &quot;*&quot;) s.push(num2 * num1); if(tokens[i] == &quot;/&quot;) s.push(num2 / num1); &#125; else &#123; s.push(stoi(tokens[i])); &#125; &#125; int result = s.top(); return result; &#125;&#125;;&#125;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://blog.eganx.cn/categories/Leetcode/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://blog.eganx.cn/tags/C/"},{"name":"栈","slug":"栈","permalink":"https://blog.eganx.cn/tags/%E6%A0%88/"}]},{"title":"明明的随机数(Ming's random numbers)","slug":"Ming's_random_numbers","date":"2021-02-22T05:46:57.000Z","updated":"2022-11-20T02:41:39.367Z","comments":true,"path":"2021/02/22/Ming's_random_numbers/","link":"","permalink":"https://blog.eganx.cn/2021/02/22/Ming's_random_numbers/","excerpt":"明明想在学校中请一些同学一起做一项问卷调查，为了实验的客观性，他先用计算机生成了N个1到1000之间的随机整数（N≤1000），对于其中重复的数字，只保留一个，把其余相同的数去掉，不同的数对应着不同的学生的学号。然后再把这些数从小到大排序，按照排好的顺序去找同学做调查。请你协助明明完成“去重”与“排序”的工作(同一个测试用例里可能会有多组数据(用于不同的调查)，希望大家能正确处理)","text":"明明想在学校中请一些同学一起做一项问卷调查，为了实验的客观性，他先用计算机生成了N个1到1000之间的随机整数（N≤1000），对于其中重复的数字，只保留一个，把其余相同的数去掉，不同的数对应着不同的学生的学号。然后再把这些数从小到大排序，按照排好的顺序去找同学做调查。请你协助明明完成“去重”与“排序”的工作(同一个测试用例里可能会有多组数据(用于不同的调查)，希望大家能正确处理) 0x0.解题思路这是华为的一道面试题。在原文中已经明确点出了所需的一些函数，分别是排序和去重。C++有现成的排序函数sort()，以及去重函数unique()。其中unique(),sort()都是属于头文件#include &lt;algorithm&gt; auto end_un = unique(vec.begin(),vec.end()); 这里的unique()返回的值是最后一个不重复数字的下标。 sort函数有三个参数： 第一个是要排序的数组的起始地址 第二个是结束的地址（最后一位要排序的地址) 第三个参数是排序的方法，可以是升序也可是降序。如果不写第三个参数，则默认的排序方法是升序排列 //升序sort( a, b, less&lt;int&gt;() ); //降序sort( a, b, greater&lt;int&gt;() ); 如果先去重再排序，那么去重就有可能不会发挥作用。因为去重再排序排序时会把重复的数字又放在了一起，所以要先排序再去重。 0x1.代码实现//// main.cpp// Demo//// Created by Egan.// #include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std; int main() &#123; int n= 0,num = 0; while (cin &gt;&gt; n) &#123; vector&lt;int&gt; vec; //input for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; num; vec.push_back(num); &#125; //sort sort(vec.begin(), vec.end()); //unique auto end_un = unique(vec.begin(),vec.end()); vec.erase(end_un, vec.end()); for (auto m = vec.begin(); m != vec.end(); m ++) &#123; cout &lt;&lt; *m &lt;&lt; endl; &#125; &#125; return 0;&#125;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://blog.eganx.cn/categories/Leetcode/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://blog.eganx.cn/tags/C/"},{"name":"sort","slug":"sort","permalink":"https://blog.eganx.cn/tags/sort/"},{"name":"unique","slug":"unique","permalink":"https://blog.eganx.cn/tags/unique/"}]},{"title":"毕业半年的自己","slug":"Six_months_after_graduation","date":"2020-12-22T05:46:57.000Z","updated":"2022-11-20T02:40:30.506Z","comments":true,"path":"2020/12/22/Six_months_after_graduation/","link":"","permalink":"https://blog.eganx.cn/2020/12/22/Six_months_after_graduation/","excerpt":"","text":"0x0.半年之后&emsp;我们这届的毕业生，大学只上了三年半，最后半年的时光都是在家里渡过。拿毕业证学位证、拍毕业照以及收拾行李，加起来不过两天时间。一切都是匆匆忙忙，匆忙到连一顿散伙饭都没法进行。&emsp;还差几日，自己也就毕业半年了，也算是有了半年的工作经验(划水经验)，学软件的我，毕业之后进了一家偏自动化的公司，工业4.0时代嘛，天天代码倒是不多，感觉还不错。","categories":[{"name":"工作","slug":"工作","permalink":"https://blog.eganx.cn/categories/%E5%B7%A5%E4%BD%9C/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.eganx.cn/tags/%E6%97%A5%E5%B8%B8/"},{"name":"杂记","slug":"杂记","permalink":"https://blog.eganx.cn/tags/%E6%9D%82%E8%AE%B0/"}]},{"title":"Test","slug":"firstPage","date":"2020-10-22T03:10:47.000Z","updated":"2022-01-20T11:36:20.632Z","comments":true,"path":"2020/10/22/firstPage/","link":"","permalink":"https://blog.eganx.cn/2020/10/22/firstPage/","excerpt":"","text":"测试文档 从这一篇测试文档开始，希望自己能够收起懒惰，重拾激情","categories":[],"tags":[{"name":"Test","slug":"Test","permalink":"https://blog.eganx.cn/tags/Test/"}]}],"categories":[{"name":"Golang","slug":"Golang","permalink":"https://blog.eganx.cn/categories/Golang/"},{"name":"Work","slug":"Work","permalink":"https://blog.eganx.cn/categories/Work/"},{"name":"C#","slug":"Work/C","permalink":"https://blog.eganx.cn/categories/Work/C/"},{"name":"Leetcode","slug":"Leetcode","permalink":"https://blog.eganx.cn/categories/Leetcode/"},{"name":"工作","slug":"工作","permalink":"https://blog.eganx.cn/categories/%E5%B7%A5%E4%BD%9C/"}],"tags":[{"name":"go","slug":"go","permalink":"https://blog.eganx.cn/tags/go/"},{"name":"interface","slug":"interface","permalink":"https://blog.eganx.cn/tags/interface/"},{"name":"map","slug":"map","permalink":"https://blog.eganx.cn/tags/map/"},{"name":"slice","slug":"slice","permalink":"https://blog.eganx.cn/tags/slice/"},{"name":"C#","slug":"C","permalink":"https://blog.eganx.cn/tags/C/"},{"name":"GC","slug":"GC","permalink":"https://blog.eganx.cn/tags/GC/"},{"name":"版本切换","slug":"版本切换","permalink":"https://blog.eganx.cn/tags/%E7%89%88%E6%9C%AC%E5%88%87%E6%8D%A2/"},{"name":"OOM","slug":"OOM","permalink":"https://blog.eganx.cn/tags/OOM/"},{"name":"Serial","slug":"Serial","permalink":"https://blog.eganx.cn/tags/Serial/"},{"name":"C++","slug":"C","permalink":"https://blog.eganx.cn/tags/C/"},{"name":"华为OD","slug":"华为OD","permalink":"https://blog.eganx.cn/tags/%E5%8D%8E%E4%B8%BAOD/"},{"name":"笔试","slug":"笔试","permalink":"https://blog.eganx.cn/tags/%E7%AC%94%E8%AF%95/"},{"name":"栈","slug":"栈","permalink":"https://blog.eganx.cn/tags/%E6%A0%88/"},{"name":"sort","slug":"sort","permalink":"https://blog.eganx.cn/tags/sort/"},{"name":"unique","slug":"unique","permalink":"https://blog.eganx.cn/tags/unique/"},{"name":"日常","slug":"日常","permalink":"https://blog.eganx.cn/tags/%E6%97%A5%E5%B8%B8/"},{"name":"杂记","slug":"杂记","permalink":"https://blog.eganx.cn/tags/%E6%9D%82%E8%AE%B0/"},{"name":"Test","slug":"Test","permalink":"https://blog.eganx.cn/tags/Test/"}]}