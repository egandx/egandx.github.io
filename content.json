{"meta":{"title":"Egan's Blog","subtitle":"The winter is coming","description":"You are more than what you have become","author":"Egan Dong","url":"https://blog.eganx.cn","root":"/"},"pages":[{"title":"关于","date":"2020-12-22T08:06:06.000Z","updated":"2022-11-20T02:34:31.036Z","comments":true,"path":"about/index.html","permalink":"https://blog.eganx.cn/about/index.html","excerpt":"","text":"一个写C#客户端和Go服务端的小垃圾。毕业两年多，啥也不是…… 个人说明： 该用户很宅 该用户不吸烟 该用户使用Linux 该用户支持言论自由 该用户认为知易行难 该用户日常靠咖啡续命 该用户反对读书无用论 该用户不喜欢微信和QQ 该用户对电脑程序感兴趣 该用户谢绝使用百度搜索引擎"},{"title":"分类","date":"2020-12-22T08:07:23.000Z","updated":"2020-12-22T08:08:17.000Z","comments":true,"path":"categories/index.html","permalink":"https://blog.eganx.cn/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2020-12-22T08:08:32.000Z","updated":"2020-12-22T08:09:05.000Z","comments":true,"path":"link/index.html","permalink":"https://blog.eganx.cn/link/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-12-22T08:06:06.000Z","updated":"2020-12-22T08:07:11.000Z","comments":true,"path":"tags/index.html","permalink":"https://blog.eganx.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"2023第一篇面经","slug":"2023_Interviews_No.1","date":"2023-02-26T07:40:11.000Z","updated":"2023-03-07T08:49:52.961Z","comments":true,"path":"2023/02/26/2023_Interviews_No.1/","link":"","permalink":"https://blog.eganx.cn/2023/02/26/2023_Interviews_No.1/","excerpt":"2023开年第一篇面经。部分答案由ChatGPT补充","text":"2023开年第一篇面经。部分答案由ChatGPT补充 0x0.谈谈go的内存对齐在 Go 语言中，内存对齐是指结构体成员（字段）在内存中的对齐方式。具体来说，它决定了一个结构体成员在内存中的起始地址，以及在内存中占用的字节数。 Go 语言会自动为结构体成员进行内存对齐，并根据需要在结构体成员之间填充空闲字节，以确保结构体成员在内存中的地址和长度都符合硬件要求。这种自动化的内存对齐机制可以提高内存读写效率，减少 CPU 访问内存时的等待时间。 在 Go 语言中，一个结构体成员的对齐方式取决于其类型和大小。具体来说，一个结构体成员的对齐方式必须满足以下条件： 结构体成员的首地址必须是其大小（即占用的字节数）的倍数。 结构体成员的大小必须是 2 的整数次幂（即 1、2、4、8 等）。 如果结构体成员的大小不是 2 的整数次幂，则需要填充额外的空间以满足对齐的要求。例如，在一个结构体中定义了一个 int8 类型的成员和一个 int32 类型的成员，那么在 int8 成员后面就需要填充 3 个字节的空闲空间，才能让 int32 成员的地址满足对齐的要求。 需要注意的是，在 Go 语言中，结构体成员之间的空闲字节是不能被使用的，因此它们只是为了填充内存而存在。如果想要更精细地控制结构体成员的内存布局，可以使用 `unsafe` 包中的相关函数来手动调整内存对齐方式，但需要注意安全性问题。 在 Go 语言中，各个类型在内存对齐中所占大小如下： bool：1 字节。 int8、uint8（即 byte）、int16、uint16：2 字节。 int32、uint32、float32：4 字节。 int64、uint64、float64、complex64：8 字节。 complex128：16 字节。 string、slice、指针、map、channel 等引用类型：8 字节（在 64 位架构中）或 4 字节（在 32 位架构中），其中包含的是一个指向底层数据结构的指针。 struct 类型的大小取决于其成员变量的大小和排列方式，由编译器自动进行内存对齐。 这里给出的是一个基本的规则，实际上不同的编译器和操作系统可能会有不同的对齐方式和字节数。 Go语言的unsafe包提供了一些底层操作，包括调整内存对齐。可以使用unsafe包中的Alignof和Offsetof函数来获取结构体中字段的对齐方式和偏移量，然后使用uintptr类型的指针进行指针运算和内存地址计算。使用unsafe.Pointer类型的指针可以将任何类型的指针转换为通用指针类型，从而进行底层操作。但是需要注意，在使用unsafe包时要特别小心，因为它可能会导致程序不安全或不可移植。 0x1. 谈谈TCP和UDP的区别TCP（Transmission Control Protocol）和UDP（User Datagram Protocol）是两种网络协议，用于在计算机上运行的应用程序之间传输数据。它们有以下几个主要区别： 连接：TCP是面向连接的协议，而UDP是无连接的协议。TCP通过三次握手建立连接，然后在发送和接收数据之前进行验证和确认。而UDP直接发送数据，没有连接的建立和维护过程。 可靠性：TCP提供可靠的数据传输，确保数据按照发送顺序到达目标地址，并且不会丢失或重复。它通过重传丢失的数据包、流量控制和拥塞控制等机制来保证数据传输的可靠性。而UDP不提供可靠性保证，数据包可能会丢失、重复、乱序等，需要应用层自己处理。 效率：由于TCP提供了可靠的数据传输和额外的控制协议，因此它通常比UDP慢一些，但比较稳定。而UDP没有这些额外的控制协议，因此速度比TCP快，但不够稳定。 适用场景：TCP适用于需要可靠数据传输且需要顺序传输的应用程序，如文件传输、电子邮件、网页浏览等；而UDP适用于实时性要求高、对数据完整性和顺序性要求不高的应用程序，如音频、视频、游戏等。 补充： TCP的三次握手是指在建立TCP连接时，客户端和服务器之间需要进行三次交互来确认双方的通信状态。具体过程如下：1. 客户端向服务器发送SYN（同步）报文，表示客户端请求建立连接，并给这个数据包分配一个随机的初始序列号（ISN）。2. 服务器收到客户端的SYN报文后，回复一个SYN+ACK（同步&#x2F;确认）报文，表示接收到了客户端的连接请求，并确认自己也希望建立连接。同时，在这个SYN+ACK报文中也会分配一个随机的初始序列号。3. 客户端再次回复一个ACK（确认）报文，表示已经收到了服务器的确认，可以开始传输数据了。此时，TCP连接就建立完成了。在这个过程中，第一次握手是客户端向服务器发起连接请求，第二次握手是服务器接收客户端的请求并回复确认，第三次握手是客户端回复服务器的确认。这样，双方都确认了自己和对方的状态，保证了数据传输的可靠性。 0x2. 谈一下golang死锁在golang中，死锁指的是一种场景，即所有goroutine都被互相等待，导致程序无法继续执行。这种情况通常出现在使用channel进行通信时，并且没有正确地管理好goroutine之间的通信流程。 一个常见的例子是两个goroutine相互等待对方释放锁的情况，如下面的代码： package mainfunc main() &#123; ch := make(chan int) go func() &#123; &lt;-ch // 1. 等待从通道中读取数据 ch &lt;- 1 // 3. 向通道中写入数据 &#125;() ch &lt;- 1 // 2. 向通道中写入数据&#125; 在这段代码中，第一个goroutine等待从通道中读取数据（步骤1），但是在这之前它必须等待第二个goroutine向通道中写入数据（步骤2）。而第二个goroutine同样需要等待第一个goroutine从通道中读取数据后才能向通道中写入数据（步骤3）。因此，在这种情况下，两个goroutine将会陷入无限期的等待，导致程序无法继续执行，最终出现死锁。 为了避免死锁的发生，需要合理地设计和管理goroutine之间的通信流程，确保每个goroutine在正确的时间点上释放锁并等待其它goroutine的响应。此外，可以使用go语言内置的工具来帮助检测和解决死锁问题，例如`go vet`、`go tool vet`等。 0x3. Go的并发机制Go语言的并发机制是一种基于Goroutine和Channel的轻量级协程模型，具有高效、简洁、安全等特点，可用于实现高并发、分布式、异步和并行计算等场景。下面详细介绍Go语言的并发机制。 GoroutineGoroutine是一种轻量级的用户态线程，由Go运行时系统调度，在单个操作系统线程上并发执行多个任务。Goroutine的创建非常简单，只需使用关键字go后跟需要执行的函数即可： func main() &#123; go func() &#123; fmt.Println(&quot;Hello, Goroutine!&quot;) &#125;() // ...&#125; 在这个例子中，使用go关键字启动一个新的Goroutine，执行匿名函数并输出”Hello, Goroutine!”。与传统的线程相比，Goroutine更加轻量级、灵活、高效，因为它们可以在需要时自动伸缩，并且可以通过通信来共享数据和协调行为，无需显式的锁或条件变量等同步机制。 Channel Channel是Goroutine之间进行通信的一种方式，它类似于UNIX中的管道，可以将数据从一个Goroutine发送到另一个Goroutine。Channel有以下几个特点： Channel是类型化的，必须指定传输数据的类型； Channel是同步的，发送和接收操作都会阻塞，直到对应的另一个Goroutine完成了配对操作； Channel是并发安全的，多个Goroutine同时操作同一个Channel时不会出现竞态条件或死锁等问题。 可以通过make函数创建Channel示例：ch := make(chan int) // 创建一个int类型的Channel 通过&lt;-符号进行发送和接收操作： ch &lt;- 1 // 向Channel中发送数据value := &lt;-ch // 从Channel中接收数据 同时，可以使用range关键字遍历Channel中的所有数据，或者使用select结构体实现多路复用等操作。 共享内存 除了使用Channel进行通信外，Go语言也支持传统的共享内存并发模型，例如使用sync包中提供的锁（Mutex）和条件变量（Cond）等机制。这些机制可以在多个Goroutine之间共享访问同一份数据，并进行同步和互斥等操作。 原子操作 为了避免竞态条件等问题，Go语言还提供了原子操作（atomic）机制，用于保证对共享资源的并发访问的原子性和一致性。原子操作包括原子增减、原子比较交换、原子读写等操作，可以有效地解决多个Goroutine同时对同一份数据进行操作的问题。 总体来说，Go语言的并发机制具有高效、简洁、安全等优点，使得它成为了开发高并发、分布式、异步和并行计算等应用程序的理想语言和工具。 0x4. MVC 和 MVVM的异同MVC (Model-View-Controller) 和 MVVM (Model-View-ViewModel) 是两种常见的应用程序设计模式，其目的都是在应用程序中清晰地分离数据、用户界面和业务逻辑。虽然这两种模式都有类似的架构，但它们之间存在一些重要的区别。 MVC 模式：MVC 模式是一种传统的模式，最早用于桌面应用程序的设计。在 MVC 中，软件应用程序被划分为三个部分：模型（Model）、视图（View）和控制器（Controller）。 Model是应用程序中的数据和状态的主要表示。它与数据库或其他持久性存储解耦，并提供了一个简单的接口来获取和设置数据。 View是用户界面的呈现，它负责显示 Model 对象的当前状态。 Controller 接收用户输入并根据需要更新 Model 和 View。 它充当 View 和 Model 之间的协调者，并包含适当的逻辑和算法来更新它们。 MVC 模式的优点是强制实现代码的分离和组织方式，使得代码更加清晰和易于维护。但是，MVC 模式可能会导致控制器变得过于复杂，因为它承担了太多的责任。 MVVM 模式：MVVM 模式是一种比较新的模式，最初用于 Windows Presentation Foundation (WPF) 的设计。在 MVVM 中，应用程序也被划分为三个部分：模型（Model）、视图（View）和视图模型（ViewModel）。 Model 与 MVC 模式相同，表示应用程序中的数据和状态。 View 是用户界面的呈现，它负责显示视图模型（ViewModel）所公开的属性和命令。 ViewModel 是 View 和 Model 之间的连接器，它充当模型和视图之间的协调者。ViewModel 将 Model 对象转换为 View 可以直接使用的格式，并将数据绑定到 View 上。 MVVM 模式的优点是更好的可扩展性和可维护性，因为 ViewModel 在处理显示逻辑时不会像控制器那样过于复杂，而且数据绑定功能可以减少代码的重复和冗余。然而，MVVM 模式需要更多的学习和实践，特别是在处理大量异步操作和复杂 UI 逻辑时。 0x5. 进程、线程、协程的区别进程、线程和协程的区别主要表现在以下几个方面： 调度方式：进程和线程都由操作系统进行调度，而协程的调度是由程序员手动控制。 系统开销：每个进程都有独立的内存空间和系统资源，所以创建和撤销进程的代价比较大。线程共享相同的内存空间和资源，所以创建和撤销线程的代价比进程要小一些。而协程则更加轻量级，创建和撤销协程的代价最小。 内存空间：每个进程都有自己独立的内存空间，不同进程之间的内存无法共享。线程共享相同的内存空间，但是需要考虑线程安全问题。协程也共享相同的内存空间，但是可以通过控制协程的执行顺序来避免线程安全问题。 执行速度：由于每个进程都有独立的内存空间和资源，因此进程之间的通信和同步比较慢。线程共享相同的内存空间和资源，因此线程之间的通信和同步比进程快一些。协程更快速和高效，因为它们不需要像线程那样切换上下文。 0x6. Go的GC机制三色标记法、混合读写屏障。之前的笔记📒balabalabala 0x7. 如何连通两个互不相连的局域网两个互不相连的局域网要进行通信，可以通过以下几种方式实现： VPN（Virtual Private Network）：通过在公共网络上建立虚拟专用网络来连接两个局域网。VPN 可以使用安全的加密协议来保护通信数据的安全性。 隧道（Tunneling）：通过在公共网络上建立一个隧道来连接两个局域网。隧道可以使用加密协议来保护通信数据的机密性和完整性。 NAT（Network Address Translation）转换：使用 NAT 转换器将两个局域网中的 IP 地址转换为公网 IP 地址，从而使它们可以相互访问。 代理服务器（Proxy Server）：在两个局域网之间放置一个代理服务器，通过代理服务器进行通信。 公共云服务（Public Cloud Service）：将两个局域网连接到同一个公共云服务中，并使用该服务提供的网络功能进行通信。 总的来说，连接两个互不相连的局域网需要考虑数据安全性、通信速度、成本等因素，选择合适的方法进行连接。 0x7. 开放式讨论 C#和Go的区别 开放式 随便说","categories":[{"name":"Work","slug":"Work","permalink":"https://blog.eganx.cn/categories/Work/"}],"tags":[{"name":"Go","slug":"Go","permalink":"https://blog.eganx.cn/tags/Go/"},{"name":"面试","slug":"面试","permalink":"https://blog.eganx.cn/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"1. 两数之和","slug":"1. Two_sum","date":"2023-02-04T14:22:11.000Z","updated":"2023-03-07T07:44:17.211Z","comments":true,"path":"2023/02/04/1. Two_sum/","link":"","permalink":"https://blog.eganx.cn/2023/02/04/1.%20Two_sum/","excerpt":"0x0. 题目描述给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。你可以按任意顺序返回答案。","text":"0x0. 题目描述给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。你可以按任意顺序返回答案。 链接： https://leetcode.cn/problems/two-sum 0x1. 示例示例 1： 输入：nums &#x3D; [2,7,11,15], target &#x3D; 9输出：[0,1]解释：因为 nums[0] + nums[1] &#x3D;&#x3D; 9 ，返回 [0, 1] 。 示例 2： 输入：nums &#x3D; [3,2,4], target &#x3D; 6输出：[1,2] 示例 3： 输入：nums &#x3D; [3,3], target &#x3D; 6输出：[0,1] 0x2. 提示： 2 &lt;= nums.length &lt;= 104 -109 &lt;= nums[i] &lt;= 109 -109 &lt;= target &lt;= 109 只会存在一个有效答案 0x3. 解题思路： 创建一个哈希表 map，用于存储数组中每个数对应的索引。 遍历数组 nums，检查当前数字 num 的补数 complement 是否在哈希表中出现过（即是否满足 complement = target - num），如果是，则说明已经找到了答案，返回两个数的索引；否则，将当前数字和它的索引加入哈希表中。 如果遍历完整个数组都没有找到符合条件的数对，则说明不存在这样的两个数，返回空数组或者抛出异常。 0x4. Go 语言实现的代码示例：func twoSum(nums []int, target int) []int &#123; m := make(map[int]int) // 创建哈希表 for i, num := range nums &#123; complement := target - num if j, ok := m[complement]; ok &#123; // 如果哈希表中已经存在 complement，则说明找到了答案 return []int&#123;j, i&#125; &#125; m[num] = i // 将当前数字和它的索引加入哈希表中 &#125; return nil // 如果遍历完整个数组都没有找到符合条件的数对，则返回空数组&#125; 时间复杂度为 O(n)，空间复杂度为 O(n)。","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://blog.eganx.cn/categories/Leetcode/"}],"tags":[{"name":"Go","slug":"Go","permalink":"https://blog.eganx.cn/tags/Go/"},{"name":"Leetcode","slug":"Leetcode","permalink":"https://blog.eganx.cn/tags/Leetcode/"},{"name":"hashmap","slug":"hashmap","permalink":"https://blog.eganx.cn/tags/hashmap/"}]},{"title":"202.快乐数","slug":"202. Happy_number","date":"2023-02-04T14:22:11.000Z","updated":"2023-03-07T07:44:23.332Z","comments":true,"path":"2023/02/04/202. Happy_number/","link":"","permalink":"https://blog.eganx.cn/2023/02/04/202.%20Happy_number/","excerpt":"0x0. 题目描述编写一个算法来判断一个数 n 是不是快乐数。「快乐数」 定义为： 对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。 然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。 如果这个过程 结果为 1，那么这个数就是快乐数。如果 n 是 快乐数 就返回 true ；不是，则返回 false 。","text":"0x0. 题目描述编写一个算法来判断一个数 n 是不是快乐数。「快乐数」 定义为： 对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。 然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。 如果这个过程 结果为 1，那么这个数就是快乐数。如果 n 是 快乐数 就返回 true ；不是，则返回 false 。 链接： https://leetcode.cn/problems/happy-number 0x1. 示例示例 1： 输入：n &#x3D; 19输出：true解释：12 + 92 &#x3D; 8282 + 22 &#x3D; 6862 + 82 &#x3D; 10012 + 02 + 02 &#x3D; 1 示例 2： 输入：n &#x3D; 2输出：false 0x2. 提示 1 &lt;= n &lt;= 231 - 1 0x3. 解题思路： 定义一个哈希集合 seen，用于记录每次计算的结果。 从输入数字 n 开始，计算其每个数位的平方和，并将结果存入变量 sum 中。例如，对于数字 n=19，计算过程为：1² + 9² = 82。 检查 sum 是否等于 1。如果是，则说明 n 是快乐数，返回 true；如果不是，则检查 sum 是否在 seen 集合中出现过。如果是，则说明已经进入了循环，n 不是快乐数，返回 false。如果不是，则将 sum 加入集合 seen 中，并更新 n 的值为 sum，继续进行下一轮计算。 重复步骤 2-3 直到找到答案或者进入循环。 0x4. Go 语言实现的代码示例：func isHappy(n int) bool &#123; seen := make(map[int]bool) // 创建哈希集合 for n != 1 &amp;&amp; !seen[n] &#123; // 判断是否已经找到答案或者进入循环 seen[n] = true // 将当前数加入哈希集合 sum := 0 for n &gt; 0 &#123; // 计算每个数位的平方和 digit := n % 10 sum += digit * digit n /= 10 &#125; n = sum // 更新 n 的值为平方和 &#125; return n == 1 // 如果最终得到 1，则说明是快乐数；否则不是&#125; 时间复杂度为 O(log n)，空间复杂度为 O(log n)。","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://blog.eganx.cn/categories/Leetcode/"}],"tags":[{"name":"Go","slug":"Go","permalink":"https://blog.eganx.cn/tags/Go/"},{"name":"Leetcode","slug":"Leetcode","permalink":"https://blog.eganx.cn/tags/Leetcode/"},{"name":"hashmap","slug":"hashmap","permalink":"https://blog.eganx.cn/tags/hashmap/"}]},{"title":"383. 赎金信","slug":"383. ransom_note","date":"2023-02-04T14:22:11.000Z","updated":"2023-03-07T07:44:34.902Z","comments":true,"path":"2023/02/04/383. ransom_note/","link":"","permalink":"https://blog.eganx.cn/2023/02/04/383.%20ransom_note/","excerpt":"0x0. 题目描述给你两个字符串：ransomNote 和 magazine ，判断 ransomNote 能不能由 magazine 里面的字符构成。如果可以，返回 true ；否则返回 false 。magazine 中的每个字符只能在 ransomNote 中使用一次。","text":"0x0. 题目描述给你两个字符串：ransomNote 和 magazine ，判断 ransomNote 能不能由 magazine 里面的字符构成。如果可以，返回 true ；否则返回 false 。magazine 中的每个字符只能在 ransomNote 中使用一次。 链接： https://leetcode.cn/problems/ransom-note 0x1. 示例示例 1： 输入：ransomNote &#x3D; &quot;a&quot;, magazine &#x3D; &quot;b&quot;输出：false示例 2： 示例 2： 输入：ransomNote &#x3D; &quot;aa&quot;, magazine &#x3D; &quot;ab&quot;输出：false 示例 3： 输入：ransomNote &#x3D; &quot;aa&quot;, magazine &#x3D; &quot;aab&quot;输出：true 0x2. 提示 1 &lt;= ransomNote.length, magazine.length &lt;= 105 ransomNote 和 magazine 由小写英文字母组成 0x3. 解题思路1 创建一个长度为 27（26 个小写字母加一个边界值）的整型数组 ml，用于记录 magazine 中每个字符出现的次数。 遍历字符串 magazine 中的每个字符 v，将 ml[v-&#39;a&#39;] 的值加 1，表示字符 v 出现了一次。 遍历字符串 ransomNote 中的每个字符 vv，将 ml[vv-&#39;a&#39;] 的值减 1，表示字符 vv 在 magazine 中被使用了一次。如果 ml[vv-&#39;a&#39;] 的值小于 0，则说明 ranasomNote 中出现了一个 magazine 中没有的字符，返回 false。 如果遍历完整个 ransomNote 后都没有返回 false，则说明可以由 magazine 构成，返回 true。 0x3. 解题思路2 创建一个哈希表 mag，用于记录 magazine 中每个字符出现的次数。 遍历 ransomNote 中的每个字符，检查它是否在哈希表 mag 中出现过。如果没有出现过，则说明不能由 magazine 构成，返回 false；如果出现过，则将该字符对应的计数减 1。 如果遍历完整个 ransomNote 都没有返回 false，则说明可以由 magazine 构成，返回 true。 0x4. Go 语言实现的代码示例1：func canConstruct(ransomNote string, magazine string) bool &#123; ml := make([]int,27) for _, v := range magazine &#123; ml[v-&#x27;a&#x27;]++ &#125; for _, vv := range ransomNote &#123; ml[vv-&#x27;a&#x27;]-- if ml[vv-&#x27;a&#x27;] &lt; 0 &#123; return false &#125; &#125; return true&#125; 使用两个数组来分别记录两个字符串中每个字符出现的次数。由于只需要遍历两个字符串各一遍，因此时间复杂度为 O(m+n)，空间复杂度为 O(1)，其中 m 和 n 分别为字符串 ransomNote 和 magazine 的长度。 0x4. Go 语言实现的代码示例2：func canConstruct(ransomNote string, magazine string) bool &#123; mag := make(map[byte]int) // 创建哈希表 for i := range magazine &#123; mag[magazine[i]]++ // 记录 magazine 中每个字符出现的次数 &#125; for i := range ransomNote &#123; if cnt, ok := mag[ransomNote[i]]; !ok || cnt == 0 &#123; // 检查 ransomNote 中的每个字符是否在 mag 中出现过 return false &#125; else &#123; mag[ransomNote[i]]-- // 将 mag 中对应字符的计数减 1 &#125; &#125; return true&#125; 时间复杂度为 O(m+n)，空间复杂度为 O(m)，其中 m 和 n 分别为字符串 ransomNote 和 magazine 的长度。","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://blog.eganx.cn/categories/Leetcode/"}],"tags":[{"name":"Go","slug":"Go","permalink":"https://blog.eganx.cn/tags/Go/"},{"name":"Leetcode","slug":"Leetcode","permalink":"https://blog.eganx.cn/tags/Leetcode/"},{"name":"hashmap","slug":"hashmap","permalink":"https://blog.eganx.cn/tags/hashmap/"}]},{"title":"349. 两个数组的交集","slug":"349. intersection_of_two_arrays","date":"2023-02-04T14:22:11.000Z","updated":"2023-03-07T07:44:29.957Z","comments":true,"path":"2023/02/04/349. intersection_of_two_arrays/","link":"","permalink":"https://blog.eganx.cn/2023/02/04/349.%20intersection_of_two_arrays/","excerpt":"0x0. 题目描述给定两个数组 nums1 和 nums2 ，返回 它们的交集 。输出结果中的每个元素一定是 唯一 的。我们可以 不考虑输出结果的顺序 。","text":"0x0. 题目描述给定两个数组 nums1 和 nums2 ，返回 它们的交集 。输出结果中的每个元素一定是 唯一 的。我们可以 不考虑输出结果的顺序 。 链接： https://leetcode.cn/problems/intersection-of-two-arrays 0x1. 示例示例 1： 输入：nums1 &#x3D; [1,2,2,1], nums2 &#x3D; [2,2]输出：[2] 示例 2： 输入：nums1 &#x3D; [4,9,5], nums2 &#x3D; [9,4,9,8,4]输出：[9,4]解释：[4,9] 也是可通过的 0x2. 提示 1 &lt;= nums1.length, nums2.length &lt;= 1000 0 &lt;= nums1[i], nums2[i] &lt;= 1000 0x3. 解题思路 创建一个空的切片 res 和一个空的哈希表 set。 遍历数组 nums1 中的每个元素 v，如果 v 在哈希表 set 中不存在，则将其加入哈希表中。 遍历数组 nums2 中的每个元素 v，如果 v 在哈希表 set 中存在，则将其加入切片 res 中，并从哈希表 set 中删除。 返回切片 res。 0x4. Go 语言实现的代码示例：func intersection(nums1 []int, nums2 []int) []int &#123; res := make([]int,0) set := make(map[int]interface&#123;&#125;,0) for _, v := range nums1 &#123; if _, ok := set[v]; !ok&#123; set[v] = v //赋值随意，只要后面能取到东西就行 &#125; &#125; for _, v := range nums2 &#123; if _, ok := set[v]; ok&#123; res = append(res, v) delete(set,v) &#125; &#125; return res&#125; 使用哈希表来记录一个数组中的元素，然后遍历另一个数组，找到其中在哈希表中出现过的元素。实现用一个接口类型来占据值的位置，只关注 key 的存在，而不关心具体的 value 值。 时间复杂度为 O(m+n)，空间复杂度为 O(min(m,n))，其中 m 和 n 分别为两个数组的长度。但需要注意的是，由于哈希表的散列函数可能会产生冲突，因此在极端情况下，时间复杂度可能会退化为 O(m * n)。","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://blog.eganx.cn/categories/Leetcode/"}],"tags":[{"name":"Go","slug":"Go","permalink":"https://blog.eganx.cn/tags/Go/"},{"name":"Leetcode","slug":"Leetcode","permalink":"https://blog.eganx.cn/tags/Leetcode/"},{"name":"hashmap","slug":"hashmap","permalink":"https://blog.eganx.cn/tags/hashmap/"}]},{"title":"数据库基础--锁和隔离级别","slug":"DB_base_ lock_and_isolation","date":"2022-11-20T07:54:23.000Z","updated":"2022-12-31T02:55:40.471Z","comments":true,"path":"2022/11/20/DB_base_ lock_and_isolation/","link":"","permalink":"https://blog.eganx.cn/2022/11/20/DB_base_%20lock_and_isolation/","excerpt":"锁的类型和数据库事务隔离级别。","text":"锁的类型和数据库事务隔离级别。 0x0.锁粒度MySQL提供了行级锁和表级锁。 应该尽量只锁定需要修改的那部分数据，而不是所有的资源。锁定的数据量越少，发生锁争用的可能性就越小，系统的并发程度就越高。 但是加锁需要消耗资源，各种锁操作都会增加系统开销。因此锁的粒度越小，系统开销就越大。在选择锁粒度的时候，需要平衡锁开销和系统并发程度。 0x1.锁类型1).读写锁 互斥锁(Exclusive)，简写X锁，又称写锁。 共享锁(Shared)，简写S锁，又称读锁。 一个事务对数据对象A加了X锁，就可以对A进行读取和更新。加锁期间其他事务不能对A加任何锁。 一个事务对数据对象A加了S锁，可以对A进行读取操作，不能进行更新操作。加锁期间其他事务能对A加S锁，但是不能加X锁。 锁的兼容关系： X S X ❌ ❌ S ❌ ✔️ 2).意向锁使用意向锁可以更容易地支持多粒度封锁。 在存在行级锁和表级锁的情况下，事务T想要对表A加X锁，就需要先检测是否有其他事务对表A或者表A中的任意一行加了锁，需要对表A的每一行都检测一次，非常耗时。 意向锁就是在原来的X/S锁之上引入了IX/IS锁，IX/IS锁都是表锁，用来表示一个事务想要在表中的某个数据行上加X锁或S锁。 一个事务在获得某个数据行对象的S锁之前，必须先获得表的IS锁或者更强的锁。 一个事务在获得某个数据行对象的X锁之前，必须先获得表的IX锁。 通过引入意向锁，事务T想要对表A加X锁，只需要先检测是否有其他事务对表A加了X/IX/S/IS锁，如果加了就表示有其他事务正在使用这个表或者表中某一行的锁，因此事务T加X锁失败。 各种锁的兼容关系： X IX S IS X ❌ ❌ ❌ ❌ IX ❌ ✔️ ❌ ✔️ S ❌ ❌ ✔️ ✔️ IS ❌ ✔️ ✔️ ✔️ 任意IS/IX锁之间都是兼容的，因为它们只表示想要对表加锁，而不是真正加锁。 兼容关系针对表级锁，而表级的IX锁和行级的X锁兼容，两个事务可以对两个数据行加X锁。（事务 T1 想要对数据行 R1 加 X 锁，事务 T2 想要对同一个表的数据行 R2 加 X 锁，两个事务都需要对该表加 IX 锁，但是 IX 锁是兼容的，并且 IX 锁与行级的 X 锁也是兼容的，因此两个事务都能加锁成功，对同一个表中的两个数据行做修改。） 0x2.锁协议1).三级封锁协议 一级封锁协议 事务T要修改数据A时必须加X锁，直到T结束才释放锁。 可以解决丢失修改的问题，不能同时有两个事务对同一个数据进行修改，那么事务的修改就不会被覆盖。 二级封锁协议 在一级的基础上，要求读取数据A时必须加S锁，读取完马上释放S锁。 可以解决读脏数据问题，因为如果一个事务在对数据A进行修改，根据1级封锁协议，会加X锁，那么就不能再加S锁了，也就是不会读入脏数据。 三级封锁协议 在二级的基础上，要求读取数据A时必须加S锁，直到事务结束了才能释放S锁。 可以解决不可重复读的问题，因为读取A时，其他事务不能对A加X锁，从而避免了在读的期间数据发生改变。 2).两段锁协议加锁和解锁分成两个阶段进行。 可串行化调度是指通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。串行执行的事务互不干扰，不会出现并发一致性问题。 事务遵循两段锁协议是保证可串行化调度的充分条件。例如以下操作满足两段锁协议，它是可串行化调度。 lock-x(A)...lock-s(B)...lock-s(C)...unlock(A)...unlock(C)...unlock(B) 但不是必要条件，例如以下操作不满足两段锁协议，但它还是可串行化调度。 lock-x(A)...unlock(A)...lock-s(B)...unlock(B)...lock-s(C)...unlock(C) MySQL的InnoDB存储引擎采用两段锁协议，会根据隔离级别在需要的时候自动加锁，并且所有的锁都是在同一时刻被释放，这也被称为隐式锁定。 InnoDB也可使用语句进行显式加锁 SELECT ... LOCK In SHARE MODE;SELECT ... FOR UPDATE; 0x3.隔离级别1).未提交读(READ UNCOMMITTED)事务中的修改，即使没有提交，对其他事务也是可见的。 2).提交读(READ COMMITTED)一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其他事务是不可见的。 3).可重复读(REPEATABLE READ)保证在同一个事务中多次读取同一数据的结果是一样的。 4).序列化（SERIALIZABLE）强制事务串行执行，这样多个事务互不干扰，不会出现并发一致性问题。 该隔离级别需要加锁实现，使用加锁机制保证同一时间只有一个事务执行，也就是保证事务串行执行。 隔离能解决的并发一致性问题如下所示： 脏读 不可重复读 幻读 未提交读 ❌ ❌ ❌ 提交读 ✔️ ❌ ❌ 可重复读 ✔️ ✔️ ❌ 序列化 ✔️ ✔️ ✔️","categories":[{"name":"Database","slug":"Database","permalink":"https://blog.eganx.cn/categories/Database/"}],"tags":[{"name":"DB","slug":"DB","permalink":"https://blog.eganx.cn/tags/DB/"},{"name":"lock","slug":"lock","permalink":"https://blog.eganx.cn/tags/lock/"}]},{"title":"数据库基础--并发一致性问题","slug":"DB_base_Concurrency_consistency","date":"2022-11-19T14:12:54.000Z","updated":"2022-12-31T02:54:27.732Z","comments":true,"path":"2022/11/19/DB_base_Concurrency_consistency/","link":"","permalink":"https://blog.eganx.cn/2022/11/19/DB_base_Concurrency_consistency/","excerpt":"在并发环境下，事务的隔离性很难保证，因此会出现很多并发一致性问题。产生并发不一致性问题的主要原因是破坏了事务的隔离性，解决方法是通过并发控制来保证隔离性。","text":"在并发环境下，事务的隔离性很难保证，因此会出现很多并发一致性问题。产生并发不一致性问题的主要原因是破坏了事务的隔离性，解决方法是通过并发控制来保证隔离性。 0x0.丢失修改┌──────────┐ ┌──────────┐│ T1 Start │ │ T2 Start │└─────┬────┘ └─────┬────┘ │ │ ▼ │┌──────────┐ ││Write A&#x3D;10│ │└─────┬────┘ │ │ ▼ │ ┌──────────┐ │ │Write A&#x3D;20│ │ └─────┬────┘ │ │ ▼ ▼┌──────────┐ ┌──────────┐│ T1 End │ │ T2 End │└──────────┘ └──────────┘ A&#x3D;20 A&#x3D;20 丢失修改指一个事务的更新操作被另外一个事务的更新操作替换。一般在现实生活中常会遇到，例如：T1 和 T2 两个事务都对一个数据进行修改，T1 先修改并提交生效，T2 随后修改，T2 的修改覆盖了 T1 的修改。最终A=20，T1的修改丢失。 0x1.读脏数据┌──────────┐ ┌──────────┐│ T1 Start │ │ T2 Start │└─────┬────┘ └─────┬────┘ │ │ ▼ │┌──────────┐ ││ Read A&#x3D;10│ │└─────┬────┘ │ │ │ ▼ │┌──────────┐ ││Write A&#x3D;20│ │└─────┬────┘ ▼ │ ┌──────────┐ │ │ Read A&#x3D;20│ ▼ └─────┬────┘┌──────────┐ ││ Rollback │ │└─────┬────┘ │ │ │ ▼ ▼┌──────────┐ ┌──────────┐│ T1 End │ │ T2 End │└──────────┘ └──────────┘ A&#x3D;10 A&#x3D;20 读脏数据指在不同的事务下，当前事务可以读到另外事务未提交的数据。例如：T1 修改一个数据但未提交，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是脏数据。 0x2.不可重复读┌──────────┐ ┌──────────┐│ T1 Start │ │ T2 Start │└─────┬────┘ └─────┬────┘ │ │ │ ▼ │ ┌──────────┐ │ │ Read A&#x3D;10│ │ └─────┬────┘ ▼ │┌──────────┐ ││Write A&#x3D;20│ │└─────┬────┘ │ │ │ │ ▼ │ ┌──────────┐ │ │ Read A&#x3D;20│ │ └─────┬────┘ │ │ │ │ │ │ ▼ ▼┌──────────┐ ┌──────────┐│ T1 End │ │ T2 End │└──────────┘ └──────────┘ A&#x3D;20 A&#x3D;20 不可重复读指在一个事务内多次读取同一数据集合。在这一事务还未结束前，另一事务也访问了该同一数据集合并做了修改，由于第二个事务的修改，第一次事务的两次读取的数据可能不一致。例如：T2 读取一个数据，T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同。 0x3.幻影读幻读本质上也属于不可重复读的情况，T1 读取某个范围的数据，T2 在这个范围内插入新的数据，T1 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。","categories":[{"name":"Database","slug":"Database","permalink":"https://blog.eganx.cn/categories/Database/"}],"tags":[{"name":"DB","slug":"DB","permalink":"https://blog.eganx.cn/tags/DB/"},{"name":"concurrency consistency","slug":"concurrency-consistency","permalink":"https://blog.eganx.cn/tags/concurrency-consistency/"}]},{"title":"数据库基础--事务","slug":"DB_base_ transaction","date":"2022-11-19T04:45:22.000Z","updated":"2022-12-31T02:54:23.744Z","comments":true,"path":"2022/11/19/DB_base_ transaction/","link":"","permalink":"https://blog.eganx.cn/2022/11/19/DB_base_%20transaction/","excerpt":"数据库事务（简称：事务）是数据库管理系统执行过程中的一个逻辑单位，由一个有限的数据库操作序列构成。","text":"数据库事务（简称：事务）是数据库管理系统执行过程中的一个逻辑单位，由一个有限的数据库操作序列构成。 0x0.事务事务是指满足ACID特性的一组操作，可以通过Commit提交一个事务，也可以使用Rollback进行回滚。 ┌──────────────────────┐ ┌──────────┐ │ │ │ │ │ insert，update，delete│ │ commit │ │ │ │ │ └─┬──────────────────┬─┘ └─────┬────┘ │ │ │ │ │ │ │ │ │ │┌────────┐ ┌────────┐ │ ┌────────┐ │ ┌────────┐│ │ │ │┼┼┼┼┼┼┼┼│ │ │┼┼┼┼┼┼┼┼│ │ │ ││ ├─────┴───►├┼┼┼┼┼┼┼┼┼────┴─────►├┼┼┼┼┼┼┼┼┼──────┴────►│ ││ │ │┼┼┼┼┼┼┼┼│ │┼┼┼┼┼┼┼┼│ │ │└────────┘ └────┼───┘ └────┼───┘ └────┬───┘ ▲ ▲ ▲ │ │ │ │ │ │ │ │ │ │ │ └─────────────────┘ │ │ │ │ │ │ │ └─────────────────────────────────────────┘ │ │ │ └──────────────────────────────┬───────────────────────────────────┘ │ │ ┌──────────┴────────────┐ │ │ │ Rollback or Error │ │ │ └───────────────────────┘*注：空白方块表示一致性状态，阴影方块表示中间状态。 0x1.ACID1).原子性(Atomicity)事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。 回滚可以用回滚日志（Undo Log）来实现，回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。 2).一致性(Consistency)数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对同一个数据的读取结果都是相同的。 3).隔离性(Isolation)一个事务所做的修改子最终提交以前，对其他事务是不可见的。 4).持久性(Durability)一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统崩溃，事务执行的结果也不能丢失。 系统发生崩溃可以用重做日志（Redo Log）进行恢复，从而实现持久性。与回滚日志记录数据的逻辑修改不同，重做日志记录的是数据页的物理修改。 事务的 ACID 特性概念简单，但不是很好理解，主要是因为这几个特性不是一种平级关系： 只有满足一致性，事务的执行结果才是正确的。 在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定能满足一致性。 在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性。 事务满足持久化是为了能应对系统崩溃的情况。 ┌───────────┐ Concurrency&#x2F;Non concurrent│ Atomicity ├───────┐└───────────┘ │ ┌───────────┐ ├──►│Consistency├───────► Correct execution┌───────────┐ │ └───────────┘│ Isolation ├───────┘└───────────┘ Concurrency ┌───────────┐ │ Durability├───────► Dealing with system crashes └───────────┘ AutoCommitMySQL 默认采用自动提交模式。也就是说，如果不显式使用START TRANSACTION语句来开始一个事务，那么每个查询操作都会被当做一个事务并自动提交。","categories":[{"name":"Database","slug":"Database","permalink":"https://blog.eganx.cn/categories/Database/"}],"tags":[{"name":"DB","slug":"DB","permalink":"https://blog.eganx.cn/tags/DB/"},{"name":"transaction","slug":"transaction","permalink":"https://blog.eganx.cn/tags/transaction/"}]},{"title":"Golang GC(Garbage Collection)","slug":"Go_GC","date":"2022-11-16T14:12:29.000Z","updated":"2022-12-28T02:45:00.841Z","comments":true,"path":"2022/11/16/Go_GC/","link":"","permalink":"https://blog.eganx.cn/2022/11/16/Go_GC/","excerpt":"内存管理是程序员开发应用的一大难题。传统的系统级编程语言（主要指C/C++）中，程序开发者必须对内存小心的进行管理操作，控制内存的申请及释放。 因为稍有不慎，就可能产生内存泄露问题，这种问题不易发现并且难以定位，一直成为困扰程序开发者的噩梦。","text":"内存管理是程序员开发应用的一大难题。传统的系统级编程语言（主要指C/C++）中，程序开发者必须对内存小心的进行管理操作，控制内存的申请及释放。 因为稍有不慎，就可能产生内存泄露问题，这种问题不易发现并且难以定位，一直成为困扰程序开发者的噩梦。 0x0.Garbage CollectionGC(Garbage Collection)，垃圾回收是一种自动内存管理机制。当某个程序占用的一部分内存空间不再被这个程序访问时，这个程序会借助垃圾回收算法向操作系统归还这部分内存空间。垃圾回收器可以减轻程序员的负担，也减少程序中的错误。垃圾回收最早起源于LISP语言。 垃圾回收器的执行过程通常被划分成两个独立的组件： 赋值器：指代用户态的代码。对于垃圾回收器来说，用户态的代码只是在修改对象之间的引用关系。 回收器：负责执行垃圾回收的代码。 0x1.根对象根集合是垃圾回收器在标记过程中最先检查的对象，包括： 全局变量 执行栈：每个goroutine都包含自己的执行栈，包含栈上的变量以及指向分配的堆内存区块的指针。 寄存器 0x2.GC实现方式GC的常见实现方式有追踪式GC和引用计数式GC。 追踪式GC 从根对象出发，根据对象之间的引用信息，逐步扫描直至扫完整个堆并确定保留的对象，从而回收所有可回收的对象。 引用计数式GC 每个对象自身包含一个被引用的计数器，当计数器归零时自动得到回收。 Go 的 GC 目前使用的是无分代（对象没有代际之分）、非移动（回收过程中不对对象进行移动与整理）、并发（与用户代码并发执行）的三色标记清扫算法。属于追踪式GC的一种。 0x3.三色标记法golang的垃圾回收是基于标记清扫算法，这种算法需要进行STW(stop the world)，这个过程会导致程序卡顿，所以频繁的GC是会严重影响程序性能的。golang在此基础上进行了改进，通过三色标记清扫算法和写屏障来减少STW的时间。 GC的四个过程 1、栈扫描（开始时STW），所有对象开始都是白色。 2、从root开始找到所有可达对象（所有可以找到的对象），标记成灰色，放入待处理队列。 3、遍历灰色对象队列，将其引用对象标记成灰色放入待处理队列，自身标记为黑色。 4、清除（并发）循环步骤3直到灰色队列为空。此时所有的引用对象都被标记为黑色，所有不可达的对象依然是白色，白色的就是需要进行回收的对象。 三色标记法相对于普通的标记清扫，减少了STW的时间，这主要得益于标记过程是”on-the-fly”的，标记过程中是不需要STW的，它与程序是并发执行的，大大缩短了STW的时间。Golang gc优化的核心就是尽量使得STW的时间越来越短。 阶段 说明 赋值器状态 SweepTermination 清扫终止阶段，为下一个阶段的并发标记做准备工作，启动写屏障 STW Mark 扫描标记阶段，与赋值器并发执行，写屏障开启 并发 MarkTermination 标记终止阶段，保证一个周期内标记任务完成，停止写屏障 STW GCoff 内存清扫阶段，将需要回收的内存归还到堆中，写屏障关闭 并发 GCoff 内存归还阶段，将过多的内存归还给操作系统，写屏障关闭 并发 写屏障当标记的程序是并发执行的，有可能在标记过程中，有新的引用产生，可能会导致误清扫。 清扫开始前，标记为黑色的对象引用一个新申请的对象，此时它肯定是白色的，而黑色对象不会被再次扫描，那么这个白色对象无法被扫描变成灰色、黑色，它最终会被清扫，而实际上它不应该被清扫。 golang采取了写屏障，其作用就是为了避免这类误清扫问题。写屏障在内存写操作前，维护一个约束，从而确保清扫开始前，黑色的对象不能引用白色对象。 0x4.触发GC的时机Go 语言中对 GC 的触发时机存在两种形式： 主动触发，通过调用 runtime.GC 来触发 GC，此调用阻塞式地等待当前 GC 运行完毕。 被动触发，分为两种方式： 使用系统监控，当超过两分钟没有产生任何 GC 时，强制触发 GC。 使用步调（Pacing）算法，其核心思想是控制内存增长的比例，当前内存分配达到一定比例则触发。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://blog.eganx.cn/categories/Golang/"}],"tags":[{"name":"GC","slug":"GC","permalink":"https://blog.eganx.cn/tags/GC/"},{"name":"go","slug":"go","permalink":"https://blog.eganx.cn/tags/go/"}]},{"title":"Go反射(reflect)","slug":"Go_reflect","date":"2022-11-13T11:21:43.000Z","updated":"2022-12-27T09:04:09.169Z","comments":true,"path":"2022/11/13/Go_reflect/","link":"","permalink":"https://blog.eganx.cn/2022/11/13/Go_reflect/","excerpt":"不同语言的反射模型不尽相同。闲来无事，看看Go的反射机制。","text":"不同语言的反射模型不尽相同。闲来无事，看看Go的反射机制。 0x0.反射的定义维基百科上反射的定义： 在计算机科学中，反射是指电脑程序在运行时（runtime）可以访问、检测和修改它本身状态或行为的一种能力。用比喻来说，反射就是程序在运行的时候能够“观察”并且修改自己的行为。 Go 语言提供了一种机制在运行时更新变量和检查它们的值、调用它们的方法，但是在编译时并不知道这些变量的具体类型，这称为反射机制。 0x1.反射的实现反射通过接口的类型信息实现。反射是建立在类型的基础上。 Go在reflect包中定义了各种类型，实现了反射的各种函数，通过它们可以在运行时检测类型的信息和改变类型的值。 1).反射的基本函数reflect 包里定义了一个接口和一个结构体，即 reflect.Type 和 reflect.Value，它们提供很多函数来获取存储在接口里的类型信息。 reflect.Type 主要提供关于类型相关的信息，所以它和 _type 关联比较紧密；reflect.Value 则结合 _type 和 data 两者，因此我们可以获取甚至改变类型的值。 reflect 包中提供了两个基础的关于反射的函数来获取上述的接口和结构体： func TypeOf(i interface&#123;&#125;) Type func ValueOf(i interface&#123;&#125;) Value TypeOf 函数用来提取一个接口中值的类型信息。由于它的输入参数是一个空的 interface&#123;&#125;，调用此函数时，实参会先被转化为 interface&#123;&#125;类型。这样，实参的类型信息、方法集、值信息都存储到 interface&#123;&#125; 变量里了。 fmt.Printf() 函数，如果使用 %T 来作为格式参数，输出的是 reflect.TypeOf 的结果，也就是动态类型。 TypeOf() 函数返回一个接口，这个接口定义了一系列方法，利用这些方法可以获取关于类型的所有信息； ValueOf() 函数返回一个结构体变量，包含类型信息以及实际值。 2).反射的三大定律 Reflection goes from interface value to reflection object. Reflection goes from reflection object to interface value. To modify a reflection object, the value must be settable. 接口型变量 和 反射类型对象 可以相互转化。如果想要操作原变量，反射变量 Value 必须要 hold 住原变量的地址才行。 0x2.反射的使用场景使用反射的常见场景有以下两种： 不能明确接口调用哪个函数，需要根据传入的参数在运行时决定。 不能明确传入函数的参数类型，需要在运行时处理任意对象。 反射对性能影响还是比较大的，比正常代码运行速度慢一到两个数量级。关键代码避免使用反射特性。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://blog.eganx.cn/categories/Golang/"}],"tags":[{"name":"go","slug":"go","permalink":"https://blog.eganx.cn/tags/go/"},{"name":"reflect","slug":"reflect","permalink":"https://blog.eganx.cn/tags/reflect/"}]},{"title":"Mongo cluster(docker compose)","slug":"DB_Mongo_0","date":"2022-11-10T13:12:34.000Z","updated":"2022-12-31T02:39:20.851Z","comments":true,"path":"2022/11/10/DB_Mongo_0/","link":"","permalink":"https://blog.eganx.cn/2022/11/10/DB_Mongo_0/","excerpt":"初次使用docker compose搭建mongo集群，记录一下。虽然问题还很多，但至少跑起来了。。。","text":"初次使用docker compose搭建mongo集群，记录一下。虽然问题还很多，但至少跑起来了。。。 0x0.文件目录结构mongodb└── mongo ├── data │ ├── hosts │ └── mongod.conf └── docker-compose.yml 0x1.mongod.confsystemLog: destination: file path: &#x2F;data&#x2F;log&#x2F;mongo.log logAppend: truestorage: dbPath: &#x2F;data&#x2F;dbnet: bindIp: 0.0.0.0replication: replSetName: rs0 0x2.hosts127.0.0.1 localhost255.255.255.255 broadcasthost::1 localhost 0x3.docker-compose.ymlversion: &#x27;3&#x27;networks: db:services: mongo1: image: mongo container_name: mongo1 restart: always command: mongod --config /etc/mongod.conf expose: - 27017 volumes: - ./data/mongo1/db:/data/db - ./data/mongo1/configdb:/data/configdb - ./data/mongo1/log:/data/log - ./data/mongod.conf:/etc/mongod.conf - ./data/hosts:/etc/hosts ports: - &quot;27017:27017&quot; networks: - db mongo2: image: mongo container_name: mongo2 restart: always command: mongod --config /etc/mongod.conf expose: - 27017 volumes: - ./data/mongo2/db:/data/db - ./data/mongo2/configdb:/data/configdb - ./data/mongo2/log:/data/log - ./data/mongod.conf:/etc/mongod.conf - ./data/hosts:/etc/hosts ports: - &quot;27018:27017&quot; networks: - db mongo3: image: mongo container_name: mongo3 restart: always command: mongod --config /etc/mongod.conf expose: - 27017 volumes: - ./data/mongo3/db:/data/db - ./data/mongo3/configdb:/data/configdb - ./data/mongo3/log:/data/log - ./data/mongod.conf:/etc/mongod.conf - ./data/hosts:/etc/hosts ports: - &quot;27019:27017&quot; networks: - db 0x4.开始部署 进入docker-compose.yml文件所在目录 执行命令：docker compose -f docker-compose.yml up -d 0x5.建立副本集 进入mongo容器：docker exec -it mongo1 bash 进入mongo：mongosh ,老版本的mongo到指令是mongo 切换管理员用户：use admin 初始化副本集：rs.initiate(),无参初始化时，会默认当前节点PRIMARY节点 添加副节点：rs.add(&#39;mongo2:27017&#39;) 添加仲裁节点：rs.addArb(&#39;mongo3:27017&#39;) &#x2F;&#x2F; 添加仲裁节点要是报错，可以试试运行以下代码 db.adminCommand(&#123; &quot;setDefaultRWConcern&quot; : 1, &quot;defaultWriteConcern&quot; : &#123; &quot;w&quot; : 2 &#125;&#125;) 查看副本集配置信息：rs.conf() 查看副本集运行状态：rs.status() 要是需要修改配置，可以按照以下步骤来： cfg = rs.conf() cfg.members[0].xxx = xxx rs.reconfig(cfg) 0x6.验证副本集切换节点查看同步状态：rs.printReplicationInfo() 仅当建立了集合后副节点才会进行同步。 0x7.外部连接准备使用Robo 3T(现在变成Studio 3T Free)连接数据库时，会有连接失败的异常，可以将WSL的IP地址写入电脑C盘hosts文件里： 172.23.224.1 mongo1172.23.224.1 mongo2172.23.224.1 mongo3 然后使用以下链接来连接数据库 mongo1:27017mongo2:27017mongo3:27017 但是如果还是连接不上，或者重启后连接不上，可以将mongo容器的IP写到mongo\\data\\hosts文件里，容器的IP可以使用docker inspect mongo1来获取。 172.30.0.2 mongo1172.30.0.3 mongo2172.30.0.4 mongo3","categories":[{"name":"Database","slug":"Database","permalink":"https://blog.eganx.cn/categories/Database/"}],"tags":[{"name":"DB","slug":"DB","permalink":"https://blog.eganx.cn/tags/DB/"},{"name":"mongo","slug":"mongo","permalink":"https://blog.eganx.cn/tags/mongo/"}]},{"title":"Go语言中new和make的区别","slug":"Go_New_and_Make","date":"2022-11-07T01:07:12.000Z","updated":"2022-12-27T09:04:20.424Z","comments":true,"path":"2022/11/07/Go_New_and_Make/","link":"","permalink":"https://blog.eganx.cn/2022/11/07/Go_New_and_Make/","excerpt":"在Go语言中，make关键字在初始化的时候被频繁使用，之前写C# 的时候都是使用new关键字，Go中new关键字也是存在的。准备看看两者的区别。","text":"在Go语言中，make关键字在初始化的时候被频繁使用，之前写C# 的时候都是使用new关键字，Go中new关键字也是存在的。准备看看两者的区别。 0x0.newnew可以对类型进行内存创建和初始化，其返回值是所创建类型的指针引用。new会根据变量类型返回一个指向该类型的指针。 0x1.makemake 函数也是用于内存分配的，但是和new不同，仅支持 slice、map、channel 三种数据类型的内存创建，其返回值是所创建类型的本身，而不是新的指针引用。make不仅可以开辟一个内存，还能给这个内存的类型初始化其零值。 0x2.总结 make和new都是golang用来分配内存的函数，且在堆上分配内存，make 即分配内存，也初始化内存。new只是将内存清零，并没有初始化内存。 make返回的还是引用类型本身；而new返回的是指向类型的指针。 make只能用来分配及初始化类型为slice，map，channel的数据；new可以分配任意类型的数据。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://blog.eganx.cn/categories/Golang/"}],"tags":[{"name":"make","slug":"make","permalink":"https://blog.eganx.cn/tags/make/"},{"name":"new","slug":"new","permalink":"https://blog.eganx.cn/tags/new/"}]},{"title":"Windows10下WSL2和Docker的安装和配置","slug":"Win10_WSL_Docker","date":"2022-11-06T04:12:32.000Z","updated":"2022-12-17T13:27:04.083Z","comments":true,"path":"2022/11/06/Win10_WSL_Docker/","link":"","permalink":"https://blog.eganx.cn/2022/11/06/Win10_WSL_Docker/","excerpt":"最近需要搭建mongo集群，看教程说使用docker比较好部署，准备在公司电脑（ThinkPad）上先试一下，所以需要安装一下WSL和docker。自己也没有在Windows环境下使用过docker，所以记录一下。","text":"最近需要搭建mongo集群，看教程说使用docker比较好部署，准备在公司电脑（ThinkPad）上先试一下，所以需要安装一下WSL和docker。自己也没有在Windows环境下使用过docker，所以记录一下。 0x0.Windows Terminal用过 Windows 默认终端的都知道，真的不怎么美观。 微软也逐渐意识到这个问题，并在 Build2019 大会上发布了 新一代 Windows 终端程序：Windows Terminal 。 Windows Terminal 是一款新式、快速、高效、强大且高效的终端应用程序，适用于命令行工具和命令提示符，PowerShell和 WSL 等 Shell 用户。主要功能包括多个选项卡、窗格、Unicode、和 UTF-8 字符支持，GPU 加速文本渲染引擎以及自定义主题、样式和配置。 而且这个是开源的，如果不喜欢在Microsoft Store里安装软件，可以直接去GitHub里下载，这里给出GitHub项目地址：https://github.com/microsoft/terminal。 0x1.Windows WSL21).概述WSL是windows推出的可让开发人员不需要安装虚拟机（vmware，virtbox）或者设置双系统启动就可以原生支持运行GNU/Linux的系统环境，简称WSL子系统。目前最新的版本是WSL2，在原先的基础上提高了文件系统的性能并添加了完全的的系统调用支持。WSL2使用全新体系架构使其能真正的运行一个Linux内核。 2).安装 WSL2对系统版本有一定的要求：必须运行 Windows 10 版本 2004 及更高版本（内部版本 19041 及更高版本）或 Windows 11。 在 控制面板-程序- 启用或关闭 Windows 功能 中勾选 适用于 Linux 的 Windows 子系统以及 虚拟机平台(wsl2 需要)。此步骤完成后需要重启电脑。 打开微软商店应用，在搜索框中输入“Linux”或者“ubuntu”然后搜索，你可以看到搜索结果中有很多的 Linux 发行版可以选择。我选Ubuntu22.04 有可能启动ubuntu报告WslRegisterDistribution failed with error: 0x800701bc是因为没有升级linux内核使用wsl --update下载更新即可。 在商店安装后并没有完全完成子系统安装，还需要运行一次Ubuntu来完成内核下载以及用户名密码的设置。 启动WSL2 Windows Terminal里面使用wsl -l命令来查看所有的子系统。使用wsl --set-default-version 2设置为每个安装的发行版默认WSL2启动。 3).导出Ubuntu-22.04到D盘下这一步可以缓解一下C盘的压力，C盘没有压力的就当没看见这一步。 查看已安装的Linux发行版: wsl -l --all -v 导出Linux发行版tar文件到指定文件夹: wsl --export Ubuntu-22.04 d:/wsl/ubuntu/wsl-ubuntu-22.04.tar 注销Ubuntu-22.04: wsl --unregister Ubuntu-22.04 重新导入并安装WSL2到D盘: wsl --import Ubuntu-22.04 d:/wsl/ubuntu/ d:/wsl/ubuntu/wsl-ubuntu-22.04.tar --version 2 0x2.Windows Docker Desktop这个没啥好说的，官网下载，直接安装就完了。官网地址传送：https://www.docker.com/products/docker-desktop/. 安装完成后，打开Docker Desktop的设置，找到Resources-WSL Integration，打开Enable integration with additional distors，将自己的WSL打开。这样docker就会跑在WSL上。","categories":[{"name":"Database","slug":"Database","permalink":"https://blog.eganx.cn/categories/Database/"}],"tags":[{"name":"mongo","slug":"mongo","permalink":"https://blog.eganx.cn/tags/mongo/"},{"name":"tool","slug":"tool","permalink":"https://blog.eganx.cn/tags/tool/"}]},{"title":"Studio 3T Free跳过一个月Full product的登陆试用(Windows)","slug":"Tool_Studio3t","date":"2022-11-05T14:32:12.000Z","updated":"2022-12-16T02:16:06.630Z","comments":true,"path":"2022/11/05/Tool_Studio3t/","link":"","permalink":"https://blog.eganx.cn/2022/11/05/Tool_Studio3t/","excerpt":"当Robo 3T变成了Studio 3T Free，不想试用Studio 3T的Full product。只想使用Robo 3T Free(Robo 3T)，该如何跳过一个月Full product的登陆试用呢？","text":"当Robo 3T变成了Studio 3T Free，不想试用Studio 3T的Full product。只想使用Robo 3T Free(Robo 3T)，该如何跳过一个月Full product的登陆试用呢？ 0x0.尊重付费软件Robo 3T作为常用的MongoDB GUI，现在变成了Studio 3T Free。依旧是免费，但是在Windows下初次打开Studio 3T软件时，会要求必须登陆，然后开始一个月的Full product trial。这个就很烦，我就只想用免费版的，毕竟免费版就可以满足我的需求。体验试用是好事，但是当这件事成为必选项时，就会让人很不爽😕 所以在不进行非正规手段进行软件破解时，该如何进行跳过登陆激活进行免费版的使用呢？ 找到位于C:\\Windows\\System32\\drivers\\ect下的hosts文件，将下面两行添加进去。 127.0.0.1 update.studio3t.com127.0.0.1 license-portal-eb.studio3t.com 然后重启Studio 3T时，Product activation弹窗就会跳过Login/Register这一步，直接到达Finish。Nice! 大功告成。","categories":[{"name":"Tool","slug":"Tool","permalink":"https://blog.eganx.cn/categories/Tool/"}],"tags":[{"name":"tool","slug":"tool","permalink":"https://blog.eganx.cn/tags/tool/"},{"name":"studio3t","slug":"studio3t","permalink":"https://blog.eganx.cn/tags/studio3t/"}]},{"title":"Go Context","slug":"Go_Context","date":"2022-11-04T03:45:19.000Z","updated":"2022-12-05T10:54:58.287Z","comments":true,"path":"2022/11/04/Go_Context/","link":"","permalink":"https://blog.eganx.cn/2022/11/04/Go_Context/","excerpt":"context是Go的一个标准库，中文一般叫做”上下文”。context主要是用来在goroutine之间传递上下午信息，包括取消信号、超时时间等。context.Context类型的值可以协调多个goroutine中的代码执行“取消”操作，并且可以存储键值对。而且还是并发安全的。与它协作可以在API的外部控制执行“取消”操作，比如取消一个HTTP请求的执行。","text":"context是Go的一个标准库，中文一般叫做”上下文”。context主要是用来在goroutine之间传递上下午信息，包括取消信号、超时时间等。context.Context类型的值可以协调多个goroutine中的代码执行“取消”操作，并且可以存储键值对。而且还是并发安全的。与它协作可以在API的外部控制执行“取消”操作，比如取消一个HTTP请求的执行。 0x0.context的作用在http server中，一个请求有可能会起若干个协程，这些goroutine有时候是需要共享请求的基本数据的，包括token，超时时间和取消信号等。当请求迟迟得不到回应或者此次请求被取消，可能是使用者关闭了浏览器或已经超过了请求方的超时时间，请求方直接放弃了这次请求的结果。这个时候，所有为这个请求工作的goroutine需要快速退出，因为工作成果变成了无意义的。在相关的goroutine退出后，系统可以回收相关资源。 正常关闭协程是采用channel+select方式来控制。但是当一个请求相关联的协程数量过多，且相互关联，能够同时关闭，可以使用context来实现。 context用来解决goroutine之间退出通知、元数据传递的功能。 context的使用建议： 不要将 Context 塞到结构体里。直接将 Context 类型作为函数的第一参数，而且一般都命名为 ctx。 不要向函数传入一个 nil 的 context，如果你实在不知道传什么，标准库给你准备好了一个 context：todo。 不要把本应该作为函数参数的类型塞到 context 中，context 存储的应该是一些共同的数据。例如：登陆的 session、cookie 等。 同一个 context 可能会被传递到多个 goroutine，别担心，context 是并发安全的。 1).传递共享的数据对于web服务端开发，往往希望将一个请求处理的整个过程串起来，因此需要在函数调用的时候传递context。 context的常见创建函数： // 创建空白的根节点contextfunc Background() Context // 创建子节点contextfunc WithCancel(parent Context) (ctx Context, cancel CancelFunc)func WithDeadline(parent Context, deadline time.Time) (Context, CancelFunc)func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc)func WithValue(parent Context, key, val interface&#123;&#125;) Context 2).取消goroutinefunc func_eg(ctx context.Context) &#123; for &#123; ... // 业务代码：1秒刷新1次 select &#123; case &lt;-ctx.Done(): // 被取消，直接返回 return case &lt;-time.After(time.Second): // block 1 秒钟 &#125; &#125;&#125;// mainctx, cancel := context.WithTimeout(context.Background(), time.Hour)go func_eg(ctx)// 客户端取消时，调用cancel函数cancel() cancel()函数返回的context和cancelFun是分开的。context本身是没有cancel函数，保证取消函数只能由外部调用，防止子节点context调用取消函数，从而严格控制信息流从父节点context流向子节点context。 3).防止goroutine泄露某些goroutine处于无限循环状态，若无外部取消函数，会造成系统资源泄露。 0x1.context详细解析 类型 名称 作用 Context 接口 定义了 Context 接口的四个方法 emptyCtx 结构体 实现了 Context 接口，它其实是个空的 context CancelFunc 函数 取消函数 canceler 接口 context 取消接口，定义了两个方法 cancelCtx 结构体 可以被取消 timerCtx 结构体 超时会被取消 valueCtx 结构体 可以存储 k-v 对 Background 函数 返回一个空的 context，常作为根 context TODO 函数 返回一个空的 context，常用于重构时期，没有合适的 context 可用 WithCancel 函数 基于父 context，生成一个可以取消的 context newCancelCtx 函数 创建一个可取消的 context propagateCancel 函数 向下传递 context 节点间的取消关系 parentCancelCtx 函数 找到第一个可取消的父节点 removeChild 函数 去掉父节点的孩子节点 init 函数 包初始化 WithDeadline 函数 创建一个有 deadline 的 context WithTimeout 函数 创建一个有 timeout 的 context WithValue 函数 创建一个存储 k-v 对的 context","categories":[{"name":"Golang","slug":"Golang","permalink":"https://blog.eganx.cn/categories/Golang/"}],"tags":[{"name":"go","slug":"go","permalink":"https://blog.eganx.cn/tags/go/"},{"name":"context","slug":"context","permalink":"https://blog.eganx.cn/tags/context/"}]},{"title":"Go Channel关闭方式","slug":"Go_Channel_Close","date":"2022-11-02T15:56:54.000Z","updated":"2022-11-24T07:06:51.771Z","comments":true,"path":"2022/11/02/Go_Channel_Close/","link":"","permalink":"https://blog.eganx.cn/2022/11/02/Go_Channel_Close/","excerpt":"channel的关闭是比较头疼的，搞不好就panic。直接panic-recover要被喷莽夫，不优雅。所以找了很多资料，总结一下channel的关闭过程，常见的关闭方式和优雅的关闭方式（没有人会比福杰一家还要优雅）","text":"channel的关闭是比较头疼的，搞不好就panic。直接panic-recover要被喷莽夫，不优雅。所以找了很多资料，总结一下channel的关闭过程，常见的关闭方式和优雅的关闭方式（没有人会比福杰一家还要优雅） 0x0.关闭chan过程关闭channel的执行函数是closechan，源码如下 // go version: go1.18.2func closechan(c *hchan) &#123; // 关闭一个nil channel，直接panic。 if c == nil &#123; panic(plainError(&quot;close of nil channel&quot;)) &#125; // 锁 lock(&amp;c.lock) // channel已经关闭 if c.closed != 0 &#123; // 解锁，然后panic unlock(&amp;c.lock) panic(plainError(&quot;close of closed channel&quot;)) &#125; if raceenabled &#123; callerpc := getcallerpc() racewritepc(c.raceaddr(), callerpc, abi.FuncPCABIInternal(closechan)) racerelease(c.raceaddr()) &#125; // 设置chan已关闭 c.closed = 1 var glist gList // 释放channel里所有等待接收队列里的sudog // release all readers for &#123; sg := c.recvq.dequeue() if sg == nil &#123; break &#125; // elem不为空，还想要接收数据，给个相对应类型的零值。 if sg.elem != nil &#123; typedmemclr(c.elemtype, sg.elem) sg.elem = nil &#125; if sg.releasetime != 0 &#123; sg.releasetime = cputicks() &#125; // 取出goroutine gp := sg.g gp.param = unsafe.Pointer(sg) sg.success = false if raceenabled &#123; raceacquireg(gp, c.raceaddr()) &#125; glist.push(gp) &#125; // 释放channel里所有等待发送队列里的sudog，同时这些goroutine将会panic。 // release all writers (they will panic) for &#123; sg := c.sendq.dequeue() if sg == nil &#123; break &#125; sg.elem = nil if sg.releasetime != 0 &#123; sg.releasetime = cputicks() &#125; gp := sg.g gp.param = unsafe.Pointer(sg) sg.success = false if raceenabled &#123; raceacquireg(gp, c.raceaddr()) &#125; glist.push(gp) &#125; unlock(&amp;c.lock) // Ready all Gs now that we&#x27;ve dropped the channel lock. // 遍历glist，唤醒goroutine for !glist.empty() &#123; gp := glist.pop() gp.schedlink = 0 goready(gp, 3) &#125;&#125; 将recvq和sendq两个队列中的Goroutine加入到gList中，并清除掉所有sudog上未被处理掉元素。最后将glist中所有的goroutine加到调度队列，等待被唤醒。 发送者在被唤醒之后会panic。 总结一下: 操作 closed channel 关闭(close) panic 发送(c&lt;-) panic 接收(&lt;-c) 永远不阻塞 0x1.关闭channel的常见方式channel的关闭与否都有可能造成panic。如何获取channel是否关闭和如何稳妥的关闭channel是非常重要的事情‼️ 在不改变channel自身状态的情况下，无法获知一个channel是否关闭。 关闭一个closed channel会导致panic。所以在关闭channel的时候，关闭的一方在不清楚当前channel是否关闭的情况下去关闭channel是很危险的⚠️。 向一个closed channel发送数据会导致panic。同上，在发送方不知道channel是否关闭的情况下向channel发送数据，也是很危险的⚠️ 关闭channel原则： 一般原则上使用channel是不允许接收方关闭channel和 不能关闭一个有多个并发发送者的channel。 换而言之， 你只能在发送方的 goroutine 中关闭只有该发送方的channel。 1).defer-recover粗暴关闭channel使用defer-recover机制来确保程序不会因panic而崩溃，然后直接关闭chan。 func SafeClose(ch chan T) (justClosed bool) &#123; defer func() &#123; if recover() != nil &#123; // 返回值可以被修改 // 在一个延时函数的调用中。 justClosed = false &#125; &#125;() // 假设这里 ch != nil 。 close(ch) // 如果 ch 已经被关闭将会引发 panic return true // &lt;=&gt; justClosed = true; return&#125; 同样的思想也可以用在发送方，确保向closed channel发送数据不会造成程序崩了。 func SafeSend(ch chan T, value T) (closed bool) &#123; defer func() &#123; if recover() != nil &#123; closed = true &#125; &#125;() ch &lt;- value // 如果 ch 已经被关闭将会引发 panic return false // &lt;=&gt; closed = false; return&#125; 上面的方法虽然处理了panic，但是并没有避免panic的发生。 2).使用sync.Once关闭channeltype MyChannel struct &#123; C chan T once sync.Once&#125;func NewMyChannel() *MyChannel &#123; return &amp;MyChannel&#123;C: make(chan T)&#125;&#125;func (mc *MyChannel) SafeClose() &#123; mc.once.Do(func() &#123; close(mc.C) &#125;)&#125; 3).使用sync.Mutex避免多次关闭同一个channeltype MyChannel struct &#123; C chan T closed bool mutex sync.Mutex&#125;func NewMyChannel() *MyChannel &#123; return &amp;MyChannel&#123;C: make(chan T)&#125;&#125;func (mc *MyChannel) SafeClose() &#123; mc.mutex.Lock() defer mc.mutex.Unlock() if !mc.closed &#123; close(mc.C) mc.closed = true &#125;&#125;func (mc *MyChannel) IsClosed() bool &#123; mc.mutex.Lock() defer mc.mutex.Unlock() return mc.closed&#125; 0x2.优雅的关闭channel上面的几种关闭channel的方式，用的人应该不少(说实话，我也很喜欢使用sync.Once的方式去关闭channel)。但是，有许多人认为代码在考虑业务实现的同时，应该优雅优雅再优雅！（舍监表示很开心！阿尼亚表示很难受！） 那么如何优雅的关闭channel？按照发送者和接收者的数量可以分为以下四种： 1. 一个 sender，一个 receiver2. 一个 sender， N个 receiver3. M个 sender， 一个 receiver4. M个 sender， N个 receiver 1).只有一个发送者，关闭唯一的发送者第一种和第二种情况比较好处理，因为只有一个发送者，只需要关闭唯一的发送者就可以。sync.WaitGroup 会被用于完成例子。 它在实践中并不是必要的。 package mainimport ( &quot;time&quot; &quot;math/rand&quot; &quot;sync&quot; &quot;log&quot;)func main() &#123; rand.Seed(time.Now().UnixNano()) log.SetFlags(0) const MaxRandomNumber = 100000 const NumReceivers = 100 wgReceivers := sync.WaitGroup&#123;&#125; wgReceivers.Add(NumReceivers) dataCh := make(chan int, 100) // 发送者 go func() &#123; for &#123; if value := rand.Intn(MaxRandomNumber); value == 0 &#123; // 唯一的发送者可以安全地关闭通道。 close(dataCh) return &#125; else &#123; dataCh &lt;- value &#125; &#125; &#125;() // 接收者 for i := 0; i &lt; NumReceivers; i++ &#123; go func() &#123; defer wgReceivers.Done() // 接收数据直到 dataCh 被关闭或者 // dataCh 的数据缓存队列是空的。 for value := range dataCh &#123; log.Println(value) &#125; &#125;() &#125; wgReceivers.Wait()&#125; 2).多个发送者，一个接收者。接收者通过关闭一个channel，告诉发送者不要再发了。 package mainimport ( &quot;time&quot; &quot;math/rand&quot; &quot;sync&quot; &quot;log&quot;)func main() &#123; rand.Seed(time.Now().UnixNano()) log.SetFlags(0) // ... const MaxRandomNumber = 100000 const NumSenders = 1000 wgReceivers := sync.WaitGroup&#123;&#125; wgReceivers.Add(1) // ... dataCh := make(chan int, 100) stopCh := make(chan struct&#123;&#125;) // stopCh 是一个信号通道。 // 它的发送者是 dataCh 的接收者。 // 它的接收者是 dataCh 的发送者。 // 发送者 for i := 0; i &lt; NumSenders; i++ &#123; go func() &#123; for &#123; select &#123; case &lt;- stopCh: return case dataCh &lt;- rand.Intn(MaxRandomNumber): &#125; &#125; &#125;() &#125; // 接收者 go func() &#123; defer wgReceivers.Done() for value := range dataCh &#123; if value == MaxRandomNumber-1 &#123; // dataCh 通道的接收者也是 stopCh 通道的发送者。 // 在这里关闭停止通道是安全的。. close(stopCh) return &#125; log.Println(value) &#125; &#125;() // ... wgReceivers.Wait()&#125; 3).多个发送者，多个接收者。当发送者和接收者都是多个的时候，没办法通过任何一方去终止这场游戏。因此需要增加一个中间人的角色来处理。 package mainimport ( &quot;time&quot; &quot;math/rand&quot; &quot;sync&quot; &quot;log&quot; &quot;strconv&quot;)func main() &#123; rand.Seed(time.Now().UnixNano()) log.SetFlags(0) // ... const MaxRandomNumber = 100000 const NumReceivers = 100 const NumSenders = 1000 wgReceivers := sync.WaitGroup&#123;&#125; wgReceivers.Add(NumReceivers) // ... dataCh := make(chan int, 100) stopCh := make(chan struct&#123;&#125;) // stopCh 是一个信号通道。 // 它的发送者是下面的主持人 goroutine。 // 它的接收者是 dataCh的所有发送者和接收者。 toStop := make(chan string, 1) // toStop 通道通常用来通知主持人去关闭信号通道( stopCh )。 // 它的发送者是 dataCh的任意发送者和接收者。 // 它的接收者是下面的主持人 goroutine var stoppedBy string // 主持人 go func() &#123; stoppedBy = &lt;-toStop close(stopCh) &#125;() // 发送者 for i := 0; i &lt; NumSenders; i++ &#123; go func(id string) &#123; for &#123; value := rand.Intn(MaxRandomNumber) if value == 0 &#123; // 用于通知主持人关闭信号通道。 select &#123; case toStop &lt;- &quot;sender#&quot; + id: default: &#125; return &#125; select &#123; case &lt;- stopCh: return case dataCh &lt;- value: &#125; &#125; &#125;(strconv.Itoa(i)) &#125; // 接收者 for i := 0; i &lt; NumReceivers; i++ &#123; go func(id string) &#123; defer wgReceivers.Done() for &#123; select &#123; case &lt;- stopCh: return case value := &lt;-dataCh: if value == MaxRandomNumber-1 &#123; // 同样用于通知主持人去关闭信号通道。 select &#123; case toStop &lt;- &quot;receiver#&quot; + id: default: &#125; return &#125; log.Println(value) &#125; &#125; &#125;(strconv.Itoa(i)) &#125; // ... wgReceivers.Wait() log.Println(&quot;stopped by&quot;, stoppedBy)&#125; 此时toStop通道的缓存大小是1。不使用非缓冲型channel是为了避免第一个关闭信号在主持人准备好从toStop接收数据之前发送，造成丢失。 也可以设置toStop通道的buf为发送者和接收者数量之和。toStop的容量足够的时候，就不用担心阻塞了。也就不需要借助select语句了。 ...toStop := make(chan string, NumReceivers + NumSenders)... value := rand.Intn(MaxRandomNumber) if value == 0 &#123; toStop &lt;- &quot;sender#&quot; + id return &#125;... if value == MaxRandomNumber-1 &#123; toStop &lt;- &quot;receiver#&quot; + id return &#125;... Q&amp;A: 关闭的channel还能读吗？ 可以。从一个带缓冲的chan里读取数据时，当channel被关闭，是可以读到有效值的。可以是comma-ok的方式读取chan数据，当ok值为false时，说明channel已经关闭且通道无数据，读出的数据开始无效。 func main() &#123; ch := make(chan int, 3) ch &lt;- 0 ch &lt;- 1 close(ch) x, ok := &lt;-ch if ok &#123; fmt.Println(&quot;received: &quot;, x) &#125; y, ok := &lt;-ch if ok &#123; fmt.Println(&quot;received: &quot;, y) &#125; z, ok := &lt;-ch if !ok &#123; fmt.Println(&quot;received false &quot;, z) &#125;&#125; 运行结果：received: 0received: 1received false: 0","categories":[{"name":"Golang","slug":"Golang","permalink":"https://blog.eganx.cn/categories/Golang/"}],"tags":[{"name":"go","slug":"go","permalink":"https://blog.eganx.cn/tags/go/"},{"name":"channel","slug":"channel","permalink":"https://blog.eganx.cn/tags/channel/"}]},{"title":"Go Channel数据结构和创建","slug":"Go_Channel_DS","date":"2022-11-01T13:09:13.000Z","updated":"2022-11-24T06:59:34.802Z","comments":true,"path":"2022/11/01/Go_Channel_DS/","link":"","permalink":"https://blog.eganx.cn/2022/11/01/Go_Channel_DS/","excerpt":"Go语言的并发是最好用的，而channel也算是Go语言并发机制的半壁江山了。","text":"Go语言的并发是最好用的，而channel也算是Go语言并发机制的半壁江山了。 0x0.CSPCSP全称“Communicating Sequential Processes”，中文可以叫做通信顺序进程。go的并发是基于channel实现，依赖的就是CSP模型。CSP描述了并发系统中的互动模式，实际上Go只是用到了CSP理论中一部分，即理论中的Process/Channel，在Go中对应goroutine/channel。这两个并发原语之间没有从属关系， Process 可以订阅任意个 Channel，Channel 也并不关心是哪个 Process 在利用它进行通信；Process 围绕 Channel 进行读写，形成一套有序阻塞和可预测的并发模型。 ┌─────────────┐ ┌─────────────┐ ┌─────────────┐│ │ │ │ │ ││ Goroutine ├────►│ Channel ├─────►│ Goroutine ││ │ │ │ │ │└─────────────┘ └─────────────┘ └─────────────┘ Goroutine + channel支撑起了Go语言的并发机制。 0x1.channel数据结构type hchan struct &#123; qcount uint // total data in the queue //循环队列元素个数 dataqsiz uint // size of the circular queue //循环队列大小 buf unsafe.Pointer // points to an array of dataqsiz elements //循环队列指针 elemsize uint16 //chan元素大小 closed uint32 //是否已经关闭 elemtype *_type // element type //chan元素类型 sendx uint // send index //chan发送操作处理到的位置 recvx uint // receive index //chan接收操作处理到的位置 recvq waitq // list of recv waiters //等待接收数据的goroutine列表 sendq waitq // list of send waiters //等待发送数据的goroutine列表 // lock protects all fields in hchan, as well as several // fields in sudogs blocked on this channel. // // Do not change another G&#x27;s status while holding this lock // (in particular, do not ready a G), as this can deadlock // with stack shrinking. lock mutex&#125; 其中buf字段只有在缓冲型的channel才有，指向底层的循环数组。 sendx和recvx分别表示已发送和已接收的元素在循环数组中的索引。 sendq和recvq分别表示等待接收和等待发送的goroutine队列。这些goroutine由于尝试读取channel或者向channel发送数据而被阻塞。 lock用来保护hchan中所有的字段。保证每个channel的读写都是原子的。 // sudog 双向列表，sudog实际上是对goroutine的一个封装。type waitq struct &#123; first *sudog last *sudog&#125; ┌─────┐ │hchan│ ├─────┴────────────┐5│ qcount uint │ ├──────────────────┤8│ dataqsiz uint │ 0 1 2 3 4 5 6 7 ├──────────────────┤ ┌───┬───┬───┬───┬───┬───┬───┬───┐ │buf unsafe.Pointer├──────────────►│ a │ b │ c │ d │ e │ │ │ │ ├──────────────────┤ └───┴───┴───┴───┴───┴───┴───┴───┘ │ elemsize uint16 │ ▲ ▲ ├──────────────────┤ │ │ │ closed uint32 │ │ │ ├──────────────────┤ │ │ │ elemtype *_type │ │ │ ├──────────────────┤ │ │0│ sendx uint ├─────────────────┘ │ ├──────────────────┤ │5│ recvx uint ├─────────────────────────────────────┘ ├──────────────────┤ │ recvq waitq ├─────────┬───────────────────────────────────────────┐ ├──────────────────┤ │ │ │ sendq waitq ├─────┐ │ ┌───────┐ ┌───────┐ ┌───────┐ │ ├──────────────────┤ │ └──►│ sudog │◄───►│ sudog │◄───►│ sudog │◄──┘ │ lock mutex │ │ └───────┘ └───────┘ └───────┘ └──────────────────┘ │ │ │ ┌───────┐ ┌───────┐ ┌───────┐ │ ┌──►│ sudog │◄───►│ sudog │◄───►│ sudog │◄──┐ │ │ └───────┘ └───────┘ └───────┘ │ │ │ │ └───┴───────────────────────────────────────────┘ 0x2.创建channel创建chan一般使用make关键字。其中chan的类型分为有无缓冲两种模式。 ch := make(chan int) //无缓冲ch := make(chan int, 2) //有缓冲 翻翻源码，有些看不太明白，只能是能看多少看多少了😭。在runtime/chan.go中都是使用makechan来创建chan。中文是个人注释，英文是官方注释。 const ( maxAlign = 8 hchanSize = unsafe.Sizeof(hchan&#123;&#125;) + uintptr(-int(unsafe.Sizeof(hchan&#123;&#125;))&amp;(maxAlign-1)) //hchan结构体大小 debugChan = false)func makechan64(t *chantype, size int64) *hchan &#123; if int64(int(size)) != size &#123; panic(plainError(&quot;makechan: size out of range&quot;)) &#125; return makechan(t, int(size))&#125;func makechan(t *chantype, size int) *hchan &#123; elem := t.elem // 检查channel size和align // compiler checks this but be safe. if elem.size &gt;= 1&lt;&lt;16 &#123; throw(&quot;makechan: invalid channel element type&quot;) &#125; if hchanSize%maxAlign != 0 || elem.align &gt; maxAlign &#123; throw(&quot;makechan: bad alignment&quot;) &#125; // 元素大小*个数，计算buf需要的内存大小 mem, overflow := math.MulUintptr(elem.size, uintptr(size)) if overflow || mem &gt; maxAlloc-hchanSize || size &lt; 0 &#123; panic(plainError(&quot;makechan: size out of range&quot;)) &#125; // Hchan does not contain pointers interesting for GC when elements stored in buf do not contain pointers. // buf points into the same allocation, elemtype is persistent. // SudoG&#x27;s are referenced from their owning thread so they can&#x27;t be collected. // TODO(dvyukov,rlh): Rethink when collector can move allocated objects. var c *hchan switch &#123; // 表示元素大小为零或者缓冲区大小为0（无缓冲类型），不需要创建buf。只进行一次内存分配。分配内存的大小就是hchan结构体大小。 case mem == 0: // Queue or element size is zero. c = (*hchan)(mallocgc(hchanSize, nil, true)) // Race detector uses this location for synchronization. c.buf = c.raceaddr() // 元素类型不含指针，进行一次内存分配，分配一块连续的内存，大小是“hchan结构体大小+个数*元素大小”。 // 同时元素大小不等于0且是缓冲区大小不为0 case elem.ptrdata == 0: // Elements do not contain pointers. // Allocate hchan and buf in one call. c = (*hchan)(mallocgc(hchanSize+mem, nil, true)) c.buf = add(unsafe.Pointer(c), hchanSize) // 元素包含指针，缓冲区大小不为0，进行两次内存分配，单独为hchan和buf分配内存。 default: // Elements contain pointers. c = new(hchan) c.buf = mallocgc(mem, elem, true) &#125; c.elemsize = uint16(elem.size) c.elemtype = elem c.dataqsiz = uint(size) lockInit(&amp;c.lock, lockRankHchan) if debugChan &#123; print(&quot;makechan: chan=&quot;, c, &quot;; elemsize=&quot;, elem.size, &quot;; dataqsiz=&quot;, size, &quot;\\n&quot;) &#125; return c&#125; 根据channel中收发的元素类型和缓冲区的大小，初始化hchan时有以下三种情况： 元素大小为零或者缓冲区大小为0（无缓冲类型），不需要创建buf。进行一次内存分配。分配内存的大小就是hchan结构体大小。 元素大小和缓冲区大小均不为0，且元素类型不含指针。进行一次内存分配，分配一块连续的内存，大小是“hchan结构体大小+个数*元素大小”。 元素包含指针，缓冲区大小不为0。进行两次内存分配，单独为hchan和buf分配内存。 0x3.channel的基本应用1).超时处理res := &lt;- c1 等待结果，&lt;-time.After 等待超时（1秒钟）以后发送的值。 由于 select 默认处理第一个已准备好的接收操作， 因此如果操作耗时超过了允许的 1 秒的话，将会执行超时 case。 package mainimport ( &quot;fmt&quot; &quot;time&quot;)func main() &#123; c1 := make(chan string, 1) go func() &#123; time.Sleep(2 * time.Second) c1 &lt;- &quot;result 1&quot; &#125;() select &#123; case res := &lt;-c1: fmt.Println(res) case &lt;-time.After(1 * time.Second): fmt.Println(&quot;timeout 1&quot;) &#125; c2 := make(chan string, 1) go func() &#123; time.Sleep(2 * time.Second) c2 &lt;- &quot;result 2&quot; &#125;() select &#123; case res := &lt;-c2: fmt.Println(res) case &lt;-time.After(3 * time.Second): fmt.Println(&quot;timeout 2&quot;) &#125;&#125; 运行结果： timeout 1result 2 2).控制并发构建一个缓冲型的 channel，容量为 3。接着遍历任务列表，每个任务启动一个 goroutine 去完成。真正执行任务，访问第三方的动作在 w() 中完成，在执行 w() 之前，先要从 limit 中拿“许可证”，拿到许可证之后，才能执行 w()，并且在执行完任务，要将“许可证”归还。这样就可以控制同时运行的 goroutine 数。如果 w() 发生 panic，那“许可证”可能就还不回去了，因此需要使用 defer 来保证。 var limit = make(chan int, 3)func main() &#123; // ...... for _, w := range work &#123; go func() &#123; limit &lt;- 1 w() &lt;-limit &#125;() &#125; // ......&#125; 3).生产者消费者模型并发编程中最常见的例子就是生产者消费者模式，该模式主要通过平衡生产线程和消费线程的工作能力来提高程序的整体处理数据的速度。简单地说，就是生产者生产一些数据，然后放到成果队列中，同时消费者从成果队列中来取这些数据。这样就让生产消费变成了异步的两个过程。当成果队列中没有数据时，消费者就进入饥饿的等待中；而当成果队列中数据已满时，生产者则面临因产品挤压导致 CPU 被剥夺的下岗问题。 // 生产者: 生成 factor 整数倍的序列func Producer(factor int, out chan&lt;- int) &#123; for i := 0; ; i++ &#123; out &lt;- i*factor &#125;&#125;// 消费者func Consumer(in &lt;-chan int) &#123; for v := range in &#123; fmt.Println(v) &#125;&#125;func main() &#123; ch := make(chan int, 64) // 成果队列 go Producer(3, ch) // 生成 3 的倍数的序列 go Producer(5, ch) // 生成 5 的倍数的序列 go Consumer(ch) // 消费生成的队列 // Ctrl+C 退出 sig := make(chan os.Signal, 1) signal.Notify(sig, syscall.SIGINT, syscall.SIGTERM) fmt.Printf(&quot;quit (%v)\\n&quot;, &lt;-sig)&#125;","categories":[{"name":"Golang","slug":"Golang","permalink":"https://blog.eganx.cn/categories/Golang/"}],"tags":[{"name":"go","slug":"go","permalink":"https://blog.eganx.cn/tags/go/"},{"name":"channel","slug":"channel","permalink":"https://blog.eganx.cn/tags/channel/"}]},{"title":"Go Interface理解(2)","slug":"Go_Interface_2","date":"2022-10-30T13:45:56.000Z","updated":"2022-11-22T06:15:48.152Z","comments":true,"path":"2022/10/30/Go_Interface_2/","link":"","permalink":"https://blog.eganx.cn/2022/10/30/Go_Interface_2/","excerpt":"接口有动态值和动态类型，只有当两者都是nil的时候，才有接口值==nil。这很重要‼️ 接口变量时常需要进行类型断言，找到真实类型。这也很重要‼️","text":"接口有动态值和动态类型，只有当两者都是nil的时候，才有接口值==nil。这很重要‼️ 接口变量时常需要进行类型断言，找到真实类型。这也很重要‼️ 0x0.空接口&amp;nil上来一个经典问题：一个包含nil指针的接口是不是nil接口？这个是真坑，在判空的时候，有可能就中招了。 空接口(interface&#123;&#125;)不包含任何的方法，但与此同时，所有的类型都实现了interface&#123;&#125;。在存储任意类型的时候，interface&#123;&#125;相当的有用。 nil 不是关键字，是一个预先声明的标识符，指针、通道、函数、接口、map、切片的零值就是nil，nil 是没有默认类型的，他的类型具有不确定性，我们在使用它时必须要提供足够的信息能够让编译器 推断nil期望的类型; 两个nil不能进行比较，因为nil是无类型的; 声明一个nil的map，map可以读数据，但是不能写数据 关闭一个nil的channel会引发panic nil切片不能进行索引访问，会引发panic 方法接收者为nil时，如果在方法内使用到了会引发panic 空指针一个没有任何值的指针 接口的底层结构体有iface、eface两种不同的表示。前者是有方法的接口，后者是无任何方法的空接口：interface&#123;&#125;。 //src/runtime/runtime2.gotype iface struct &#123; tab *itab data unsafe.Pointer&#125;type eface struct &#123; _type *_type data unsafe.Pointer&#125;type itab struct &#123; inter *interfacetype _type *_type hash uint32 // copy of _type.hash. Used for type switches. _ [4]byte fun [1]uintptr // variable sized. fun[0]==0 means _type does not implement inter.&#125; iface 内部维护两个指针，tab 指向一个 itab 实体， 它表示接口的类型以及赋给这个接口的实体类型。data 则指向接口具体的值，一般而言是一个指向堆内存的指针。tab和data也分别被称为动态类型和动态值，接口值包括动态类型和动态值。只有当接口的动态类型和动态值都为nil的时候，才有接口值==nil。 0x1.接口类型断言隐士类型转换在Go中是不允许的，这个时候类型就需要进行转换成另一个类型。有两种方式实现：类型转换，类型断言。两者的不同之处在于类型断言是针对接口变量。 1).类型转换&lt;结果&gt; := &lt;目标类型&gt;(&lt;表达式&gt;) f = 10.101i := int(f)fmt.Printf(&quot;%T, %v\\n&quot;, i, i) //output: int, 10 类型转换前后的两个类型需要相互兼容才可以，不然编译器会报错。 2).类型断言因为空接口 interface&#123;&#125; 没有定义任何函数，因此 Go 中所有类型都实现了空接口。当一个函数的形参是 interface&#123;&#125;，那么在函数中，需要对形参进行断言，从而得到它的真实类型。 &lt;目标类型的值&gt; :&#x3D; &lt;表达式&gt;.( 目标类型 ) &#x2F;&#x2F;非安全类型断言 type Duck struct &#123; age int&#125;func main() &#123; var d interface&#123;&#125; = new(Duck) s := d.(Duck) fmt.Println(s)&#125;//run main.go//panic: &quot;interface conversion: interface &#123;&#125; is *main.Duck, not main.Duck&quot; &lt;目标类型的值&gt;，&lt;布尔参数&gt; :&#x3D; &lt;表达式&gt;.( 目标类型 ) &#x2F;&#x2F; comma-ok断言,安全类型断言 type Duck struct &#123; age int&#125;func main() &#123; var d interface&#123;&#125; = new(Duck) s, ok := d.(Duck) if ok &#123; fmt.Println(s) &#125; fmt.Printf(&quot;d type is %T&quot;, d)&#125;//run main.go//d type is *main.Duck 尽量使用comma-ok断言，即使断言失败也不会panic。 断言其实也可以使用 switch 语句判断接口的类型，每一个 case 会被顺序地考虑。当命中一个 case 时，就会执行 case 中的语句，因此 case 语句的顺序是很重要的，因为很有可能会有多个 case 匹配的情况。 switch m := m.(type) &#123; case nil: case Duck: case *Duck: default:&#125;","categories":[{"name":"Golang","slug":"Golang","permalink":"https://blog.eganx.cn/categories/Golang/"}],"tags":[{"name":"go","slug":"go","permalink":"https://blog.eganx.cn/tags/go/"},{"name":"interface","slug":"interface","permalink":"https://blog.eganx.cn/tags/interface/"}]},{"title":"Go Interface理解(1)","slug":"Go_Interface_1","date":"2022-10-29T11:23:19.000Z","updated":"2022-11-22T06:10:18.113Z","comments":true,"path":"2022/10/29/Go_Interface_1/","link":"","permalink":"https://blog.eganx.cn/2022/10/29/Go_Interface_1/","excerpt":"Go语言中，接口是不需要像传统的静态编程语言一样进行声明后才能使用。它引用了动态语言的接口使用方式，只需要实现接口要求的相关方法就行，同时还会在编译阶段进行类型匹配，个人觉得非常好用。","text":"Go语言中，接口是不需要像传统的静态编程语言一样进行声明后才能使用。它引用了动态语言的接口使用方式，只需要实现接口要求的相关方法就行，同时还会在编译阶段进行类型匹配，个人觉得非常好用。 0x0.Interface &amp; Duck Typing所谓Go语言式的接口，就是不用显示声明类型T实现了接口I，只要类型T的公开方法完全满足接口I的要求，就可以把类型T的对象用在需要接口I的地方。这种做法的学名叫做Structural Typing，也有人称它为一种静态的Duck Typing。 Duck Typing一般常见于动态语言中（比如python），但是动态语言不会在编译阶段去进行类型匹配，只有在运行到当前行代码的时候才会报错。而传统的静态语言（比如Java），必须显示地去声明实现了某个接口，然后才可以去使用。这跟动态语言静态语言的讨论类似，可以讨论优缺点，但是不能以好坏去下结论。 Go语言本身作为一种静态语言，静态语言的类型检查是肯定有的。但是在接口的使用上，引用了动态语言的接口使用方式。即不要求类型显示地去声明实现了某个接口，只需要实现接口要求的相关方法就行，编译阶段会去进行类型检查。如果没有实现相关方法，编译是会报错的。 举个🌰： type IDuck interface &#123; gaga() swimming()&#125;type Duck struct&#123;&#125;func (d Duck) gaga() &#123; fmt.Println(&quot;Duck gaga&quot;)&#125;func (d *Duck) swimming() &#123; fmt.Println(&quot;Duck swimming&quot;)&#125;func main() &#123; var _ IDuck = (*Duck)(nil)&#125; var _ IDuck = (*Duck)(nil) //这个很实用，编译器会由此检查 *Duck类型是否实现了 IDuck 接口。 以上的代码编译可以通过，表示A实现了Duck接口，那么A就是一只鸭子🦆。 但是当注释了A的游泳方法时，就会出现编译器会直接爆出以下错误，表示A并没有完全实现Duck接口，A不是一只鸭子🦆。 // func (d *Duck) swimming() &#123;// fmt.Println(&quot;Duck swimming&quot;)// &#125;func main() &#123; var _ IDuck = (*Duck)(nil) //编译报错：cannot use (*A)(nil) (value of type *A) as Duck value in variable declaration: *A does not implement Duck (missing method swimming) compiler(InvalidIfaceAssign)&#125; 0x1.方法接口方法方便接口添加新的行为。方法有接收者，当没有了接收者，方法就变成了函数。接收者有两种类型，一种是值接收者，另一种是指针接收者。 方法的调用者不必满足接收者类型。换句话说，无论方法的接收者是什么类型，该类型的值和指针都可以调用。 func main() &#123; var _ IDuck = (*Duck)(nil) d := Duck&#123;&#125; //d := &amp;Duck&#123;&#125; 也是可以的 d.gaga() d.swimming()&#125; 当方法的接收者是值类型的时候，无论调用者是值类型还是指针类型，该方法操作的都是对应接收者的值的副本。即使你用指针类型去调用，方法内部操作还是对副本的操作，而不是指针操作。同理，当接收者是指针时，即使用值类型调用，方法内部也是对指针的操作，修改的是值指针指向的值本身。 0x2.接口实现type IDuck interface &#123; gaga() swimming()&#125;type Duck struct&#123;&#125;func (d Duck) gaga() &#123; fmt.Println(&quot;A gaga&quot;)&#125;func (d *Duck) swimming() &#123; fmt.Println(&quot;A swimming&quot;)&#125;func main() &#123; d := &amp;Duck&#123;&#125; dd := Duck&#123;&#125; var _ IDuck = (*Duck)(d) //OK var _ IDuck = (Duck)(dd) //编译报错：cannot use (Duck)(dd) (value of type Duck) as IDuck value in variable declaration: Duck does not implement IDuck (method swimming has pointer receiver)compilerInvalidIfaceAssign&#125; 编译器不考虑我们的值是实现该接口的类型，接口的调用规则是建立在这些方法的接受者和接口如何被调用的基础上。下面的是语言规范里定义的规则，这些规则用来说明是否我们一个类型的值或者指针该接口： 接收者是指针 *T 时，接口的实例必须是指针 接收者是值 T 时，接口的实例可以是指针也可以是值 也就是说：实现了接收者是值类型的方法，相当于自动实现了接收者是指针类型的方法；而实现了接收者是指针类型的方法，不会自动生成对应接收者是值类型的方法。 Q&amp;A：既然实现接收者是值类型的方法时，会自动实现接收者是指针类型的方法，那么为啥要用指针类型去做接收者？什么时候会去使用指针作为方法的接收者？ 方法的接收者是值类型的时候，修改的永远是对象的副本，不会对调用者有影响。但是接收者是指针的时候，在方法里修改，就是修改了指针指向的对象本身。当类型是大型的结构体或者不能被安全的复制时，就定义指针接收者方法，例如文件结构体（struct File）。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://blog.eganx.cn/categories/Golang/"}],"tags":[{"name":"go","slug":"go","permalink":"https://blog.eganx.cn/tags/go/"},{"name":"interface","slug":"interface","permalink":"https://blog.eganx.cn/tags/interface/"}]},{"title":"Go Map的遍历","slug":"Go_Map_Range","date":"2022-10-26T13:33:01.000Z","updated":"2022-11-20T04:33:57.713Z","comments":true,"path":"2022/10/26/Go_Map_Range/","link":"","permalink":"https://blog.eganx.cn/2022/10/26/Go_Map_Range/","excerpt":"Map的遍历过程是便利所有的bucket(一般称之为桶)以及挂载的overflow bucket，然后逐一遍历bucket的所有cell，从有key的cell中取出key和value，遍历完成。实际在遍历的时候，有可能map处于扩容过程中,这时候map的状态就相当于是处于一个中间态，即有些bucket已经迁移，有些bucket还在原来的位置。也就是说遍历如果发生在扩容的过程中，就会涉及到遍历新老 bucket 的过程，就比较麻烦。","text":"Map的遍历过程是便利所有的bucket(一般称之为桶)以及挂载的overflow bucket，然后逐一遍历bucket的所有cell，从有key的cell中取出key和value，遍历完成。实际在遍历的时候，有可能map处于扩容过程中,这时候map的状态就相当于是处于一个中间态，即有些bucket已经迁移，有些bucket还在原来的位置。也就是说遍历如果发生在扩容的过程中，就会涉及到遍历新老 bucket 的过程，就比较麻烦。 0x0.Map遍历是无序的在遍历map的时候，可以发现key是无序的。正常来说从一个固定Map的第一个bucket的第一个cell逐步遍历取出key的话，key应该是有序的。因为扩容会带来某些key的bucket或者cell发生变化，Go为了避免我们误认为遍历map会得到有序key，在遍历开始的时候，不是从0号bucket开始，而是会给一个随机数，从一个随机的bucket开始，更绝的是在开始bucket中的开始cell也是随机选择的。这样的话，就算是一个写死的map在遍历的时候依旧不会返回一个固定序列的key集合。 // decide where to start r := uintptr(fastrand()) if h.B &gt; 31-bucketCntBits &#123; r += uintptr(fastrand()) &lt;&lt; 31 &#125; // start bucket it.startBucket = r &amp; bucketMask(h.B) // start cell it.offset = uint8(r &gt;&gt; h.B &amp; (bucketCnt - 1)) 0x1.遍历过程假如有一个起始B=1的map（有0号和1号两个bucket），现在触发扩容，B变成了2（有0-3号4个bucket）。假设现在老0号bucket已经迁移到新0号和新2号bucket中，老1号中的bucket尚未开始迁移。此时开始对map的遍历，假设startBucket = 2,offset = 4，遍历的起点就是2号bucket中第4个cell。bucket的遍历顺序就是：2-&gt;3-&gt;0-&gt;1。 2号bucket对应的是老0号bucket，检查老0号bucket的迁移状态，发现完成已经完成迁移，从4号cell依次遍历2号bucket中所有cell。如果2号bucket返回的key是非空的，就会继续遍历2号bucket的overflow bucket。 完成2号bucket的遍历后，开始3号bucket的遍历，检查后发现3号bucket对应的老1号bucket并没有迁移，这个时候就会去遍历老1号bucket。但是并不会取出老1号bucket的全部key，只会取出hash值后两位为11的key，因为这些key最终会迁移进新3号bucket。 完成3号bucket的遍历，继续0号bucket的遍历，已迁移，取出新0号bucket中的key。 继续1号bucket的遍历，未迁移，遍历老1号bucket，取出hash值后两位为01的key。 再次到2号bucket的时候，表示所有bucket遍历完成，map的遍历也就结束了。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://blog.eganx.cn/categories/Golang/"}],"tags":[{"name":"go","slug":"go","permalink":"https://blog.eganx.cn/tags/go/"},{"name":"map","slug":"map","permalink":"https://blog.eganx.cn/tags/map/"}]},{"title":"Go Map的扩容","slug":"Go_Map_Grow","date":"2022-10-24T07:53:19.000Z","updated":"2022-11-20T04:33:16.832Z","comments":true,"path":"2022/10/24/Go_Map_Grow/","link":"","permalink":"https://blog.eganx.cn/2022/10/24/Go_Map_Grow/","excerpt":"在使用slice的时候，如果向slice中追加元素的时候，导致元素数量大于cap，这时候就会发生slice的扩容。那么在go语言中，什么时候map会发生扩容呢？扩容的策略有哪些呢？扩容的过程是怎样的呢？很是好奇，心动不如行动。开始学习，又是收获满满的一天。","text":"在使用slice的时候，如果向slice中追加元素的时候，导致元素数量大于cap，这时候就会发生slice的扩容。那么在go语言中，什么时候map会发生扩容呢？扩容的策略有哪些呢？扩容的过程是怎样的呢？很是好奇，心动不如行动。开始学习，又是收获满满的一天。 0x0.触发扩容的条件众所周知，map是使用hash表的。使用hash表的目的就是追求更加快速的找到key，但是当map中key的数量逐渐增加，逐渐离谱的时候，那么碰撞的几率就越来越大，效率也就随之下降了。最离谱的时候就是所有的key都在一个bucket里面 (这是碳基生物能干出来的事?这和链表有个锤子的区别吗？)，最好就是一个bucket里面就一个key，找到了bucket就找到了key，效率贼高，直接拉到o(1)。但是空间不允许啊，为了效率用空间换时间不寒碜？(很寒碜，贼TM寒碜)。 最好最坏都属于极端，其实都很难遇到，只是在举🌰的时候夸张表述才会用到。在go语言中，有一个loadFactor指标来对上面的两种情况进行衡量。废话不多说，直接上源码(/go1.18.2/src/runtime/map.go) // 判断条件在mapassign函数中。// If we hit the max load factor or we have too many overflow buckets,// and we&#x27;re not already in the middle of growing, start growing.if !h.growing() &amp;&amp; (overLoadFactor(h.count+1, h.B) || tooManyOverflowBuckets(h.noverflow, h.B)) &#123; hashGrow(t, h) goto again // Growing the table invalidates everything, so try again&#125; 从上面的条件可以看出，map扩容一个是在overLoadFactor的时候，一个是在tooManyOverflowBuckets。下面是这两个函数所用到的常量以及主要的引用函数。 const (// Maximum number of key/elem pairs a bucket can hold. bucketCntBits = 3 bucketCnt = 1 &lt;&lt; bucketCntBits //8 // Maximum average load of a bucket that triggers growth is 6.5. // Represent as loadFactorNum/loadFactorDen, to allow integer math. loadFactorNum = 13 loadFactorDen = 2)// PtrSize is the size of a pointer in bytes - unsafe.Sizeof(uintptr(0)) but as an ideal constant.// It is also the size of the machine&#x27;s native word size (that is, 4 on 32-bit systems, 8 on 64-bit).const PtrSize = 4 &lt;&lt; (^uintptr(0) &gt;&gt; 63)// bucketShift returns 1&lt;&lt;b, optimized for code generation.func bucketShift(b uint8) uintptr &#123; // Masking the shift amount allows overflow checks to be elided. return uintptr(1) &lt;&lt; (b &amp; (goarch.PtrSize*8 - 1))&#125;// overLoadFactor reports whether count items placed in 1&lt;&lt;B buckets is over loadFactor.func overLoadFactor(count int, B uint8) bool &#123; return count &gt; bucketCnt &amp;&amp; uintptr(count) &gt; loadFactorNum*(bucketShift(B)/loadFactorDen)&#125;// tooManyOverflowBuckets reports whether noverflow buckets is too many for a map with 1&lt;&lt;B buckets.// Note that most of these overflow buckets must be in sparse use;// if use was dense, then we&#x27;d have already triggered regular map growth.func tooManyOverflowBuckets(noverflow uint16, B uint8) bool &#123; // If the threshold is too low, we do extraneous work. // If the threshold is too high, maps that grow and shrink can hold on to lots of unused memory. // &quot;too many&quot; means (approximately) as many overflow buckets as regular buckets. // See incrnoverflow for more details. if B &gt; 15 &#123; B = 15 &#125; // The compiler doesn&#x27;t see here that B &lt; 16; mask B to generate shorter shift code. return noverflow &gt;= uint16(1)&lt;&lt;(B&amp;15)&#125; 1）第一种情况// overLoadFactor reports whether count items placed in 1&lt;&lt;B buckets is over loadFactor.func overLoadFactor(count int, B uint8) bool &#123; // 换算一下下: count &gt; 8 &amp;&amp; count &gt; 13*((2^B)/2) // loadFactor = count/(2^B) &gt; 6.5 return count &gt; bucketCnt &amp;&amp; uintptr(count) &gt; loadFactorNum*(bucketShift(B)/loadFactorDen)&#125; 其中count是map的元素个数，1&lt;&lt;B表示bucket数组长度。也就是说在loadFactor := count/(2^B)超过6.5的时候，会触发map的扩容。按照loadFactor的计算方式，当所有bucket都满的时候是8。达到6.5的时候也就差不多算是满了大半了，无论查找还是插入，这个时候碰撞的几率很高，效率也会下降的厉害，所以这是触发扩容的时机。 如果不停的插入元素、删除元素，然后在插入元素。刚开始插入元素的时候会创建大量bucket。但是只要没有达到第一种扩容情况，也就是说loadFactor的值低于6.5。这个时候进行删除元素的操作，降低loadFactor的分子。然后重复操作，就会产生大量overflow bucket。这个时候key就会过于分散，导致查找和插入的效率过低。为了避免这种情况的发生，就有了下面第二种触发扩容的条件。 2) 第二种情况// tooManyOverflowBuckets reports whether noverflow buckets is too many for a map with 1&lt;&lt;B buckets.// Note that most of these overflow buckets must be in sparse use;// if use was dense, then we&#x27;d have already triggered regular map growth.func tooManyOverflowBuckets(noverflow uint16, B uint8) bool &#123; // If the threshold is too low, we do extraneous work. // If the threshold is too high, maps that grow and shrink can hold on to lots of unused memory. // &quot;too many&quot; means (approximately) as many overflow buckets as regular buckets. // See incrnoverflow for more details. if B &gt; 15 &#123; B = 15 &#125; // The compiler doesn&#x27;t see here that B &lt; 16; mask B to generate shorter shift code. return noverflow &gt;= uint16(1)&lt;&lt;(B&amp;15)&#125; 翻译成人话：overflow的bucket数量太多了。当B &gt;= 15的时候，如果overflow的bucket数量超过2^15就触发扩容；当B &lt; 15的时候，如果overflow的bucket数量超过2^B就触发扩容。第二种的这个情况主要是为了避免loadFactor的分子小的时候，却有大量的bucket(包括大量的overflow bucket)。 0x1.扩容策略针对两种不同的触发扩容的条件，进行扩容的策略也有所不同。 第一种情况是由于元素数量过多，导致了bucket数组快满了。这个时候采用的扩容策略就是B+1，bucket的数组长度变成之前的2倍（2倍扩容） 第二种情况是由于flowbucket的过多造成，元素没有那么多，主要是位置分散，造成查找和插入的效率较低。采用第一种的扩容策略肯定是不行的，解决的办法是采用等量扩容，创建一个和老buckets数组相同长度的新buckets数组。将老buckets中处于同一个bucket的元素进行紧密排列，尽可能的消除overflow bucket，节省空间，提高效率。 map的扩容不是原子操作，不会一步到位。扩容需要将原本的键值对迁移到新bucket得内存地址中，大量键值对同时迁移会影响性能，所以Go map的扩容是采用“渐进式”方式。每次最多只会迁移2个bucket。 0x2.迁移过程第一种扩容策略，因为B+1会导致key的hash值需要重新计算，才能确定它会落入那个bucket中，毕竟确定bucket位置的是根据hash值的后B位。这样的话就会导致某些key在迁移前后的bucket序号是不一样的。 举个🌰：初始状态下B=2，3号bucket里有两个key的hash值后3位值011,111，经过B+1扩容之后，这两个原本处于3号bucket的key会分别落入3号和7号bucket。key在迁移前后是否还是处于原本的bucket取决于倒数第3位是0还是1。 ┌───────────────────────┐ │ │ ┌─────┼─────────────────┐ │ │ │ │ │ ┌─────┼─────┼───────────┐ │ │ │ │ │ │ │ │ ┌─────┼─────┼─────┼─────┐ │ │ │ │ │ │ │ │ │ │ │┌──┴──┬──┴──┬──┴──┬──┴──┐ │ │ │ ││ │ │ │ │ │ │ │ ││ 0 │ 1 │ 2 │ 3 │ │ │ │ ││ │ │ │ │ │ │ │ │└──┬──┴──┬──┴──┬──┴──┬──┘ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ ▼ ▼ ▼ ▼ ▼ ▼ ▼ ▼┌─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┐│ │ │ │ │ │ │ │ ││ 0 │ 1 │ 2 │ 3 │ 4 │ 5 │ 6 │ 7 ││ │ │ │ │ │ │ │ │└─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┘ 第二种扩容策略，等量扩容因为B是不变的，所以key还是在原来的bucket。主要是为了收拢过于分散的key(大多数都分散在overflow bucket中)。下面的图是迁移完成的情况。 buckets B&#x3D;2 buckets B&#x3D;2┌─────┬─────┬─────┬─────┐ ┌─────┬─────┬─────┬─────┐│ │ │ │ │ │ │ │ │ ││ 0 │ 1 │ 2 │ 3 │ │ 0 │ 1 │ 2 │ 3 ││ │ │ │ │ │ │ │ │ │└─────┴─────┴─────┴──┬──┘ └─────┴─────┴─────┴──┬──┘ │ │ ┌─────────────────┘ ┌───────┘ │ │ ▼ ▼┌────┐ ┌────┐ ┌────┐ ┌────┐│bmap│ ┌─►│bmap│ ┌─►│bmap│ │bmap│├────┴┐ │ ├────┴┐ │ ├────┴┐ ├────┴┐│key:a│ │ │ │ │ │key:f│ │key:a││ 111 │ │ │ │ │ │ 111 │ │ 111 │├─────┤ │ ├─────┤ │ ├─────┤ ├─────┤│key:b│ │ │ │ │ │ │ │key:b││ 011 │ │ │ │ │ │ │ │ 011 │├─────┤ │ ├─────┤ │ ├─────┤ ├─────┤│ │ │ │key:d│ │ │ │ │key:c││ │ │ │ 111 │ │ │ │ │ 011 │├─────┤ │ ├─────┤ │ ├─────┤ ├─────┤│ │ │ │ │ │ │ │ │key:d││ │ │ │ │ │ │ │ │ 111 │├─────┤ │ ├─────┤ │ ├─────┤ ├─────┤│key:c│ │ │key:e│ │ │ │ │key:e││ 011 │ │ │ 111 │ │ │ │ │ 111 │├─────┤ │ ├─────┤ │ ├─────┤ ├─────┤│ │ │ │ │ │ │key:g│ │key:f││ │ │ │ │ │ │ 011 │ │ 111 │├─────┤ │ ├─────┤ │ ├─────┤ ├─────┤│ │ │ │ │ │ │ │ │key:g││ │ │ │ │ │ │ │ │ 011 │├─────┤ │ ├─────┤ │ ├─────┤ ├─────┤│ │ │ │ │ │ │ │ │ ││ │ │ │ │ │ │ │ │ │├─────┤ │ ├─────┤ │ ├─────┤ ├─────┤│*over│ │ │*over│ │ │*over│ │*over││flow ├──┘ │flow ├─┘ │flow │ │flow │└─────┘ └─────┘ └─────┘ └─────┘","categories":[{"name":"Golang","slug":"Golang","permalink":"https://blog.eganx.cn/categories/Golang/"}],"tags":[{"name":"go","slug":"go","permalink":"https://blog.eganx.cn/tags/go/"},{"name":"map","slug":"map","permalink":"https://blog.eganx.cn/tags/map/"}]},{"title":"Go Map的基本介绍","slug":"Go_Map","date":"2022-10-22T06:53:19.000Z","updated":"2022-11-20T04:33:23.564Z","comments":true,"path":"2022/10/22/Go_Map/","link":"","permalink":"https://blog.eganx.cn/2022/10/22/Go_Map/","excerpt":"map由key-value对组成，并且一个key只会出现一次。对map可以进行增删改查一系列操作。在Go语言，map采用的是哈希查找表实现，解决哈希冲突的方式是链表法。记录一下学习过程中了解到的map基本结构和key的定位过程。","text":"map由key-value对组成，并且一个key只会出现一次。对map可以进行增删改查一系列操作。在Go语言，map采用的是哈希查找表实现，解决哈希冲突的方式是链表法。记录一下学习过程中了解到的map基本结构和key的定位过程。 0x0.map的基本结构附上源码(go1.18.2/src/runtime/map.go) // A header for a Go map.type hmap struct &#123; // Note: the format of the hmap is also encoded in // cmd/compile/internal/reflectdata/reflect.go. // Make sure this stays in sync with the compiler&#x27;s definition. count int // # live cells == size of map. Must be first (used by len() builtin) flags uint8 B uint8 // log_2 of # of buckets (can hold up to loadFactor * 2^B items) noverflow uint16 // approximate number of overflow buckets; see incrnoverflow for details hash0 uint32 // hash seed buckets unsafe.Pointer // array of 2^B Buckets. may be nil if count==0. oldbuckets unsafe.Pointer // previous bucket array of half the size, non-nil only when growing nevacuate uintptr // progress counter for evacuation (buckets less than this have been evacuated) extra *mapextra // optional fields&#125; ┌──────┐│ hmap │├──────┴─────────────────────┐ ┌─────┐│ count int │ │ │├────────────────────────────┤ │ ▼│ flags uint8 │ │ ┌──────┐ ┌───────┐├────────────────────────────┤ │ │[]bmap│ ┌►│ bmap ││ B uint8 │ │ ├──────┴─┐ │ ├───────┴───────────────────────┐├────────────────────────────┤ │ │ 0 ├──┘ │ tophash [bucketCnt]uint8 ││ noverflow uint16 │ │ ├────────┤ ├───────┬───────────────────────┤├────────────────────────────┤ │ │ 1 │ │ key │ ││ hash0 uint32 │ │ ├────────┤ ├───┬───┼───┬───┬───┬───┬───┬───┤├────────────────────────────┤ │ │ 2 │ │ 0 │ 1 │ 2 │ 3 │ 4 │ 5 │ 6 │ 7 ││ buckets unsafe.Pointer ├─┘ ├────────┤ ├───┴───┼───┴───┴───┴───┴───┴───┤├────────────────────────────┤ │ 3 │ │ values│ ││ oldbuckets unsafe.Pointer │ ├────────┤ ├───┬───┼───┬───┬───┬───┬───┬───┤├────────────────────────────┤ │ ... │ │ 0 │ 1 │ 2 │ 3 │ 4 │ 5 │ 6 │ 7 ││ nevacuates uintptr │ ├────────┤ ├───┴───┴───┴───┴───┴───┴───┴───┤├────────────────────────────┤ │ 62 │ │ overflow *bmap ││ extra *mapextra │ ├────────┤ └─────┬─────────────────────────┘└────┬───────────────────────┘ │ 63 ├─┐ │ │ └────────┘ │ │ ┌───────┐ ▼ size&#x3D;2^B │ └─────►│ bmap │┌──────────┐ │ ├───────┴───────────────────────┐│ mapextra │ │ │ tophash [bucketCnt]uint8 │├──────────┴─────────┐ │ ├───────┬───────────────────────┤│ overflow *[]*bmap │ ┌───────┐ ◄─────────┘ │ key │ │├────────────────────┤ │ bmap │ ├───┬───┼───┬───┬───┬───┬───┬───┤│oldoverflow *[]*bmap│ ├───────┴───────────────────────┐ │ 0 │ 1 │ 2 │ 3 │ 4 │ 5 │ 6 │ 7 │├────────────────────┤ │ tophash [bucketCnt]uint8 │ ├───┴───┼───┴───┴───┴───┴───┴───┤│ nextoverflow *bmap │ ├───────┬───────────────────────┤ │ values│ │└────────────────────┘ │ key │ │ ├───┬───┼───┬───┬───┬───┬───┬───┤ ├───┬───┼───┬───┬───┬───┬───┬───┤ │ 0 │ 1 │ 2 │ 3 │ 4 │ 5 │ 6 │ 7 │ │ 0 │ 1 │ 2 │ 3 │ 4 │ 5 │ 6 │ 7 │ ├───┴───┴───┴───┴───┴───┴───┴───┤ ├───┴───┼───┴───┴───┴───┴───┴───┤ │ overflow *bmap │ │ values│ │ └───────────────────────────────┘ ├───┬───┼───┬───┬───┬───┬───┬───┤ │ 0 │ 1 │ 2 │ 3 │ 4 │ 5 │ 6 │ 7 │ ├───┴───┴───┴───┴───┴───┴───┴───┤ ┌────────┐ │ overflow *bmap ├──────►│ nil │ └───────────────────────────────┘ └────────┘ 其中B是bucket数组长度的对数，bucket里面存储了key和value。可以看见一个bucket里面最多能装8个key，这8个key在bucket里面的位置根据hash值的高8位决定。nevacuate表示扩容进度，小于此地址的 buckets 迁移完成。Ascii风格的map内存模型图是参考曹大github里的，曹大yyds。 其中bucket指针指向的结构体如下： // A bucket for a Go map.type bmap struct &#123; // tophash generally contains the top byte of the hash value // for each key in this bucket. If tophash[0] &lt; minTopHash, // tophash[0] is a bucket evacuation state instead. tophash [bucketCnt]uint8 // Followed by bucketCnt keys and then bucketCnt elems. // NOTE: packing all the keys together and then all the elems together makes the // code a bit more complicated than alternating key/elem/key/elem/... but it allows // us to eliminate padding which would be needed for, e.g., map[int64]int8. // Followed by an overflow pointer.&#125; ┌───────┐│ bmap │├───────┴───────────────────────┐│ tophash [bucketCnt]uint8 │├───────┬───────────────────────┤│ key │ │├───┬───┼───┬───┬───┬───┬───┬───┤│ 0 │ 1 │ 2 │ 3 │ 4 │ 5 │ 6 │ 7 │├───┴───┼───┴───┴───┴───┴───┴───┤│ values│ │├───┬───┼───┬───┬───┬───┬───┬───┤│ 0 │ 1 │ 2 │ 3 │ 4 │ 5 │ 6 │ 7 │├───┴───┴───┴───┴───┴───┴───┴───┤│ overflow *bmap │└───────────────────────────────┘ 其中key和value是各自存放在一起的，为什么要这么做呢，以下是在注释中的官方解释。 NOTE: packing all the keys together and then all the elems together makes the code a bit more complicated than alternating key/elem/key/elem/... but it allows us to eliminate padding which would be needed for, e.g., map[int64]int8. 主要是为了减少内存对齐带来的padding。注释中给了一个例子map[int64]int8，如果是按照key/elem/key/elem/这种方式存储，相当于每一个key/elem都需要padding7个字节。64位的机器上，默认的对齐系数是8，同时int8的对齐系数是1，int64的对齐系数是8。以下是key/elem方式产生padding的过程： 第一个key，key1(int64)的大小和对齐值是8，占据8位。暂且写做：kkkkkkkk 第一个value，value1(int8)的大小和对齐值是1，占据1位。写做：kkkkkkkk｜v 第二个key，key2(int64)的大小和对齐值是8，偏移量必须是8的倍数。也就产生了padding。不能直接接着value1后面写了，写作：kkkkkkkk｜vxxxxxxx｜kkkkkkkk。其中x表示padding。后面也就是依次类推了。 如果是按照key/key/key/.../key/elem/elem/.../elem来进行存储的话，只需要在最后面添加padding就行。内存对齐一般好像不怎么会考虑，但是了解还是需要了解的，TODO List再加一项。 0x1.map中key的位置在64位的机器上面，key经过hash计算后会得到一个64bit的哈希值。在key的定位过程中会用到哈希值的高8位和后B位。B就是hmap中的B，如果B=6，buckets数组的长度就是2^6=64。 举个🌰,现在有一个key的哈希值如下： 00000111 | 00001111111011001111111111101010001000000001010000 | 000010 key┌────────────────────────────────────────────────────────────────────────┐│ 00000111 | 00001111111011001111111111101010001000000001010000 | 000010 │└────┬──────────────────────────────────────────────────────────────┬────┘ │ │ │ ▼ │ B&#x3D;6 ┌────────────────┐ │ bucketMask&#x3D;111111 │ 000010&amp;111111 │ │ └────────────┬───┘ │ tophash │ │ ▼ │ ┌────────┐ │ ┌─────────────────────┤000010&#x3D;2│ ▼ │ └────────┘┌────────────┐ buckets ▼│ 00000111&#x3D;7 │ ┌───┬───┬───┬───┬──────────┬────┬────┬────┐└─────┬──────┘ │ 0 │ 1 │ 2 │ 3 │ ... │ 61 │ 62 │ 63 │ │ └───┴───┴─┬─┴───┴──────────┴────┴────┴────┘ │ │ │ │ └─────────────────────────────┐ │ │ ▼ ┌────────────────────────┼────────────┬──────┐ │ │ │bucket│ │ ┌───────┐ │ ├──────┘ │ │ bmap │ ▼ │ │ ├───┬───┼───┬───┬───┬───┬───┬───┐ │ │ │111│ 9 │ 3 │ 5 │ 6 │ 7 │ 0 │ 0 │ │ │ ├───┴───┼───┴───┴───┴───┴───┴───┤ │ │ │ key │ │ │ │ ├───┬───┼───┬───┬───┬───┬───┬───┤ │ │ │ 5 │ 2 │ 1 │ 4 │ 3 │ 9 │ 0 │ 0 │ │ │ ├───┴───┼───┴───┴───┴───┴───┴───┤ │ │ │ values│ │ │ │ ├───┬───┼───┬───┬───┬───┬───┬───┤ │ │ │ 3 │ 5 │ 4 │ 7 │ 9 │ 6 │ 0 │ 0 │ │ │ ├───┴───┴───┴───┴───┴───┴───┴───┤ │ │ │ overflow *bmap │ │ │ └───────────────────────────────┘ │ │ │ └─────────────────────────────────────┘ 如果在 bucket 中没找到，并且 overflow 不为空，还要继续去 overflow bucket 中寻找，直到找到或是所有的 key 槽位都找遍了，包括所有的 overflow bucket。 实现上有 mapaccess1，mapaccess2，mapaccessK 几个方法，主要区别是在返回内容上。当要查询的 key 不在 map 里，mapaccess2的用法会返回一个 bool 型变量提示 key 是否在 map 中；而mapaccess1 的语句则会返回一个 key 对应 value 类型的零值。如果 value 是 int 型就会返回 0，如果 value 是 string 类型，就会返回空字符串。mapaccess2就是日常代码中v, ok := map[k]的底层函数。 0x2.Go Map是线程安全的吗？map不是线程安全的。在对map进行读写操作的时候都会先检测写标志，发现写标志位置1，会panic。所以不能一边写入一边遍历。 一个协程内一边删除一边遍历的操作是允许的，但是真的这么干了，大概率会被打。毕竟遍历出来的结果有可能会包含已经删除的元素。 上面的两种情况看看就行，真要写的时候一般都会加读写锁：sync.RWMutex。 map不是线程安全的，但是sync.Map是线程安全。 0x3.如何判断两个map是否相等两个map是否相等不能直接通过==判断，编译报错。 引用书里的map深度相等的条件： 1、都为nil 2、非空，长度相等，指向同一个map实体 3、相同的key指向的value“深度”相等 var m map[int]intvar n map[int]intfmt.Println(m == nil) //OKfmt.Println(n == nil) //OKfmt.Println(m == n) //编译报错 因此只能是遍历map 的每个元素，比较元素是否都是深度相等。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://blog.eganx.cn/categories/Golang/"}],"tags":[{"name":"go","slug":"go","permalink":"https://blog.eganx.cn/tags/go/"},{"name":"map","slug":"map","permalink":"https://blog.eganx.cn/tags/map/"}]},{"title":"Go Slice的扩容策略","slug":"Go_Slice_growup","date":"2022-10-15T04:56:11.000Z","updated":"2022-11-20T04:33:01.426Z","comments":true,"path":"2022/10/15/Go_Slice_growup/","link":"","permalink":"https://blog.eganx.cn/2022/10/15/Go_Slice_growup/","excerpt":"在写Go的时候，对Slice的操作就很危险，特别是函数参数传的是Slice指针，一不小心就改了。切片支持子切片 和原本切片共享底层数组，那子切片和切片究竟会不会相互影响？ 就看他们是不是还共享底层数组。如果他们的结构没有变化，肯定是共享的。结构发生变化(扩容)，就可能不共享了。 对子切片的使用建议：只读不改","text":"在写Go的时候，对Slice的操作就很危险，特别是函数参数传的是Slice指针，一不小心就改了。切片支持子切片 和原本切片共享底层数组，那子切片和切片究竟会不会相互影响？ 就看他们是不是还共享底层数组。如果他们的结构没有变化，肯定是共享的。结构发生变化(扩容)，就可能不共享了。 对子切片的使用建议：只读不改 0x0.Slice和Array的联系slice 的底层数据是数组，slice 是对数组的封装。两者都可以通过下标来访问单个元素。 数组就是一片连续的内存，是定长的，其长度是类型的一部分，比如 [3]int 和 [4]int 就是不同的类型。 slice可以动态地扩容，切片的类型和长度无关。 slice 是一个结构体，包含三个字段：长度、容量、底层数组。 type slice struct &#123; array unsafe.Pointer &#x2F;&#x2F; 元素指针 len int &#x2F;&#x2F; 长度 cap int &#x2F;&#x2F; 容量&#125; 不是每一个Slice都有自己专属的底层数组，底层数组是可以被多个Slice同时指向的，也就是说在修改SliceA的数据时，有可能SliceB的数据也会发生改变。 0x1.Slice扩容策略在golang1.18版本之前，Slice的扩容策略是当原 slice 容量小于 1024 的时候，新 slice 容量变成原来的 2 倍；原 slice 容量超过 1024，新 slice 容量变成原来的1.25倍。 在golang1.18版本之后，新的Slice扩容策略是当原slice容量(oldcap)小于256的时候，新slice(newcap)容量为原来的2倍；原slice容量超过256，新slice容量newcap = oldcap+(oldcap+3*256)/4 在实际的扩容过程中，还需要考虑内存对齐产生的影响，这个和内存分配策略相关。进行内存对齐之后，新 slice 的容量是要 大于等于 理论的扩容量。 经典例题，来自golang Slice的扩容规则 package mainimport &quot;fmt&quot;func main() &#123; s := []int&#123;1,2&#125; s = append(s,4,5,6) fmt.Printf(&quot;len=%d, cap=%d&quot;,len(s),cap(s))&#125; 运行结果： len&#x3D;5, cap&#x3D;6","categories":[{"name":"Golang","slug":"Golang","permalink":"https://blog.eganx.cn/categories/Golang/"}],"tags":[{"name":"go","slug":"go","permalink":"https://blog.eganx.cn/tags/go/"},{"name":"slice","slug":"slice","permalink":"https://blog.eganx.cn/tags/slice/"}]},{"title":"C# GC机制(Garbage Collector)","slug":"CSharp_GC_mechanism","date":"2022-02-08T13:31:19.000Z","updated":"2022-11-20T02:42:11.675Z","comments":true,"path":"2022/02/08/CSharp_GC_mechanism/","link":"","permalink":"https://blog.eganx.cn/2022/02/08/CSharp_GC_mechanism/","excerpt":"记录一下C#中GC的相关知识。不记下来，下次又找不到，就很烦。 主要针对的是C#中如何判定Garbage和GC的运作方式。","text":"记录一下C#中GC的相关知识。不记下来，下次又找不到，就很烦。 主要针对的是C#中如何判定Garbage和GC的运作方式。 0x0.资源概念所谓的资源其实就是程序中可以利用的数据。比如字符串、图片和任何的二进制数据。 托管资源，非托管资源：托管资源是由CLR全权负责的资源，CLR不负责的资源位非托管资源。对于托管资源通过GC自动清理回收。对于非托管的资源，一般就是Stream，数据库的连接，网络连接，GDI+的相关对象，还有Com对象等等这些操作系统资源，需要我们手动去释放，再由GC回收。 0x1.Garbage的判定.Net类型分为两大类，一个就是值类型，另一个就是引用类型。前者是在堆栈中分配内存，它们有自身的生命周期，所以不用对它们进行管理，会自动分配和释放。后者是在堆中分配内存的。所以它的分配和释放就需要像回收机制来管理。 GC的全称为“Garbage Collector”,顾名思义就是垃圾回收器，那么只有被称为垃圾的对象才能被GC回收。也就是说， 一个引用类型对象所占用的内存需要被GC回收，需要先成为垃圾。 .Net判定一个引用类型对象是垃圾，只需要判定此对象或者其包含的子对象没有任何引用是有效的，那么系统就认为它是垃圾。 0x2.非托管资源的释放方式1).Close()关闭对象资源，在显示调用时被调用。 2).Dispose()继承IDisposable接口，实现Dispose方法；介绍：调用Dispose方法，销毁对象，需要显示调用或者通过using语句，在显示调用或者离开using程序块时被调用。Dispose方法用于清理对象封装的非托管资源，而不是释放对象的内存，对象的内存依然由垃圾回收器控制。Dispose方法调用，不但释放该类的非托管资源，还释放了引用的类的非托管资源。Dispose模式就是一种强制资源清理所要遵守的约定；Dispose模式实现IDisposable接口，从而使得该类型提供一个公有的Dispose方法。 而Close与Dispose这两种方法的区别在于，调用完了对象的Close方法后，此对象有可能被重新进行使用；而Dispose方法来说，此对象所占有的资源需要被标记为无用了，也就是此对象被销毁了，不能再被使用。 3).析构函数/Finalize()带有析构函数的类，生命周期会变长。内存空间需要两次垃圾回收才会被释放，导致性能下降。 一个正常情况的类是不会写析构函数的，而一旦一个类写了析构函数，就意味着GC会在不确定的时间调用该类的析构函数，判断该类的资源是否需要释放，然后调用Finalize方法，如果重写了Finalize方法则调用重写的Finalize方法。Finalize方法的作用是保证.NET对象能在垃圾回收时清除非托管资源。在.NET中，Object.Finalize()方法是无法重载的，编译器是根据类的析构函数来自动生成Object.Finalize()方法的Finalize由垃圾回收器调用；dispose由对象调用。Finalize无需担心因为没有调用Finalize而使非托管资源得不到释放，因为GC会在不确定时间调用，当然，你也可以手动调用Finalize方法，而dispose必须手动调用。Finalize虽然无需担心因为没有调用Finalize而使非托管资源得不到释放，但因为由垃圾回收器管理，不能保证立即释放非托管资源；而dispose一调用便释放非托管资源。只有类类型才能重写Finalize，而结构不能；类和结构都能实现IDispose 释放模式：是一种微软建议的写法，先手动显示去释放资源，如果忘记了，再让finalize释放资源。所以如果已经完成了析构函数该干的事情(例如释放非托管资源)，就应当使用SuppressFinalize方法告诉GC不需要再执行某个对象的析构函数。 0x3.GC的运作方式内存的释放和回收需要伴随着程序的运行，因此系统为GC安排了独立的线程。那么GC的工作大致是，查询内存中对象是否成为垃圾，然后对垃圾进行释放和回收。那么对于GC对于内存回收采取了一定的优先算法进行轮循回收内存资源。 其次，对于内存中的垃圾分为两种，一种是需要调用对象的析构函数，另一种是不需要调用的。GC对于前者的回收需要通过两步完成，第一步是调用对象的析构函数，第二步是回收内存，但是要注意这两步不是在GC一次轮循完成，即需要两次轮循；相对于后者，则只是回收内存而已。 C#中的GC使用了Generation的概念，它将分配的对象分为3代(可用GC.GetGeneration方法返回任意作为参数的对象当前所处的代)。 最近被分配内存的对象被放置于第0代，因为第0代很小，小到足以放进处理器的二级（L2)缓存，所以它能够提供对对象的快速存取。经过一轮垃圾回收后，仍然保留在第0代中的对象被移进第1代中，再经过一轮垃圾内存回收后，仍然保留在第1代中的对象则被移进第2代中，第2代中包含了生存期较长的对象。 当第0代中没有可以分配的有效内存时，就触发了第0代中的一轮垃圾回收，它将删除那些不再被引用的对象，并将当前正在使用的对象移至第1代。而当第0代垃圾回收后依然不能请求到充足的内存时，就启动第1代垃圾回收。如果对各代都进行了垃圾回收后仍没有可用的内存就会引发一个OutOfMemoryException异常。 Close Dispose 析构函数 关闭对象资源 销毁对象 销毁对象 调用方式 需要显示调用 需要显示调用或者通过using语句 不能被显示调用，会被GC调用 调用时机 在显示调用时 在显示调用或者离开using程序块 不确定","categories":[{"name":"Work","slug":"Work","permalink":"https://blog.eganx.cn/categories/Work/"},{"name":"C#","slug":"Work/C","permalink":"https://blog.eganx.cn/categories/Work/C/"}],"tags":[{"name":"C#","slug":"C","permalink":"https://blog.eganx.cn/tags/C/"},{"name":"GC","slug":"GC","permalink":"https://blog.eganx.cn/tags/GC/"}]},{"title":"Go版本切换","slug":"Go_Version_switching","date":"2022-01-05T13:06:11.000Z","updated":"2022-11-15T09:02:25.162Z","comments":true,"path":"2022/01/05/Go_Version_switching/","link":"","permalink":"https://blog.eganx.cn/2022/01/05/Go_Version_switching/","excerpt":"线上的程序用的是老版本的Go(毕竟比较稳)，自己又想尝试新的版本特性。久而久之，电脑里面SDK的版本就越来越多了，每次切换起来就很麻烦。所以特此记录一下。","text":"线上的程序用的是老版本的Go(毕竟比较稳)，自己又想尝试新的版本特性。久而久之，电脑里面SDK的版本就越来越多了，每次切换起来就很麻烦。所以特此记录一下。 0x0.手动管理(目前使用的切换方式)官网下载最新版Archive文件go1.18beta1.darwin-amd64.tar.gz 解压缩重命名go1.18.beta1,拷贝一份放到默认安装路径/usr/local/go1.18beta1 sudo cp -R /User/egan/Sdks/go1.18beta1 /usr/local/go1.18beta1 进入默认安装路径，创建软链 cd /usr/local/sudo ln -s go1.18beta1 go 0x1.版本切换工具1).gGitHub: https:&#x2F;&#x2F;github.com&#x2F;voidint&#x2F;g 2).goupGithub: https:&#x2F;&#x2F;github.com&#x2F;owenthereal&#x2F;goup","categories":[{"name":"Golang","slug":"Golang","permalink":"https://blog.eganx.cn/categories/Golang/"}],"tags":[{"name":"go","slug":"go","permalink":"https://blog.eganx.cn/tags/go/"},{"name":"版本切换","slug":"版本切换","permalink":"https://blog.eganx.cn/tags/%E7%89%88%E6%9C%AC%E5%88%87%E6%8D%A2/"}]},{"title":"C#内存泄露","slug":"CSharp_OOM","date":"2022-01-03T04:31:19.000Z","updated":"2022-11-20T02:42:25.089Z","comments":true,"path":"2022/01/03/CSharp_OOM/","link":"","permalink":"https://blog.eganx.cn/2022/01/03/CSharp_OOM/","excerpt":"记录自己干的蠢事，这也是自己第一次在工作中写出来内存泄漏。幸亏程序没有直接上线，以后还是要多测试测试自己的代码。","text":"记录自己干的蠢事，这也是自己第一次在工作中写出来内存泄漏。幸亏程序没有直接上线，以后还是要多测试测试自己的代码。 0x0.问题产生原因在button1.Click += Button1_Click中，(+=) 来为事件附加事件处理程序 public Form1()&#123; InitializeComponent(); button1.Click += Button1_Click;&#125;private void Button1_Click(object sender, EventArgs e) &#123; System.Diagnostics.Debug.Print(&quot;x&quot;); &#125; public event EventHandler Click;public delegate void EventHandler(object sender, EventArgs e); 给button1_Click的附加事件处理程序放在了心跳里面； 此次溢出是因为每次心跳，又进行了一次事件处理程序的附加，造成不断附件事件处理程序。 直至最后，点击一次，要运行2K+次的事件处理程序。 而事件处理程序的代码里面会使用创建新的线程，运行一次，创建大量的新线程，线程数直接飙升，内存崩掉。 0x1.定位内存泄露发生的地方：C#的代码可以使用内存分析工具dotMemory。dotMemory允许你分析各种.NET和.NET Core应用程序的内存使用情况；比如桌面应用程序、Windows服务、ASP.NET Web应用程序、IIS、IIS Express、任意.NET进程等。不过临时用一下可以，有30天的试用期，还是比较好用的。 溢出版本源码示例: namespace WindowsFormsApp1&#123; public partial class Form1 : Form &#123; private static int i = 0; public Form1() &#123; InitializeComponent(); button1.Click += Button1_Click; &#125; private void Cycle() &#123; button1.Click += Button1_Click; &#125; private void Button1_Click(object sender, EventArgs e) &#123; i += 1; System.Diagnostics.Debug.Print(&quot;x:&#123;0&#125;&quot;,i); Cycle(); &#125; &#125;&#125; 正常版本源码示例： namespace WindowsFormsApp1&#123; public partial class Form1 : Form &#123; private static int i = 0; public Form1() &#123; InitializeComponent(); button1.Click += Button1_Click; &#125; private void Button1_Click(object sender, EventArgs e) &#123; i += 1; System.Diagnostics.Debug.Print(&quot;x:&#123;0&#125;&quot;,i); &#125; &#125;&#125;","categories":[{"name":"Work","slug":"Work","permalink":"https://blog.eganx.cn/categories/Work/"},{"name":"C#","slug":"Work/C","permalink":"https://blog.eganx.cn/categories/Work/C/"}],"tags":[{"name":"C#","slug":"C","permalink":"https://blog.eganx.cn/tags/C/"},{"name":"OOM","slug":"OOM","permalink":"https://blog.eganx.cn/tags/OOM/"}]},{"title":"C#串口读写连续性问题","slug":"CSharp_Serial_port_readwrite_continuity_problem","date":"2022-01-01T03:31:19.000Z","updated":"2022-11-20T02:42:29.078Z","comments":true,"path":"2022/01/01/CSharp_Serial_port_readwrite_continuity_problem/","link":"","permalink":"https://blog.eganx.cn/2022/01/01/CSharp_Serial_port_readwrite_continuity_problem/","excerpt":"在使用串口协议进行自定义协议读写的时候，一般使用Ascii编码。但是串口中读取到的数据并不能保证其完整性。一条指令有可能会被拆分成多条数据发送，读取到的字符串有可能只是其中的一部分。一般一条指令的末尾都会加上\\n\\r作为结束符。","text":"在使用串口协议进行自定义协议读写的时候，一般使用Ascii编码。但是串口中读取到的数据并不能保证其完整性。一条指令有可能会被拆分成多条数据发送，读取到的字符串有可能只是其中的一部分。一般一条指令的末尾都会加上\\n\\r作为结束符。 0x0.创建连接串口使用System.IO.Ports.SerialPort来创建连接 //// 摘要:// 使用指定的端口名、波特率、奇偶校验位、数据位和停止位初始化 System.IO.Ports.SerialPort 类的新实例。//// 参数:// portName:// 要使用的端口（例如 COM1）。//// baudRate:// 波特率。//// parity:// System.IO.Ports.SerialPort.Parity 值之一。//// dataBits:// 数据位值。//// stopBits:// System.IO.Ports.SerialPort.StopBits 值之一。//// 异常:// T:System.IO.IOException:// 未能找到或打开指定的端口。public SerialPort(string portName, int baudRate, Parity parity, int dataBits, StopBits stopBits); 其中Parity和StopBits的枚举分别为： //// 摘要:// 指定 System.IO.Ports.SerialPort 对象的奇偶校验位。public enum Parity&#123; // // 摘要: // 不发生奇偶校验检查。 None = 0, // // 摘要: // 设置奇偶校验位，使位数等于奇数。 Odd = 1, // // 摘要: // 设置奇偶校验位，使位数等于偶数。 Even = 2, // // 摘要: // 将奇偶校验位保留为 1。 Mark = 3, // // 摘要: // 将奇偶校验位保留为 0。 Space = 4&#125; //// 摘要:// 指定在 System.IO.Ports.SerialPort 对象上使用的停止位的数目。public enum StopBits&#123; // // 摘要: // 不使用停止位。 System.IO.Ports.SerialPort.StopBits 属性不支持此值。 None = 0, // // 摘要: // 使用一个停止位。 One = 1, // // 摘要: // 使用两个停止位。 Two = 2, // // 摘要: // 使用 1.5 个停止位。 OnePointFive = 3&#125; 连接完成后需要保证端口的开启，可使用IsOpen参数进行判定。 if (!Conn.IsOpen)&#123; Conn.Open();&#125; 0x1.数据的读写部分何时停止读写，可以根据NewLine的值进行判定。NewLine的默认值是”\\n”换行符，可以根据自己的需求进行更改。”\\r\\n”也是比较常用的NewLine。 //// 摘要:// 获取或设置用于解释 System.IO.Ports.SerialPort.ReadLine 和 System.IO.Ports.SerialPort.WriteLine(System.String)// 方法调用结束的值。//// 返回结果:// 表示行尾的值。 默认值为换行符，System.Environment.NewLine。//// 异常:// T:System.ArgumentException:// 属性值为空。//// T:System.ArgumentNullException:// 属性值为 null。[Browsable(false)][DefaultValue(&quot;\\n&quot;)][MonitoringDescription(&quot;NewLine&quot;)]public string NewLine &#123; get; set; &#125; 如果不想直接设置NewLine，也可以在读取串口数据时，根据自定义字符进行读取划分。 //// 摘要:// 一直读取到输入缓冲区中的指定 value 的字符串。//// 参数:// value:// 指示读取操作停止位置的值。//// 返回结果:// 输入缓冲区中直到指定 value 的内容。//// 异常:// T:System.ArgumentException:// value 参数的长度为 0。//// T:System.ArgumentNullException:// value 参数为 null。//// T:System.InvalidOperationException:// 指定的端口未打开。//// T:System.TimeoutException:// 该操作未在超时时间到期之前完成。public string ReadTo(string value); string reqStr = Conn.ReadTo(&quot;\\r\\n&quot;); 这样读取出来的数据就可以时一条条完整的指令，而不会出现被分隔的指令片段。","categories":[{"name":"Work","slug":"Work","permalink":"https://blog.eganx.cn/categories/Work/"},{"name":"C#","slug":"Work/C","permalink":"https://blog.eganx.cn/categories/Work/C/"}],"tags":[{"name":"C#","slug":"C","permalink":"https://blog.eganx.cn/tags/C/"},{"name":"Serial","slug":"Serial","permalink":"https://blog.eganx.cn/tags/Serial/"}]},{"title":"华为OD笔试","slug":"Huawei_OD_exam","date":"2021-03-09T03:30:12.000Z","updated":"2022-11-20T02:40:46.138Z","comments":true,"path":"2021/03/09/Huawei_OD_exam/","link":"","permalink":"https://blog.eganx.cn/2021/03/09/Huawei_OD_exam/","excerpt":"第一次参加华为OD的笔试，作为参加过精英笔试的优秀青年。我还是想记录一下的。说实话题目还行，但是裸考还是有点难度的(个人观点，或许是我菜的过分了)。","text":"第一次参加华为OD的笔试，作为参加过精英笔试的优秀青年。我还是想记录一下的。说实话题目还行，但是裸考还是有点难度的(个人观点，或许是我菜的过分了)。 0x0.第一题用一个数组A，代表程序员的工作能力。公司想通过结对编程的模式来提高员工的工作能力，假设成对后的能力是两个员工的能力之和，求一共有多少种结对方式，使结对后的能力为N。 提示： 1. 第一行代表员工个数2. 第二行代表各个员工的能力值3. 第三行代表结对后的能力值N4. 输出为结对的组合方式的值 示例： 输入：51 2 2 2 34输出：4 1).解题思路说实话这题放在华为OD的笔试里面，应该是属于送分题，一个输入数组加两层for循环直接解就行，直接附上代码就算了。 2).代码实现//// main.cpp// Demo//// Created by Egan.// #include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;numeric&gt;#include &lt;cctype&gt;using namespace std; int main() &#123; int n,N; int arr[1001]; int count =0; cin &gt;&gt; n; for(int i = 0; i &lt; n; i++)&#123; cin &gt;&gt; arr[i]; &#125; cin &gt;&gt; N; for(int x =0; x &lt; n; x++ )&#123; for(int y= x+1; y &lt;n; y++ )&#123; if(arr[x]+arr[y] == N) count += 1; &#125; &#125; cout &lt;&lt; count &lt;&lt;endl;&#125; 0x1.错误的里程表一个汽车里程表，它以整数形式显示行驶的英里数。然而，里程表有一个缺陷:它从数字3转到数字5，总是跳过数字4。这个缺陷出现在所有的位置(1,10,100，等等)。例如，如果里程表显示为15339，而汽车行驶了1英里，里程表的读数将更改为15350(而不是15340)。 提示： 1. 输入为里程表上的数值2. 输出为实际车子行驶的数值 示例： 输入1：5输出1：3输入2：17输出2：15输入3：100输出3：81 1).解题思路遇到4则直接从3进位到5，所以这是一道典型的进制转化问题，遍历该数字的每一位（如果这一位的数字比4大，就要减去1，因为这个位跳过了一个4），然后再遍历该数字的每一位，将其转化为10进制。 2).代码实现//// main.cpp// Demo//// Created by Egan.//#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;cstdio&gt;using namespace std;int main()&#123; string n; for (int i = 0;; i++) &#123; cin &gt;&gt; n; if(n[0] == &#x27;0&#x27;)&#123; break; &#125; int j = n.size; long long num = 0; ans = 1; for (int m = j-1; m &gt;= 0; m--) &#123; if((n[m]-&#x27;0&#x27;)&gt;4)&#123; num += ((n[m]-&#x27;0&#x27;)-1) * ans; &#125; else&#123; num += (n[m]-&#x27;0&#x27;) * ans; &#125; ans = ans * 9; &#125; cout &lt;&lt; n &lt;&lt; &quot;:&quot;&lt;&lt;num&lt;&lt;endl; &#125;&#125; 0x2.贪吃蛇算法题目太长，具体的记不清楚了，只能大致的描述一下。。。。 输入一个字符矩阵，其中字符E是食物(蛇吃了长度+1的那种)，F是空白，H是蛇的位置(初始只占一个位置) 移动指令有5种，分别让贪吃蛇移动以及转向：G前进、U往上转、D往下转、L往左转、R往右转（初始方向为左） 结束条件是碰壁或者碰到自己就算死了。 求按输入的指令执行之后的蛇的长度。 输入输出示例： 输入：D G G3F E FE E HF F F输出：1","categories":[{"name":"Work","slug":"Work","permalink":"https://blog.eganx.cn/categories/Work/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://blog.eganx.cn/tags/C/"},{"name":"华为OD","slug":"华为OD","permalink":"https://blog.eganx.cn/tags/%E5%8D%8E%E4%B8%BAOD/"},{"name":"笔试","slug":"笔试","permalink":"https://blog.eganx.cn/tags/%E7%AC%94%E8%AF%95/"}]},{"title":"基础计算器II (Basic calculator II)","slug":"Basic_calculator_II","date":"2021-03-02T02:22:11.000Z","updated":"2022-11-20T02:41:25.456Z","comments":true,"path":"2021/03/02/Basic_calculator_II/","link":"","permalink":"https://blog.eganx.cn/2021/03/02/Basic_calculator_II/","excerpt":"栈的经典应用： 给一个字符串表达式 s ，实现一个基本计算器来计算并返回它的值。(整数除法仅保留整数部分)","text":"栈的经典应用： 给一个字符串表达式 s ，实现一个基本计算器来计算并返回它的值。(整数除法仅保留整数部分) 提示： 1. 1 &lt;&#x3D; s.length &lt;&#x3D; 3 * 10^52. s 由整数和算符(&#39;+&#39;, &#39;-&#39;, &#39;*&#39;, &#39;&#x2F;&#39;)组成,中间由一些空格隔开3. s 表示一个有效表达式4. 表达式中的所有整数都是非负整数,且在范围[0, 231 - 1]内5. 题目数据保证答案是一个32-bit整数 示例： 输入：s &#x3D; &quot;3+2*2&quot;输出：7 0x0.解题思路栈的经典应用，此题没有括号，不需要进行括号匹配，相对来说简单一点，可以直接进行暴力求解。 需要考虑运算符的优先级问题。乘除的优先级大于加减，可以先进行乘除运算，用一个栈，保存进行乘除运算后的整数的值。对于加减号后的数字，将其直接压入栈中；对于乘除号后的数字，直接与栈顶元素计算，并替换栈顶元素为计算后的结果。 遍历字符串 s，并用变量preSign记录每个数字之前的运算符，对于第一个数字，其之前的运算符视为加号。遍历到运算符或者字符串最后一位时，根据preSign来决定计算方式: 加号：数字直接入栈； 减号：num变(-num)入栈； 乘除：num ( * or / ) stack.back()，并将栈顶元素替换为运算结果。 0x1.复杂度分析 时间复杂度：O(n)，其中n为字符串s的长度。需要遍历字符串s一次，计算表达式的值。 空间复杂度：O(n)，其中n为字符串s的长度。空间复杂度主要取决于栈的空间，栈的元素个数不超过n。 需要注意的是 在运算的时候，判断字符是数字还是运算符的时候，需要使用isdigit()函数，此函数包含在头文件#include &lt;cctype&gt;中。 运算的时候，如果遇到的数是大数(两位数及以上的)，需要进行处理。大数在字符串中是两个字符，需要在遍历字符串时，使用num = num * 10 + int (s[i] - &#39;0&#39;);对大数进行处理。 在乘除运算的结果都模拟入栈之后，使用累加函数accumulate(st.begin(), st.end(), 0);对数组进行累加处理，accumulate()函数包含在头文件#include &lt;numeric&gt;中，累加过程中，正负数都可以处理。 0x2.代码实现//// main.cpp// Demo//// Created by Egan.// #include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;numeric&gt;#include &lt;cctype&gt;using namespace std; int main() &#123; class Solution &#123; public: int calculate(string s) &#123; vector&lt;int&gt; st; //digits char ps = &#x27;+&#x27;; //presign int num = 0; for(int i = 0; i &lt; s.length(); i++)&#123; if (isdigit(s[i]))&#123; //#include &lt;cctype&gt; num = num * 10 + int (s[i] - &#x27;0&#x27;); &#125; if (!isdigit(s[i]) &amp;&amp; s[i] != &#x27; &#x27; || i == s.length()-1)&#123; switch(ps)&#123; case &#x27;+&#x27; : st.push_back(num); break; case &#x27;-&#x27; : st.push_back(-num); break; case &#x27;*&#x27; : st.back() *= num; break; case &#x27;/&#x27; : st.back() /= num; break; &#125; ps = s[i]; num = 0; &#125; &#125; return accumulate(st.begin(), st.end(), 0); //#include&lt;numeric&gt; &#125;&#125;;&#125;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://blog.eganx.cn/categories/Leetcode/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://blog.eganx.cn/tags/C/"},{"name":"栈","slug":"栈","permalink":"https://blog.eganx.cn/tags/%E6%A0%88/"}]},{"title":"逆波兰表示法(Reverse Polish notation)","slug":"Reverse Polish notation","date":"2021-03-01T08:12:14.000Z","updated":"2022-11-20T02:41:34.945Z","comments":true,"path":"2021/03/01/Reverse Polish notation/","link":"","permalink":"https://blog.eganx.cn/2021/03/01/Reverse%20Polish%20notation/","excerpt":"根据逆波兰表示法，求表达式的值。 有效的运算符包括 +, -, *, / 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。","text":"根据逆波兰表示法，求表达式的值。 有效的运算符包括 +, -, *, / 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。 0x0.解题思路逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。 逆波兰表达式主要有以下两个优点： 去掉括号后表达式无歧义，( 1 + 2 ) * ( 3 + 4 )即便写成 1 2 + 3 4 + * 也可以依据次序计算出正确结果。 适合用栈操作运算 逆波兰表达式的求解是栈的经典应用。所以此题采用栈来解决，遇到数字则入栈，遇到运算符则取出栈顶两个数字进行运算，并将结果压入栈中。 需要注意的是 在运算的时候，需要后取出的数字在前，先取出的数字在后，即num2在前。 stoi表示string to int，即字符串转整数 0x1.代码实现//// main.cpp// Demo//// Created by Egan.// #include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;stack&gt;#include &lt;cstring&gt;using namespace std; int main() &#123; class Solution &#123; public: int evalRPN(vector&lt;string&gt;&amp; tokens) &#123; stack&lt;int&gt; s; for(int i=0; i&lt;tokens.size(); i++)&#123; if(tokens[i] == &quot;+&quot;||tokens[i] == &quot;-&quot;||tokens[i] == &quot;*&quot;||tokens[i] == &quot;/&quot;)&#123; int num1 = s.top(); s.pop(); int num2 = s.top(); s.pop(); if(tokens[i] == &quot;+&quot;) s.push(num2 + num1); if(tokens[i] == &quot;-&quot;) s.push(num2 - num1); if(tokens[i] == &quot;*&quot;) s.push(num2 * num1); if(tokens[i] == &quot;/&quot;) s.push(num2 / num1); &#125; else &#123; s.push(stoi(tokens[i])); &#125; &#125; int result = s.top(); return result; &#125;&#125;;&#125;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://blog.eganx.cn/categories/Leetcode/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://blog.eganx.cn/tags/C/"},{"name":"栈","slug":"栈","permalink":"https://blog.eganx.cn/tags/%E6%A0%88/"}]},{"title":"明明的随机数(Ming's random numbers)","slug":"Ming's_random_numbers","date":"2021-02-22T05:46:57.000Z","updated":"2022-11-20T02:41:39.367Z","comments":true,"path":"2021/02/22/Ming's_random_numbers/","link":"","permalink":"https://blog.eganx.cn/2021/02/22/Ming's_random_numbers/","excerpt":"明明想在学校中请一些同学一起做一项问卷调查，为了实验的客观性，他先用计算机生成了N个1到1000之间的随机整数（N≤1000），对于其中重复的数字，只保留一个，把其余相同的数去掉，不同的数对应着不同的学生的学号。然后再把这些数从小到大排序，按照排好的顺序去找同学做调查。请你协助明明完成“去重”与“排序”的工作(同一个测试用例里可能会有多组数据(用于不同的调查)，希望大家能正确处理)","text":"明明想在学校中请一些同学一起做一项问卷调查，为了实验的客观性，他先用计算机生成了N个1到1000之间的随机整数（N≤1000），对于其中重复的数字，只保留一个，把其余相同的数去掉，不同的数对应着不同的学生的学号。然后再把这些数从小到大排序，按照排好的顺序去找同学做调查。请你协助明明完成“去重”与“排序”的工作(同一个测试用例里可能会有多组数据(用于不同的调查)，希望大家能正确处理) 0x0.解题思路这是华为的一道面试题。在原文中已经明确点出了所需的一些函数，分别是排序和去重。C++有现成的排序函数sort()，以及去重函数unique()。其中unique(),sort()都是属于头文件#include &lt;algorithm&gt; auto end_un = unique(vec.begin(),vec.end()); 这里的unique()返回的值是最后一个不重复数字的下标。 sort函数有三个参数： 第一个是要排序的数组的起始地址 第二个是结束的地址（最后一位要排序的地址) 第三个参数是排序的方法，可以是升序也可是降序。如果不写第三个参数，则默认的排序方法是升序排列 //升序sort( a, b, less&lt;int&gt;() ); //降序sort( a, b, greater&lt;int&gt;() ); 如果先去重再排序，那么去重就有可能不会发挥作用。因为去重再排序排序时会把重复的数字又放在了一起，所以要先排序再去重。 0x1.代码实现//// main.cpp// Demo//// Created by Egan.// #include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std; int main() &#123; int n= 0,num = 0; while (cin &gt;&gt; n) &#123; vector&lt;int&gt; vec; //input for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; num; vec.push_back(num); &#125; //sort sort(vec.begin(), vec.end()); //unique auto end_un = unique(vec.begin(),vec.end()); vec.erase(end_un, vec.end()); for (auto m = vec.begin(); m != vec.end(); m ++) &#123; cout &lt;&lt; *m &lt;&lt; endl; &#125; &#125; return 0;&#125;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://blog.eganx.cn/categories/Leetcode/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://blog.eganx.cn/tags/C/"},{"name":"sort","slug":"sort","permalink":"https://blog.eganx.cn/tags/sort/"},{"name":"unique","slug":"unique","permalink":"https://blog.eganx.cn/tags/unique/"}]},{"title":"毕业半年的自己","slug":"Six_months_after_graduation","date":"2020-12-22T05:46:57.000Z","updated":"2022-11-20T02:40:30.506Z","comments":true,"path":"2020/12/22/Six_months_after_graduation/","link":"","permalink":"https://blog.eganx.cn/2020/12/22/Six_months_after_graduation/","excerpt":"","text":"0x0.半年之后&emsp;我们这届的毕业生，大学只上了三年半，最后半年的时光都是在家里渡过。拿毕业证学位证、拍毕业照以及收拾行李，加起来不过两天时间。一切都是匆匆忙忙，匆忙到连一顿散伙饭都没法进行。&emsp;还差几日，自己也就毕业半年了，也算是有了半年的工作经验(划水经验)，学软件的我，毕业之后进了一家偏自动化的公司，工业4.0时代嘛，天天代码倒是不多，感觉还不错。","categories":[{"name":"工作","slug":"工作","permalink":"https://blog.eganx.cn/categories/%E5%B7%A5%E4%BD%9C/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.eganx.cn/tags/%E6%97%A5%E5%B8%B8/"},{"name":"杂记","slug":"杂记","permalink":"https://blog.eganx.cn/tags/%E6%9D%82%E8%AE%B0/"}]},{"title":"Test","slug":"firstPage","date":"2020-10-22T03:10:47.000Z","updated":"2022-01-20T11:36:20.632Z","comments":true,"path":"2020/10/22/firstPage/","link":"","permalink":"https://blog.eganx.cn/2020/10/22/firstPage/","excerpt":"","text":"测试文档 从这一篇测试文档开始，希望自己能够收起懒惰，重拾激情","categories":[],"tags":[{"name":"Test","slug":"Test","permalink":"https://blog.eganx.cn/tags/Test/"}]}],"categories":[{"name":"Work","slug":"Work","permalink":"https://blog.eganx.cn/categories/Work/"},{"name":"Leetcode","slug":"Leetcode","permalink":"https://blog.eganx.cn/categories/Leetcode/"},{"name":"Database","slug":"Database","permalink":"https://blog.eganx.cn/categories/Database/"},{"name":"Golang","slug":"Golang","permalink":"https://blog.eganx.cn/categories/Golang/"},{"name":"Tool","slug":"Tool","permalink":"https://blog.eganx.cn/categories/Tool/"},{"name":"C#","slug":"Work/C","permalink":"https://blog.eganx.cn/categories/Work/C/"},{"name":"工作","slug":"工作","permalink":"https://blog.eganx.cn/categories/%E5%B7%A5%E4%BD%9C/"}],"tags":[{"name":"Go","slug":"Go","permalink":"https://blog.eganx.cn/tags/Go/"},{"name":"面试","slug":"面试","permalink":"https://blog.eganx.cn/tags/%E9%9D%A2%E8%AF%95/"},{"name":"Leetcode","slug":"Leetcode","permalink":"https://blog.eganx.cn/tags/Leetcode/"},{"name":"hashmap","slug":"hashmap","permalink":"https://blog.eganx.cn/tags/hashmap/"},{"name":"DB","slug":"DB","permalink":"https://blog.eganx.cn/tags/DB/"},{"name":"lock","slug":"lock","permalink":"https://blog.eganx.cn/tags/lock/"},{"name":"concurrency consistency","slug":"concurrency-consistency","permalink":"https://blog.eganx.cn/tags/concurrency-consistency/"},{"name":"transaction","slug":"transaction","permalink":"https://blog.eganx.cn/tags/transaction/"},{"name":"GC","slug":"GC","permalink":"https://blog.eganx.cn/tags/GC/"},{"name":"go","slug":"go","permalink":"https://blog.eganx.cn/tags/go/"},{"name":"reflect","slug":"reflect","permalink":"https://blog.eganx.cn/tags/reflect/"},{"name":"mongo","slug":"mongo","permalink":"https://blog.eganx.cn/tags/mongo/"},{"name":"make","slug":"make","permalink":"https://blog.eganx.cn/tags/make/"},{"name":"new","slug":"new","permalink":"https://blog.eganx.cn/tags/new/"},{"name":"tool","slug":"tool","permalink":"https://blog.eganx.cn/tags/tool/"},{"name":"studio3t","slug":"studio3t","permalink":"https://blog.eganx.cn/tags/studio3t/"},{"name":"context","slug":"context","permalink":"https://blog.eganx.cn/tags/context/"},{"name":"channel","slug":"channel","permalink":"https://blog.eganx.cn/tags/channel/"},{"name":"interface","slug":"interface","permalink":"https://blog.eganx.cn/tags/interface/"},{"name":"map","slug":"map","permalink":"https://blog.eganx.cn/tags/map/"},{"name":"slice","slug":"slice","permalink":"https://blog.eganx.cn/tags/slice/"},{"name":"C#","slug":"C","permalink":"https://blog.eganx.cn/tags/C/"},{"name":"版本切换","slug":"版本切换","permalink":"https://blog.eganx.cn/tags/%E7%89%88%E6%9C%AC%E5%88%87%E6%8D%A2/"},{"name":"OOM","slug":"OOM","permalink":"https://blog.eganx.cn/tags/OOM/"},{"name":"Serial","slug":"Serial","permalink":"https://blog.eganx.cn/tags/Serial/"},{"name":"C++","slug":"C","permalink":"https://blog.eganx.cn/tags/C/"},{"name":"华为OD","slug":"华为OD","permalink":"https://blog.eganx.cn/tags/%E5%8D%8E%E4%B8%BAOD/"},{"name":"笔试","slug":"笔试","permalink":"https://blog.eganx.cn/tags/%E7%AC%94%E8%AF%95/"},{"name":"栈","slug":"栈","permalink":"https://blog.eganx.cn/tags/%E6%A0%88/"},{"name":"sort","slug":"sort","permalink":"https://blog.eganx.cn/tags/sort/"},{"name":"unique","slug":"unique","permalink":"https://blog.eganx.cn/tags/unique/"},{"name":"日常","slug":"日常","permalink":"https://blog.eganx.cn/tags/%E6%97%A5%E5%B8%B8/"},{"name":"杂记","slug":"杂记","permalink":"https://blog.eganx.cn/tags/%E6%9D%82%E8%AE%B0/"},{"name":"Test","slug":"Test","permalink":"https://blog.eganx.cn/tags/Test/"}]}