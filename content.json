{"meta":{"title":"DxBlog","subtitle":"一个人的小破站","description":"You are more than what you have become","author":"Egan Dong","url":"https://dxblog.top","root":"/"},"pages":[{"title":"标签","date":"2020-12-22T08:06:06.000Z","updated":"2020-12-22T08:07:11.761Z","comments":true,"path":"tags/index.html","permalink":"https://dxblog.top/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2020-12-22T08:07:23.000Z","updated":"2020-12-22T08:08:17.679Z","comments":true,"path":"categories/index.html","permalink":"https://dxblog.top/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2020-12-22T08:08:32.000Z","updated":"2020-12-22T08:09:05.029Z","comments":true,"path":"link/index.html","permalink":"https://dxblog.top/link/index.html","excerpt":"","text":""},{"title":"关于","date":"2020-12-22T08:06:06.000Z","updated":"2020-12-24T09:35:13.035Z","comments":true,"path":"about/index.html","permalink":"https://dxblog.top/about/index.html","excerpt":"","text":""}],"posts":[{"title":"基础计算器II (Basic calculator II)","slug":"Basic calculator II","date":"2021-03-02T02:22:11.000Z","updated":"2021-03-11T11:48:01.148Z","comments":true,"path":"2021/03/02/Basic calculator II/","link":"","permalink":"https://dxblog.top/2021/03/02/Basic%20calculator%20II/","excerpt":"","text":"基础计算器II (Basic calculator II)题目描述给一个字符串表达式 s ，实现一个基本计算器来计算并返回它的值。(整数除法仅保留整数部分) 提示： 1. 1 &lt;&#x3D; s.length &lt;&#x3D; 3 * 10^52. s 由整数和算符(&#39;+&#39;, &#39;-&#39;, &#39;*&#39;, &#39;&#x2F;&#39;)组成,中间由一些空格隔开3. s 表示一个有效表达式4. 表达式中的所有整数都是非负整数,且在范围[0, 231 - 1]内5. 题目数据保证答案是一个32-bit整数 示例： 输入：s &#x3D; &quot;3+2*2&quot;输出：7 解题思路栈的经典应用，此题没有括号，不需要进行括号匹配，相对来说简单一点，可以直接进行暴力求解。 需要考虑运算符的优先级问题。乘除的优先级大于加减，可以先进行乘除运算，用一个栈，保存进行乘除运算后的整数的值。对于加减号后的数字，将其直接压入栈中；对于乘除号后的数字，直接与栈顶元素计算，并替换栈顶元素为计算后的结果。 遍历字符串 s，并用变量preSign记录每个数字之前的运算符，对于第一个数字，其之前的运算符视为加号。遍历到运算符或者字符串最后一位时，根据preSign来决定计算方式: 加号：数字直接入栈； 减号：num变(-num)入栈； 乘除：num ( * or / ) stack.back()，并将栈顶元素替换为运算结果。 复杂度分析 时间复杂度：O(n)，其中n为字符串s的长度。需要遍历字符串s一次，计算表达式的值。 空间复杂度：O(n)，其中n为字符串s的长度。空间复杂度主要取决于栈的空间，栈的元素个数不超过n。 需要注意的是 在运算的时候，判断字符是数字还是运算符的时候，需要使用isdigit()函数，此函数包含在头文件#include &lt;cctype&gt;中。 运算的时候，如果遇到的数是大数(两位数及以上的)，需要进行处理。大数在字符串中是两个字符，需要在遍历字符串时，使用num = num * 10 + int (s[i] - &#39;0&#39;);对大数进行处理。 在乘除运算的结果都模拟入栈之后，使用累加函数accumulate(st.begin(), st.end(), 0);对数组进行累加处理，accumulate()函数包含在头文件#include &lt;numeric&gt;中，累加过程中，正负数都可以处理。 //// main.cpp// Demo//// Created by Egan.// #include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;numeric&gt;#include &lt;cctype&gt;using namespace std; int main() &#123; class Solution &#123; public: int calculate(string s) &#123; vector&lt;int&gt; st; //digits char ps = &#x27;+&#x27;; //presign int num = 0; for(int i = 0; i &lt; s.length(); i++)&#123; if (isdigit(s[i]))&#123; //#include &lt;cctype&gt; num = num * 10 + int (s[i] - &#x27;0&#x27;); &#125; if (!isdigit(s[i]) &amp;&amp; s[i] != &#x27; &#x27; || i == s.length()-1)&#123; switch(ps)&#123; case &#x27;+&#x27; : st.push_back(num); break; case &#x27;-&#x27; : st.push_back(-num); break; case &#x27;*&#x27; : st.back() *= num; break; case &#x27;/&#x27; : st.back() /= num; break; &#125; ps = s[i]; num = 0; &#125; &#125; return accumulate(st.begin(), st.end(), 0); //#include&lt;numeric&gt; &#125;&#125;;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://dxblog.top/categories/%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"算法/Leetcode","permalink":"https://dxblog.top/categories/%E7%AE%97%E6%B3%95/Leetcode/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://dxblog.top/tags/%E6%97%A5%E5%B8%B8/"},{"name":"C++","slug":"C","permalink":"https://dxblog.top/tags/C/"},{"name":"Leetcode","slug":"Leetcode","permalink":"https://dxblog.top/tags/Leetcode/"},{"name":"栈","slug":"栈","permalink":"https://dxblog.top/tags/%E6%A0%88/"}]},{"title":"逆波兰表示法(Reverse Polish notation)","slug":"Reverse Polish notation","date":"2021-03-01T08:12:14.000Z","updated":"2021-03-10T14:03:18.276Z","comments":true,"path":"2021/03/01/Reverse Polish notation/","link":"","permalink":"https://dxblog.top/2021/03/01/Reverse%20Polish%20notation/","excerpt":"","text":"逆波兰表示法(Reverse Polish notation)题目描述根据逆波兰表示法，求表达式的值。 有效的运算符包括 +, -, *, / 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。 逆波兰表达式主要有以下两个优点： 去掉括号后表达式无歧义，( 1 + 2 ) * ( 3 + 4 )即便写成 1 2 + 3 4 + * 也可以依据次序计算出正确结果。 适合用栈操作运算 解题思路逆波兰表达式的求解是栈的经典应用。所以此题采用栈来解决，遇到数字则入栈，遇到运算符则取出栈顶两个数字进行运算，并将结果压入栈中。 需要注意的是 在运算的时候，需要后取出的数字在前，先取出的数字在后，即num2在前。 stoi表示string to int，即字符串转整数 //// main.cpp// Demo//// Created by Egan.// #include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;stack&gt;#include &lt;cstring&gt;using namespace std; int main() &#123; class Solution &#123; public: int evalRPN(vector&lt;string&gt;&amp; tokens) &#123; stack&lt;int&gt; s; for(int i=0; i&lt;tokens.size(); i++)&#123; if(tokens[i] == &quot;+&quot;||tokens[i] == &quot;-&quot;||tokens[i] == &quot;*&quot;||tokens[i] == &quot;/&quot;)&#123; int num1 = s.top(); s.pop(); int num2 = s.top(); s.pop(); if(tokens[i] == &quot;+&quot;) s.push(num2 + num1); if(tokens[i] == &quot;-&quot;) s.push(num2 - num1); if(tokens[i] == &quot;*&quot;) s.push(num2 * num1); if(tokens[i] == &quot;/&quot;) s.push(num2 / num1); &#125; else &#123; s.push(stoi(tokens[i])); &#125; &#125; int result = s.top(); return result; &#125;&#125;;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://dxblog.top/categories/%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"算法/Leetcode","permalink":"https://dxblog.top/categories/%E7%AE%97%E6%B3%95/Leetcode/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://dxblog.top/tags/%E6%97%A5%E5%B8%B8/"},{"name":"C++","slug":"C","permalink":"https://dxblog.top/tags/C/"},{"name":"Leetcode","slug":"Leetcode","permalink":"https://dxblog.top/tags/Leetcode/"},{"name":"Reverse Polish notation","slug":"Reverse-Polish-notation","permalink":"https://dxblog.top/tags/Reverse-Polish-notation/"}]},{"title":"Ming's random numbers","slug":"Ming's random numbers","date":"2021-02-22T05:46:57.000Z","updated":"2021-03-10T14:02:51.371Z","comments":true,"path":"2021/02/22/Ming's random numbers/","link":"","permalink":"https://dxblog.top/2021/02/22/Ming's%20random%20numbers/","excerpt":"","text":"明明的随机数明明想在学校中请一些同学一起做一项问卷调查，为了实验的客观性，他先用计算机生成了N个1到1000之间的随机整数（N≤1000），对于其中重复的数字，只保留一个，把其余相同的数去掉，不同的数对应着不同的学生的学号。然后再把这些数从小到大排序，按照排好的顺序去找同学做调查。请你协助明明完成“去重”与“排序”的工作(同一个测试用例里可能会有多组数据(用于不同的调查)，希望大家能正确处理) 这是华为的一道面试题。在原文中已经明确点出了所需的一些函数，分别是排序和去重。C++有现成的排序函数sort()，以及去重函数unique()。其中unique(),sort()都是属于头文件#include &lt;algorithm&gt; auto end_un = unique(vec.begin(),vec.end()); 这里的unique()返回的值是最后一个不重复数字的下标。 sort函数有三个参数： 第一个是要排序的数组的起始地址 第二个是结束的地址（最后一位要排序的地址) 第三个参数是排序的方法，可以是升序也可是降序。如果不写第三个参数，则默认的排序方法是升序排列 //升序sort( a, b, less&lt;int&gt;() ); //降序sort( a, b, greater&lt;int&gt;() ); 如果先去重再排序，那么去重就有可能不会发挥作用。因为去重再排序排序时会把重复的数字又放在了一起，所以要先排序再去重。 //// main.cpp// Demo//// Created by Egan.// #include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std; int main() &#123; int n= 0,num = 0; while (cin &gt;&gt; n) &#123; vector&lt;int&gt; vec; //input for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; num; vec.push_back(num); &#125; //sort sort(vec.begin(), vec.end()); //unique auto end_un = unique(vec.begin(),vec.end()); vec.erase(end_un, vec.end()); for (auto m = vec.begin(); m != vec.end(); m ++) &#123; cout &lt;&lt; *m &lt;&lt; endl; &#125; &#125; return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://dxblog.top/categories/%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"算法/Leetcode","permalink":"https://dxblog.top/categories/%E7%AE%97%E6%B3%95/Leetcode/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://dxblog.top/tags/%E6%97%A5%E5%B8%B8/"},{"name":"C++","slug":"C","permalink":"https://dxblog.top/tags/C/"},{"name":"sort","slug":"sort","permalink":"https://dxblog.top/tags/sort/"},{"name":"unique","slug":"unique","permalink":"https://dxblog.top/tags/unique/"},{"name":"Leetcode","slug":"Leetcode","permalink":"https://dxblog.top/tags/Leetcode/"}]},{"title":"毕业半年的自己","slug":"Six_months_after_graduation","date":"2020-12-22T05:46:57.000Z","updated":"2021-03-04T12:09:00.080Z","comments":true,"path":"2020/12/22/Six_months_after_graduation/","link":"","permalink":"https://dxblog.top/2020/12/22/Six_months_after_graduation/","excerpt":"","text":"半年之后&emsp;我们这届的毕业生，大学只上了三年半，最后半年的时光都是在家里渡过。拿毕业证学位证、拍毕业照以及收拾行李，加起来不过两天时间。一切都是匆匆忙忙，匆忙到连一顿散伙饭都没法进行。&emsp;还差几日，自己也就毕业半年了，也算是有了半年的工作经验(划水经验)，学软件的我，毕业之后进了一家偏自动化的公司，工业4.0时代嘛，天天代码倒是不多，就是比较累。","categories":[{"name":"日常","slug":"日常","permalink":"https://dxblog.top/categories/%E6%97%A5%E5%B8%B8/"},{"name":"工作","slug":"日常/工作","permalink":"https://dxblog.top/categories/%E6%97%A5%E5%B8%B8/%E5%B7%A5%E4%BD%9C/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://dxblog.top/tags/%E6%97%A5%E5%B8%B8/"},{"name":"杂记","slug":"杂记","permalink":"https://dxblog.top/tags/%E6%9D%82%E8%AE%B0/"}]},{"title":"Test","slug":"firstPage","date":"2020-10-22T03:10:47.000Z","updated":"2021-03-04T11:56:58.360Z","comments":true,"path":"2020/10/22/firstPage/","link":"","permalink":"https://dxblog.top/2020/10/22/firstPage/","excerpt":"","text":"测试文档 从这一篇测试文档开始，希望自己能够收起懒惰，重拾激情","categories":[],"tags":[{"name":"Test","slug":"Test","permalink":"https://dxblog.top/tags/Test/"}]}],"categories":[{"name":"算法","slug":"算法","permalink":"https://dxblog.top/categories/%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"算法/Leetcode","permalink":"https://dxblog.top/categories/%E7%AE%97%E6%B3%95/Leetcode/"},{"name":"日常","slug":"日常","permalink":"https://dxblog.top/categories/%E6%97%A5%E5%B8%B8/"},{"name":"工作","slug":"日常/工作","permalink":"https://dxblog.top/categories/%E6%97%A5%E5%B8%B8/%E5%B7%A5%E4%BD%9C/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://dxblog.top/tags/%E6%97%A5%E5%B8%B8/"},{"name":"C++","slug":"C","permalink":"https://dxblog.top/tags/C/"},{"name":"Leetcode","slug":"Leetcode","permalink":"https://dxblog.top/tags/Leetcode/"},{"name":"栈","slug":"栈","permalink":"https://dxblog.top/tags/%E6%A0%88/"},{"name":"Reverse Polish notation","slug":"Reverse-Polish-notation","permalink":"https://dxblog.top/tags/Reverse-Polish-notation/"},{"name":"sort","slug":"sort","permalink":"https://dxblog.top/tags/sort/"},{"name":"unique","slug":"unique","permalink":"https://dxblog.top/tags/unique/"},{"name":"杂记","slug":"杂记","permalink":"https://dxblog.top/tags/%E6%9D%82%E8%AE%B0/"},{"name":"Test","slug":"Test","permalink":"https://dxblog.top/tags/Test/"}]}