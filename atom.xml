<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Egan&#39;s Blog</title>
  
  <subtitle>The winter is coming</subtitle>
  <link href="https://blog.eganx.cn/atom.xml" rel="self"/>
  
  <link href="https://blog.eganx.cn/"/>
  <updated>2023-03-07T06:48:18.860Z</updated>
  <id>https://blog.eganx.cn/</id>
  
  <author>
    <name>Egan Dong</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>1. 两数之和</title>
    <link href="https://blog.eganx.cn/2023/02/04/1.%20Two_sum/"/>
    <id>https://blog.eganx.cn/2023/02/04/1.%20Two_sum/</id>
    <published>2023-02-04T14:22:11.000Z</published>
    <updated>2023-03-07T06:48:18.860Z</updated>
    
    <content type="html"><![CDATA[<p>链接： <a href="https://leetcode.cn/problems/two-sum">https://leetcode.cn/problems/two-sum</a></p><h3 id="0x0-题目描述"><a href="#0x0-题目描述" class="headerlink" title="0x0. 题目描述"></a>0x0. 题目描述</h3><p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p><p>你可以按任意顺序返回答案。</p><span id="more"></span><h3 id="0x1-示例"><a href="#0x1-示例" class="headerlink" title="0x1. 示例"></a>0x1. 示例</h3><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [2,7,11,15], target &#x3D; 9</span><br><span class="line">输出：[0,1]</span><br><span class="line">解释：因为 nums[0] + nums[1] &#x3D;&#x3D; 9 ，返回 [0, 1] 。</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [3,2,4], target &#x3D; 6</span><br><span class="line">输出：[1,2]</span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [3,3], target &#x3D; 6</span><br><span class="line">输出：[0,1]</span><br></pre></td></tr></table></figure><h3 id="0x2-提示："><a href="#0x2-提示：" class="headerlink" title="0x2. 提示："></a>0x2. 提示：</h3><ul><li><code>2 &lt;= nums.length &lt;= 104</code></li><li><code>-109 &lt;= nums[i] &lt;= 109</code></li><li><code>-109 &lt;= target &lt;= 109</code></li><li>只会存在一个有效答案</li></ul><h3 id="0x3-解题思路："><a href="#0x3-解题思路：" class="headerlink" title="0x3. 解题思路："></a>0x3. 解题思路：</h3><ol><li> 创建一个哈希表 <code>map</code>，用于存储数组中每个数对应的索引。</li><li> 遍历数组 <code>nums</code>，检查当前数字 <code>num</code> 的补数 <code>complement</code> 是否在哈希表中出现过（即是否满足 <code>complement = target - num</code>），如果是，则说明已经找到了答案，返回两个数的索引；否则，将当前数字和它的索引加入哈希表中。</li><li> 如果遍历完整个数组都没有找到符合条件的数对，则说明不存在这样的两个数，返回空数组或者抛出异常。</li></ol><h3 id="0x4-Go-语言实现的代码示例："><a href="#0x4-Go-语言实现的代码示例：" class="headerlink" title="0x4. Go 语言实现的代码示例："></a>0x4. Go 语言实现的代码示例：</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">twoSum</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>) <span class="comment">// 创建哈希表</span></span><br><span class="line">    <span class="keyword">for</span> i, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        complement := target - num</span><br><span class="line">        <span class="keyword">if</span> j, ok := m[complement]; ok &#123; <span class="comment">// 如果哈希表中已经存在 complement，则说明找到了答案</span></span><br><span class="line">            <span class="keyword">return</span> []<span class="keyword">int</span>&#123;j, i&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        m[num] = i <span class="comment">// 将当前数字和它的索引加入哈希表中</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span> <span class="comment">// 如果遍历完整个数组都没有找到符合条件的数对，则返回空数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度为 O(n)，空间复杂度为 O(n)。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;链接： &lt;a href=&quot;https://leetcode.cn/problems/two-sum&quot;&gt;https://leetcode.cn/problems/two-sum&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;0x0-题目描述&quot;&gt;&lt;a href=&quot;#0x0-题目描述&quot; class=&quot;headerlink&quot; title=&quot;0x0. 题目描述&quot;&gt;&lt;/a&gt;0x0. 题目描述&lt;/h3&gt;&lt;p&gt;给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。&lt;/p&gt;
&lt;p&gt;你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。&lt;/p&gt;
&lt;p&gt;你可以按任意顺序返回答案。&lt;/p&gt;</summary>
    
    
    
    <category term="Leetcode" scheme="https://blog.eganx.cn/categories/Leetcode/"/>
    
    
    <category term="Go" scheme="https://blog.eganx.cn/tags/Go/"/>
    
    <category term="Leetcode" scheme="https://blog.eganx.cn/tags/Leetcode/"/>
    
    <category term="hashmap" scheme="https://blog.eganx.cn/tags/hashmap/"/>
    
  </entry>
  
  <entry>
    <title>202.快乐数</title>
    <link href="https://blog.eganx.cn/2023/02/04/202.%20Happy_number/"/>
    <id>https://blog.eganx.cn/2023/02/04/202.%20Happy_number/</id>
    <published>2023-02-04T14:22:11.000Z</published>
    <updated>2023-03-07T06:48:17.992Z</updated>
    
    <content type="html"><![CDATA[<p>链接： <a href="https://leetcode.cn/problems/happy-number">https://leetcode.cn/problems/happy-number</a></p><h3 id="0x0-题目描述"><a href="#0x0-题目描述" class="headerlink" title="0x0. 题目描述"></a>0x0. 题目描述</h3><p>编写一个算法来判断一个数 n 是不是快乐数。</p><p>「快乐数」 定义为：</p><ul><li>对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。</li><li>然后重复这个过程直到这个数变为 1，也可能是 <strong>无限循环</strong> 但始终变不到 1。</li><li>如果这个过程 <strong>结果为 1</strong>，那么这个数就是快乐数。</li></ul><p>如果 n 是 快乐数 就返回 true ；不是，则返回 false 。</p><span id="more"></span><h3 id="0x1-示例"><a href="#0x1-示例" class="headerlink" title="0x1. 示例"></a>0x1. 示例</h3><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 19</span><br><span class="line">输出：true</span><br><span class="line">解释：</span><br><span class="line">12 + 92 &#x3D; 82</span><br><span class="line">82 + 22 &#x3D; 68</span><br><span class="line">62 + 82 &#x3D; 100</span><br><span class="line">12 + 02 + 02 &#x3D; 1</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 2</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><h3 id="0x2-提示"><a href="#0x2-提示" class="headerlink" title="0x2. 提示"></a>0x2. 提示</h3><ul><li>1 &lt;= n &lt;= 231 - 1</li></ul><h3 id="0x3-解题思路："><a href="#0x3-解题思路：" class="headerlink" title="0x3. 解题思路："></a>0x3. 解题思路：</h3><ol><li> 定义一个哈希集合 <code>seen</code>，用于记录每次计算的结果。</li><li> 从输入数字 n 开始，计算其每个数位的平方和，并将结果存入变量 <code>sum</code> 中。例如，对于数字 n=19，计算过程为：1² + 9² = 82。</li><li> 检查 <code>sum</code> 是否等于 1。如果是，则说明 n 是快乐数，返回 true；如果不是，则检查 <code>sum</code> 是否在 <code>seen</code> 集合中出现过。如果是，则说明已经进入了循环，n 不是快乐数，返回 false。如果不是，则将 <code>sum</code> 加入集合 <code>seen</code> 中，并更新 n 的值为 <code>sum</code>，继续进行下一轮计算。</li><li> 重复步骤 2-3 直到找到答案或者进入循环。</li></ol><h3 id="0x4-Go-语言实现的代码示例："><a href="#0x4-Go-语言实现的代码示例：" class="headerlink" title="0x4. Go 语言实现的代码示例："></a>0x4. Go 语言实现的代码示例：</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isHappy</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    seen := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">bool</span>) <span class="comment">// 创建哈希集合</span></span><br><span class="line">    <span class="keyword">for</span> n != <span class="number">1</span> &amp;&amp; !seen[n] &#123;   <span class="comment">// 判断是否已经找到答案或者进入循环</span></span><br><span class="line">        seen[n] = <span class="literal">true</span>         <span class="comment">// 将当前数加入哈希集合</span></span><br><span class="line">        sum := <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> n &gt; <span class="number">0</span> &#123;            <span class="comment">// 计算每个数位的平方和</span></span><br><span class="line">            digit := n % <span class="number">10</span></span><br><span class="line">            sum += digit * digit</span><br><span class="line">            n /= <span class="number">10</span></span><br><span class="line">        &#125;</span><br><span class="line">        n = sum                <span class="comment">// 更新 n 的值为平方和</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n == <span class="number">1</span>             <span class="comment">// 如果最终得到 1，则说明是快乐数；否则不是</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度为 O(log n)，空间复杂度为 O(log n)。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;链接： &lt;a href=&quot;https://leetcode.cn/problems/happy-number&quot;&gt;https://leetcode.cn/problems/happy-number&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;0x0-题目描述&quot;&gt;&lt;a href=&quot;#0x0-题目描述&quot; class=&quot;headerlink&quot; title=&quot;0x0. 题目描述&quot;&gt;&lt;/a&gt;0x0. 题目描述&lt;/h3&gt;&lt;p&gt;编写一个算法来判断一个数 n 是不是快乐数。&lt;/p&gt;
&lt;p&gt;「快乐数」 定义为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。&lt;/li&gt;
&lt;li&gt;然后重复这个过程直到这个数变为 1，也可能是 &lt;strong&gt;无限循环&lt;/strong&gt; 但始终变不到 1。&lt;/li&gt;
&lt;li&gt;如果这个过程 &lt;strong&gt;结果为 1&lt;/strong&gt;，那么这个数就是快乐数。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果 n 是 快乐数 就返回 true ；不是，则返回 false 。&lt;/p&gt;</summary>
    
    
    
    <category term="Leetcode" scheme="https://blog.eganx.cn/categories/Leetcode/"/>
    
    
    <category term="Go" scheme="https://blog.eganx.cn/tags/Go/"/>
    
    <category term="Leetcode" scheme="https://blog.eganx.cn/tags/Leetcode/"/>
    
    <category term="hashmap" scheme="https://blog.eganx.cn/tags/hashmap/"/>
    
  </entry>
  
  <entry>
    <title>349. 两个数组的交集</title>
    <link href="https://blog.eganx.cn/2023/02/04/349.%20intersection_of_two_arrays/"/>
    <id>https://blog.eganx.cn/2023/02/04/349.%20intersection_of_two_arrays/</id>
    <published>2023-02-04T14:22:11.000Z</published>
    <updated>2023-03-07T06:48:16.382Z</updated>
    
    <content type="html"><![CDATA[<p>链接： <a href="https://leetcode.cn/problems/intersection-of-two-arrays">https://leetcode.cn/problems/intersection-of-two-arrays</a></p><h3 id="0x0-题目描述"><a href="#0x0-题目描述" class="headerlink" title="0x0. 题目描述"></a>0x0. 题目描述</h3><p>给定两个数组 nums1 和 nums2 ，返回 它们的交集 。输出结果中的每个元素一定是 唯一 的。我们可以 不考虑输出结果的顺序 。</p><span id="more"></span><h3 id="0x1-示例"><a href="#0x1-示例" class="headerlink" title="0x1. 示例"></a>0x1. 示例</h3><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums1 &#x3D; [1,2,2,1], nums2 &#x3D; [2,2]</span><br><span class="line">输出：[2]</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums1 &#x3D; [4,9,5], nums2 &#x3D; [9,4,9,8,4]</span><br><span class="line">输出：[9,4]</span><br><span class="line">解释：[4,9] 也是可通过的</span><br></pre></td></tr></table></figure><h3 id="0x2-提示"><a href="#0x2-提示" class="headerlink" title="0x2. 提示"></a>0x2. 提示</h3><ul><li><code>1 &lt;= nums1.length, nums2.length &lt;= 1000</code></li><li><code>0 &lt;= nums1[i], nums2[i] &lt;= 1000</code></li></ul><h3 id="0x3-解题思路"><a href="#0x3-解题思路" class="headerlink" title="0x3. 解题思路"></a>0x3. 解题思路</h3><ol><li> 创建一个空的切片 <code>res</code> 和一个空的哈希表 <code>set</code>。</li><li> 遍历数组 <code>nums1</code> 中的每个元素 <code>v</code>，如果 <code>v</code> 在哈希表 <code>set</code> 中不存在，则将其加入哈希表中。</li><li> 遍历数组 <code>nums2</code> 中的每个元素 <code>v</code>，如果 <code>v</code> 在哈希表 <code>set</code> 中存在，则将其加入切片 <code>res</code> 中，并从哈希表 <code>set</code> 中删除。</li><li> 返回切片 <code>res</code>。</li></ol><h3 id="0x4-Go-语言实现的代码示例："><a href="#0x4-Go-语言实现的代码示例：" class="headerlink" title="0x4. Go 语言实现的代码示例："></a>0x4. Go 语言实现的代码示例：</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">intersection</span><span class="params">(nums1 []<span class="keyword">int</span>, nums2 []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">res := <span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">0</span>)</span><br><span class="line">set := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">interface</span>&#123;&#125;,<span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> nums1 &#123;</span><br><span class="line"><span class="keyword">if</span> _, ok := set[v]; !ok&#123;</span><br><span class="line">set[v] = v <span class="comment">//赋值随意，只要后面能取到东西就行</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> nums2 &#123;</span><br><span class="line"><span class="keyword">if</span> _, ok := set[v]; ok&#123;</span><br><span class="line">res = <span class="built_in">append</span>(res, v)</span><br><span class="line"><span class="built_in">delete</span>(set,v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用哈希表来记录一个数组中的元素，然后遍历另一个数组，找到其中在哈希表中出现过的元素。实现用一个接口类型来占据值的位置，只关注 key 的存在，而不关心具体的 value 值。</li><li>时间复杂度为 O(m+n)，空间复杂度为 O(min(m,n))，其中 m 和 n 分别为两个数组的长度。但需要注意的是，由于哈希表的散列函数可能会产生冲突，因此在极端情况下，时间复杂度可能会退化为 O(m * n)。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;链接： &lt;a href=&quot;https://leetcode.cn/problems/intersection-of-two-arrays&quot;&gt;https://leetcode.cn/problems/intersection-of-two-arrays&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;0x0-题目描述&quot;&gt;&lt;a href=&quot;#0x0-题目描述&quot; class=&quot;headerlink&quot; title=&quot;0x0. 题目描述&quot;&gt;&lt;/a&gt;0x0. 题目描述&lt;/h3&gt;&lt;p&gt;给定两个数组 nums1 和 nums2 ，返回 它们的交集 。输出结果中的每个元素一定是 唯一 的。我们可以 不考虑输出结果的顺序 。&lt;/p&gt;</summary>
    
    
    
    <category term="Leetcode" scheme="https://blog.eganx.cn/categories/Leetcode/"/>
    
    
    <category term="Go" scheme="https://blog.eganx.cn/tags/Go/"/>
    
    <category term="Leetcode" scheme="https://blog.eganx.cn/tags/Leetcode/"/>
    
    <category term="hashmap" scheme="https://blog.eganx.cn/tags/hashmap/"/>
    
  </entry>
  
  <entry>
    <title>383. 赎金信</title>
    <link href="https://blog.eganx.cn/2023/02/04/383.%20ransom_note/"/>
    <id>https://blog.eganx.cn/2023/02/04/383.%20ransom_note/</id>
    <published>2023-02-04T14:22:11.000Z</published>
    <updated>2023-03-07T06:48:15.114Z</updated>
    
    <content type="html"><![CDATA[<p>链接： <a href="https://leetcode.cn/problems/ransom-note">https://leetcode.cn/problems/ransom-note</a></p><h3 id="0x0-题目描述"><a href="#0x0-题目描述" class="headerlink" title="0x0. 题目描述"></a>0x0. 题目描述</h3><p>给你两个字符串：ransomNote 和 magazine ，判断 ransomNote 能不能由 magazine 里面的字符构成。</p><p>如果可以，返回 true ；否则返回 false 。</p><p>magazine 中的每个字符只能在 ransomNote 中使用一次。</p><span id="more"></span><h3 id="0x1-示例"><a href="#0x1-示例" class="headerlink" title="0x1. 示例"></a>0x1. 示例</h3><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：ransomNote &#x3D; &quot;a&quot;, magazine &#x3D; &quot;b&quot;</span><br><span class="line">输出：false</span><br><span class="line">示例 2：</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：ransomNote &#x3D; &quot;aa&quot;, magazine &#x3D; &quot;ab&quot;</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：ransomNote &#x3D; &quot;aa&quot;, magazine &#x3D; &quot;aab&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><h3 id="0x2-提示"><a href="#0x2-提示" class="headerlink" title="0x2. 提示"></a>0x2. 提示</h3><ul><li><code>1 &lt;= ransomNote.length, magazine.length &lt;= 105</code></li><li><code>ransomNote 和 magazine 由小写英文字母组成</code></li></ul><h3 id="0x3-解题思路1"><a href="#0x3-解题思路1" class="headerlink" title="0x3. 解题思路1"></a>0x3. 解题思路1</h3><ol><li> 创建一个长度为 27（26 个小写字母加一个边界值）的整型数组 <code>ml</code>，用于记录 magazine 中每个字符出现的次数。</li><li> 遍历字符串 <code>magazine</code> 中的每个字符 <code>v</code>，将 <code>ml[v-&#39;a&#39;]</code> 的值加 1，表示字符 <code>v</code> 出现了一次。</li><li> 遍历字符串 <code>ransomNote</code> 中的每个字符 <code>vv</code>，将 <code>ml[vv-&#39;a&#39;]</code> 的值减 1，表示字符 <code>vv</code> 在 <code>magazine</code> 中被使用了一次。如果 <code>ml[vv-&#39;a&#39;]</code> 的值小于 0，则说明 <code>ranasomNote</code> 中出现了一个 <code>magazine</code> 中没有的字符，返回 false。</li><li> 如果遍历完整个 <code>ransomNote</code> 后都没有返回 false，则说明可以由 <code>magazine</code> 构成，返回 true。</li></ol><h3 id="0x3-解题思路2"><a href="#0x3-解题思路2" class="headerlink" title="0x3. 解题思路2"></a>0x3. 解题思路2</h3><ol><li> 创建一个哈希表 <code>mag</code>，用于记录 magazine 中每个字符出现的次数。</li><li> 遍历 ransomNote 中的每个字符，检查它是否在哈希表 <code>mag</code> 中出现过。如果没有出现过，则说明不能由 magazine 构成，返回 false；如果出现过，则将该字符对应的计数减 1。</li><li> 如果遍历完整个 ransomNote 都没有返回 false，则说明可以由 magazine 构成，返回 true。</li></ol><h3 id="0x4-Go-语言实现的代码示例1："><a href="#0x4-Go-语言实现的代码示例1：" class="headerlink" title="0x4. Go 语言实现的代码示例1："></a>0x4. Go 语言实现的代码示例1：</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canConstruct</span><span class="params">(ransomNote <span class="keyword">string</span>, magazine <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">ml := <span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">27</span>)</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> magazine &#123;</span><br><span class="line">ml[v-<span class="string">&#x27;a&#x27;</span>]++</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, vv := <span class="keyword">range</span> ransomNote &#123;</span><br><span class="line">ml[vv-<span class="string">&#x27;a&#x27;</span>]--</span><br><span class="line"><span class="keyword">if</span> ml[vv-<span class="string">&#x27;a&#x27;</span>] &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用两个数组来分别记录两个字符串中每个字符出现的次数。由于只需要遍历两个字符串各一遍，因此时间复杂度为 O(m+n)，空间复杂度为 O(1)，其中 m 和 n 分别为字符串 ransomNote 和 magazine 的长度。</li></ul><h3 id="0x4-Go-语言实现的代码示例2："><a href="#0x4-Go-语言实现的代码示例2：" class="headerlink" title="0x4. Go 语言实现的代码示例2："></a>0x4. Go 语言实现的代码示例2：</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canConstruct</span><span class="params">(ransomNote <span class="keyword">string</span>, magazine <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    mag := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">byte</span>]<span class="keyword">int</span>) <span class="comment">// 创建哈希表</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> magazine &#123;</span><br><span class="line">        mag[magazine[i]]++    <span class="comment">// 记录 magazine 中每个字符出现的次数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> ransomNote &#123;</span><br><span class="line">        <span class="keyword">if</span> cnt, ok := mag[ransomNote[i]]; !ok || cnt == <span class="number">0</span> &#123; <span class="comment">// 检查 ransomNote 中的每个字符是否在 mag 中出现过</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mag[ransomNote[i]]-- <span class="comment">// 将 mag 中对应字符的计数减 1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度为 O(m+n)，空间复杂度为 O(m)，其中 m 和 n 分别为字符串 ransomNote 和 magazine 的长度。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;链接： &lt;a href=&quot;https://leetcode.cn/problems/ransom-note&quot;&gt;https://leetcode.cn/problems/ransom-note&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;0x0-题目描述&quot;&gt;&lt;a href=&quot;#0x0-题目描述&quot; class=&quot;headerlink&quot; title=&quot;0x0. 题目描述&quot;&gt;&lt;/a&gt;0x0. 题目描述&lt;/h3&gt;&lt;p&gt;给你两个字符串：ransomNote 和 magazine ，判断 ransomNote 能不能由 magazine 里面的字符构成。&lt;/p&gt;
&lt;p&gt;如果可以，返回 true ；否则返回 false 。&lt;/p&gt;
&lt;p&gt;magazine 中的每个字符只能在 ransomNote 中使用一次。&lt;/p&gt;</summary>
    
    
    
    <category term="Leetcode" scheme="https://blog.eganx.cn/categories/Leetcode/"/>
    
    
    <category term="Go" scheme="https://blog.eganx.cn/tags/Go/"/>
    
    <category term="Leetcode" scheme="https://blog.eganx.cn/tags/Leetcode/"/>
    
    <category term="hashmap" scheme="https://blog.eganx.cn/tags/hashmap/"/>
    
  </entry>
  
  <entry>
    <title>数据库基础--锁和隔离级别</title>
    <link href="https://blog.eganx.cn/2022/11/20/DB_base_%20lock_and_isolation/"/>
    <id>https://blog.eganx.cn/2022/11/20/DB_base_%20lock_and_isolation/</id>
    <published>2022-11-20T07:54:23.000Z</published>
    <updated>2022-12-31T02:55:40.471Z</updated>
    
    <content type="html"><![CDATA[<p>锁的类型和数据库事务隔离级别。</p><span id="more"></span><h2 id="0x0-锁粒度"><a href="#0x0-锁粒度" class="headerlink" title="0x0.锁粒度"></a>0x0.锁粒度</h2><p>MySQL提供了行级锁和表级锁。</p><p>应该尽量只锁定需要修改的那部分数据，而不是所有的资源。锁定的数据量越少，发生锁争用的可能性就越小，系统的并发程度就越高。</p><p>但是加锁需要消耗资源，各种锁操作都会增加系统开销。因此锁的粒度越小，系统开销就越大。在选择锁粒度的时候，需要平衡锁开销和系统并发程度。</p><h2 id="0x1-锁类型"><a href="#0x1-锁类型" class="headerlink" title="0x1.锁类型"></a>0x1.锁类型</h2><h4 id="1-读写锁"><a href="#1-读写锁" class="headerlink" title="1).读写锁"></a>1).读写锁</h4><ul><li><p>互斥锁(Exclusive)，简写X锁，又称写锁。</p></li><li><p>共享锁(Shared)，简写S锁，又称读锁。</p></li><li><p>一个事务对数据对象A加了X锁，就可以对A进行读取和更新。加锁期间其他事务不能对A加任何锁。</p></li><li><p>一个事务对数据对象A加了S锁，可以对A进行读取操作，不能进行更新操作。加锁期间其他事务能对A加S锁，但是不能加X锁。</p></li></ul><p>锁的兼容关系：</p><table><thead><tr><th align="center"></th><th align="center">X</th><th align="center">S</th></tr></thead><tbody><tr><td align="center">X</td><td align="center">❌</td><td align="center">❌</td></tr><tr><td align="center">S</td><td align="center">❌</td><td align="center"><strong>✔️</strong></td></tr></tbody></table><h4 id="2-意向锁"><a href="#2-意向锁" class="headerlink" title="2).意向锁"></a>2).意向锁</h4><p>使用意向锁可以更容易地支持多粒度封锁。</p><p>在存在行级锁和表级锁的情况下，事务T想要对表A加X锁，就需要先检测是否有其他事务对表A或者表A中的任意一行加了锁，需要对表A的每一行都检测一次，非常耗时。</p><p>意向锁就是在原来的X/S锁之上引入了IX/IS锁，IX/IS锁都是表锁，用来表示一个事务想要在表中的某个数据行上加X锁或S锁。</p><ul><li>一个事务在获得某个数据行对象的S锁之前，必须先获得表的IS锁或者更强的锁。</li><li>一个事务在获得某个数据行对象的X锁之前，必须先获得表的IX锁。</li></ul><p>通过引入意向锁，事务T想要对表A加X锁，只需要先检测是否有其他事务对表A加了X/IX/S/IS锁，如果加了就表示有其他事务正在使用这个表或者表中某一行的锁，因此事务T加X锁失败。</p><p>各种锁的兼容关系：</p><table><thead><tr><th align="center"></th><th align="center">X</th><th align="center">IX</th><th align="center">S</th><th align="center">IS</th></tr></thead><tbody><tr><td align="center">X</td><td align="center">❌</td><td align="center">❌</td><td align="center">❌</td><td align="center">❌</td></tr><tr><td align="center">IX</td><td align="center">❌</td><td align="center">✔️</td><td align="center">❌</td><td align="center">✔️</td></tr><tr><td align="center">S</td><td align="center">❌</td><td align="center">❌</td><td align="center">✔️</td><td align="center">✔️</td></tr><tr><td align="center">IS</td><td align="center">❌</td><td align="center">✔️</td><td align="center">✔️</td><td align="center">✔️</td></tr></tbody></table><ul><li>任意IS/IX锁之间都是兼容的，因为它们只表示想要对表加锁，而不是真正加锁。</li><li>兼容关系针对表级锁，而表级的IX锁和行级的X锁兼容，两个事务可以对两个数据行加X锁。（事务 T1 想要对数据行 R1 加 X 锁，事务 T2 想要对同一个表的数据行 R2 加 X 锁，两个事务都需要对该表加 IX 锁，但是 IX 锁是兼容的，并且 IX 锁与行级的 X 锁也是兼容的，因此两个事务都能加锁成功，对同一个表中的两个数据行做修改。）</li></ul><h2 id="0x2-锁协议"><a href="#0x2-锁协议" class="headerlink" title="0x2.锁协议"></a>0x2.锁协议</h2><h4 id="1-三级封锁协议"><a href="#1-三级封锁协议" class="headerlink" title="1).三级封锁协议"></a>1).三级封锁协议</h4><ul><li><p>一级封锁协议</p><p>事务T要修改数据A时必须加X锁，直到T结束才释放锁。</p><p>可以解决丢失修改的问题，不能同时有两个事务对同一个数据进行修改，那么事务的修改就不会被覆盖。</p></li><li><p>二级封锁协议</p><p>在一级的基础上，要求读取数据A时必须加S锁，读取完马上释放S锁。</p><p>可以解决读脏数据问题，因为如果一个事务在对数据A进行修改，根据1级封锁协议，会加X锁，那么就不能再加S锁了，也就是不会读入脏数据。</p></li><li><p>三级封锁协议</p><p>在二级的基础上，要求读取数据A时必须加S锁，直到事务结束了才能释放S锁。</p><p>可以解决不可重复读的问题，因为读取A时，其他事务不能对A加X锁，从而避免了在读的期间数据发生改变。</p></li></ul><h4 id="2-两段锁协议"><a href="#2-两段锁协议" class="headerlink" title="2).两段锁协议"></a>2).两段锁协议</h4><p>加锁和解锁分成两个阶段进行。</p><p>可串行化调度是指通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。串行执行的事务互不干扰，不会出现并发一致性问题。</p><p>事务遵循两段锁协议是保证可串行化调度的充分条件。例如以下操作满足两段锁协议，它是可串行化调度。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lock-x(A)...lock-s(B)...lock-s(C)...unlock(A)...unlock(C)...unlock(B)</span><br></pre></td></tr></table></figure><p>但不是必要条件，例如以下操作不满足两段锁协议，但它还是可串行化调度。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lock-x(A)...unlock(A)...lock-s(B)...unlock(B)...lock-s(C)...unlock(C)</span><br></pre></td></tr></table></figure><p>MySQL的InnoDB存储引擎采用两段锁协议，会根据隔离级别在需要的时候自动加锁，并且所有的锁都是在同一时刻被释放，这也被称为隐式锁定。</p><p>InnoDB也可使用语句进行显式加锁</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">LOCK</span> <span class="keyword">In</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span>;</span><br><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure><h2 id="0x3-隔离级别"><a href="#0x3-隔离级别" class="headerlink" title="0x3.隔离级别"></a>0x3.隔离级别</h2><h4 id="1-未提交读-READ-UNCOMMITTED"><a href="#1-未提交读-READ-UNCOMMITTED" class="headerlink" title="1).未提交读(READ UNCOMMITTED)"></a>1).未提交读(READ UNCOMMITTED)</h4><p>事务中的修改，即使没有提交，对其他事务也是可见的。</p><h4 id="2-提交读-READ-COMMITTED"><a href="#2-提交读-READ-COMMITTED" class="headerlink" title="2).提交读(READ COMMITTED)"></a>2).提交读(READ COMMITTED)</h4><p>一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其他事务是不可见的。</p><h4 id="3-可重复读-REPEATABLE-READ"><a href="#3-可重复读-REPEATABLE-READ" class="headerlink" title="3).可重复读(REPEATABLE READ)"></a>3).可重复读(REPEATABLE READ)</h4><p>保证在同一个事务中多次读取同一数据的结果是一样的。</p><h4 id="4-序列化（SERIALIZABLE）"><a href="#4-序列化（SERIALIZABLE）" class="headerlink" title="4).序列化（SERIALIZABLE）"></a>4).序列化（SERIALIZABLE）</h4><p>强制事务串行执行，这样多个事务互不干扰，不会出现并发一致性问题。</p><p>该隔离级别需要加锁实现，使用加锁机制保证同一时间只有一个事务执行，也就是保证事务串行执行。</p><p>隔离能解决的并发一致性问题如下所示：</p><table><thead><tr><th align="center"></th><th align="center">脏读</th><th align="center">不可重复读</th><th align="center">幻读</th></tr></thead><tbody><tr><td align="center">未提交读</td><td align="center">❌</td><td align="center">❌</td><td align="center">❌</td></tr><tr><td align="center">提交读</td><td align="center">✔️</td><td align="center">❌</td><td align="center">❌</td></tr><tr><td align="center">可重复读</td><td align="center">✔️</td><td align="center">✔️</td><td align="center">❌</td></tr><tr><td align="center">序列化</td><td align="center">✔️</td><td align="center">✔️</td><td align="center">✔️</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;p&gt;锁的类型和数据库事务隔离级别。&lt;/p&gt;</summary>
    
    
    
    <category term="Database" scheme="https://blog.eganx.cn/categories/Database/"/>
    
    
    <category term="DB" scheme="https://blog.eganx.cn/tags/DB/"/>
    
    <category term="lock" scheme="https://blog.eganx.cn/tags/lock/"/>
    
  </entry>
  
  <entry>
    <title>数据库基础--并发一致性问题</title>
    <link href="https://blog.eganx.cn/2022/11/19/DB_base_Concurrency_consistency/"/>
    <id>https://blog.eganx.cn/2022/11/19/DB_base_Concurrency_consistency/</id>
    <published>2022-11-19T14:12:54.000Z</published>
    <updated>2022-12-31T02:54:27.732Z</updated>
    
    <content type="html"><![CDATA[<p>在并发环境下，事务的隔离性很难保证，因此会出现很多并发一致性问题。产生并发不一致性问题的主要原因是破坏了事务的隔离性，解决方法是通过并发控制来保证隔离性。</p><span id="more"></span><h2 id="0x0-丢失修改"><a href="#0x0-丢失修改" class="headerlink" title="0x0.丢失修改"></a>0x0.丢失修改</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">┌──────────┐     ┌──────────┐</span><br><span class="line">│ T1 Start │     │ T2 Start │</span><br><span class="line">└─────┬────┘     └─────┬────┘</span><br><span class="line">      │                │</span><br><span class="line">      ▼                │</span><br><span class="line">┌──────────┐           │</span><br><span class="line">│Write A&#x3D;10│           │</span><br><span class="line">└─────┬────┘           │</span><br><span class="line">      │                ▼</span><br><span class="line">      │          ┌──────────┐</span><br><span class="line">      │          │Write A&#x3D;20│</span><br><span class="line">      │          └─────┬────┘</span><br><span class="line">      │                │</span><br><span class="line">      ▼                ▼</span><br><span class="line">┌──────────┐     ┌──────────┐</span><br><span class="line">│  T1 End  │     │  T2 End  │</span><br><span class="line">└──────────┘     └──────────┘</span><br><span class="line">  A&#x3D;20 A&#x3D;20</span><br></pre></td></tr></table></figure><p>丢失修改指一个事务的更新操作被另外一个事务的更新操作替换。一般在现实生活中常会遇到，例如：T1 和 T2 两个事务都对一个数据进行修改，T1 先修改并提交生效，T2 随后修改，T2 的修改覆盖了 T1 的修改。最终<code>A=20</code>，T1的修改丢失。</p><h2 id="0x1-读脏数据"><a href="#0x1-读脏数据" class="headerlink" title="0x1.读脏数据"></a>0x1.读脏数据</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">┌──────────┐     ┌──────────┐</span><br><span class="line">│ T1 Start │     │ T2 Start │</span><br><span class="line">└─────┬────┘     └─────┬────┘</span><br><span class="line">      │                │</span><br><span class="line">      ▼                │</span><br><span class="line">┌──────────┐           │</span><br><span class="line">│ Read A&#x3D;10│           │</span><br><span class="line">└─────┬────┘           │</span><br><span class="line">      │                │</span><br><span class="line">      ▼                │</span><br><span class="line">┌──────────┐           │</span><br><span class="line">│Write A&#x3D;20│           │</span><br><span class="line">└─────┬────┘           ▼</span><br><span class="line">      │          ┌──────────┐</span><br><span class="line">      │          │ Read A&#x3D;20│</span><br><span class="line">      ▼          └─────┬────┘</span><br><span class="line">┌──────────┐           │</span><br><span class="line">│ Rollback │           │</span><br><span class="line">└─────┬────┘           │</span><br><span class="line">      │                │</span><br><span class="line">      ▼                ▼</span><br><span class="line">┌──────────┐     ┌──────────┐</span><br><span class="line">│  T1 End  │     │  T2 End  │</span><br><span class="line">└──────────┘     └──────────┘</span><br><span class="line">    A&#x3D;10             A&#x3D;20</span><br></pre></td></tr></table></figure><p>读脏数据指在不同的事务下，当前事务可以读到另外事务未提交的数据。例如：T1 修改一个数据但未提交，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是脏数据。</p><h2 id="0x2-不可重复读"><a href="#0x2-不可重复读" class="headerlink" title="0x2.不可重复读"></a>0x2.不可重复读</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">┌──────────┐     ┌──────────┐</span><br><span class="line">│ T1 Start │     │ T2 Start │</span><br><span class="line">└─────┬────┘     └─────┬────┘</span><br><span class="line">      │                │</span><br><span class="line">      │                ▼</span><br><span class="line">      │          ┌──────────┐</span><br><span class="line">      │          │ Read A&#x3D;10│</span><br><span class="line">      │          └─────┬────┘</span><br><span class="line">      ▼                │</span><br><span class="line">┌──────────┐           │</span><br><span class="line">│Write A&#x3D;20│           │</span><br><span class="line">└─────┬────┘           │</span><br><span class="line">      │                │</span><br><span class="line">      │                ▼</span><br><span class="line">      │          ┌──────────┐</span><br><span class="line">      │          │ Read A&#x3D;20│</span><br><span class="line">      │          └─────┬────┘</span><br><span class="line">      │                │</span><br><span class="line">      │                │</span><br><span class="line">      │                │</span><br><span class="line">      ▼                ▼</span><br><span class="line">┌──────────┐     ┌──────────┐</span><br><span class="line">│  T1 End  │     │  T2 End  │</span><br><span class="line">└──────────┘     └──────────┘</span><br><span class="line">    A&#x3D;20             A&#x3D;20</span><br></pre></td></tr></table></figure><p>不可重复读指在一个事务内多次读取同一数据集合。在这一事务还未结束前，另一事务也访问了该同一数据集合并做了修改，由于第二个事务的修改，第一次事务的两次读取的数据可能不一致。例如：T2 读取一个数据，T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同。</p><h2 id="0x3-幻影读"><a href="#0x3-幻影读" class="headerlink" title="0x3.幻影读"></a>0x3.幻影读</h2><p>幻读本质上也属于不可重复读的情况，T1 读取某个范围的数据，T2 在这个范围内插入新的数据，T1 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在并发环境下，事务的隔离性很难保证，因此会出现很多并发一致性问题。产生并发不一致性问题的主要原因是破坏了事务的隔离性，解决方法是通过并发控制来保证隔离性。&lt;/p&gt;</summary>
    
    
    
    <category term="Database" scheme="https://blog.eganx.cn/categories/Database/"/>
    
    
    <category term="DB" scheme="https://blog.eganx.cn/tags/DB/"/>
    
    <category term="concurrency consistency" scheme="https://blog.eganx.cn/tags/concurrency-consistency/"/>
    
  </entry>
  
  <entry>
    <title>数据库基础--事务</title>
    <link href="https://blog.eganx.cn/2022/11/19/DB_base_%20transaction/"/>
    <id>https://blog.eganx.cn/2022/11/19/DB_base_%20transaction/</id>
    <published>2022-11-19T04:45:22.000Z</published>
    <updated>2022-12-31T02:54:23.744Z</updated>
    
    <content type="html"><![CDATA[<p><strong>数据库事务</strong>（简称：<strong>事务</strong>）是数据库管理系统执行过程中的一个逻辑单位，由一个有限的数据库操作序列构成。</p><span id="more"></span><h2 id="0x0-事务"><a href="#0x0-事务" class="headerlink" title="0x0.事务"></a>0x0.事务</h2><p>事务是指满足ACID特性的一组操作，可以通过Commit提交一个事务，也可以使用Rollback进行回滚。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">             ┌──────────────────────┐              ┌──────────┐</span><br><span class="line">             │                      │              │          │</span><br><span class="line">             │ insert，update，delete│              │  commit  │</span><br><span class="line">             │                      │              │          │</span><br><span class="line">             └─┬──────────────────┬─┘              └─────┬────┘</span><br><span class="line">               │                  │                      │</span><br><span class="line"></span><br><span class="line">               │                  │                      │</span><br><span class="line">               │                  │                      │</span><br><span class="line">               │</span><br><span class="line">┌────────┐          ┌────────┐    │      ┌────────┐      │     ┌────────┐</span><br><span class="line">│        │     │    │┼┼┼┼┼┼┼┼│    │      │┼┼┼┼┼┼┼┼│      │     │        │</span><br><span class="line">│        ├─────┴───►├┼┼┼┼┼┼┼┼┼────┴─────►├┼┼┼┼┼┼┼┼┼──────┴────►│        │</span><br><span class="line">│        │          │┼┼┼┼┼┼┼┼│           │┼┼┼┼┼┼┼┼│            │        │</span><br><span class="line">└────────┘          └────┼───┘           └────┼───┘            └────┬───┘</span><br><span class="line"> ▲  ▲  ▲                 │                    │                     │</span><br><span class="line"> │  │  │                 │                    │                     │</span><br><span class="line"> │  │  └─────────────────┘                    │                     │</span><br><span class="line"> │  │                                         │                     │</span><br><span class="line"> │  └─────────────────────────────────────────┘                     │</span><br><span class="line"> │                                                                  │</span><br><span class="line"> └──────────────────────────────┬───────────────────────────────────┘</span><br><span class="line">                                │</span><br><span class="line"></span><br><span class="line">                                │</span><br><span class="line">                     ┌──────────┴────────────┐</span><br><span class="line">                     │                       │</span><br><span class="line">                     │   Rollback or Error   │</span><br><span class="line">                     │                       │</span><br><span class="line">                     └───────────────────────┘</span><br><span class="line">*注：空白方块表示一致性状态，阴影方块表示中间状态。</span><br></pre></td></tr></table></figure><h2 id="0x1-ACID"><a href="#0x1-ACID" class="headerlink" title="0x1.ACID"></a>0x1.ACID</h2><h4 id="1-原子性-Atomicity"><a href="#1-原子性-Atomicity" class="headerlink" title="1).原子性(Atomicity)"></a>1).原子性(Atomicity)</h4><p>事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。</p><p>回滚可以用回滚日志（Undo Log）来实现，回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。</p><h4 id="2-一致性-Consistency"><a href="#2-一致性-Consistency" class="headerlink" title="2).一致性(Consistency)"></a>2).一致性(Consistency)</h4><p>数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对同一个数据的读取结果都是相同的。</p><h4 id="3-隔离性-Isolation"><a href="#3-隔离性-Isolation" class="headerlink" title="3).隔离性(Isolation)"></a>3).隔离性(Isolation)</h4><p>一个事务所做的修改子最终提交以前，对其他事务是不可见的。</p><h4 id="4-持久性-Durability"><a href="#4-持久性-Durability" class="headerlink" title="4).持久性(Durability)"></a>4).持久性(Durability)</h4><p>一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统崩溃，事务执行的结果也不能丢失。</p><p>系统发生崩溃可以用重做日志（Redo Log）进行恢复，从而实现持久性。与回滚日志记录数据的逻辑修改不同，重做日志记录的是数据页的物理修改。</p><blockquote><p>事务的 ACID 特性概念简单，但不是很好理解，主要是因为这几个特性不是一种平级关系：</p><ul><li>只有满足一致性，事务的执行结果才是正确的。</li><li>在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定能满足一致性。</li><li>在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性。</li><li>事务满足持久化是为了能应对系统崩溃的情况。</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">┌───────────┐  Concurrency&#x2F;Non concurrent</span><br><span class="line">│ Atomicity ├───────┐</span><br><span class="line">└───────────┘       │   ┌───────────┐</span><br><span class="line">                    ├──►│Consistency├───────► Correct execution</span><br><span class="line">┌───────────┐       │   └───────────┘</span><br><span class="line">│ Isolation ├───────┘</span><br><span class="line">└───────────┘  Concurrency</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                        ┌───────────┐</span><br><span class="line">                        │ Durability├───────► Dealing with system crashes</span><br><span class="line">                        └───────────┘</span><br></pre></td></tr></table></figure><h4 id="AutoCommit"><a href="#AutoCommit" class="headerlink" title="AutoCommit"></a>AutoCommit</h4><p>MySQL 默认采用自动提交模式。也就是说，如果不显式使用<code>START TRANSACTION</code>语句来开始一个事务，那么每个查询操作都会被当做一个事务并自动提交。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;数据库事务&lt;/strong&gt;（简称：&lt;strong&gt;事务&lt;/strong&gt;）是数据库管理系统执行过程中的一个逻辑单位，由一个有限的数据库操作序列构成。&lt;/p&gt;</summary>
    
    
    
    <category term="Database" scheme="https://blog.eganx.cn/categories/Database/"/>
    
    
    <category term="DB" scheme="https://blog.eganx.cn/tags/DB/"/>
    
    <category term="transaction" scheme="https://blog.eganx.cn/tags/transaction/"/>
    
  </entry>
  
  <entry>
    <title>Golang GC(Garbage Collection)</title>
    <link href="https://blog.eganx.cn/2022/11/16/Go_GC/"/>
    <id>https://blog.eganx.cn/2022/11/16/Go_GC/</id>
    <published>2022-11-16T14:12:29.000Z</published>
    <updated>2022-12-28T02:45:00.841Z</updated>
    
    <content type="html"><![CDATA[<p>内存管理是程序员开发应用的一大难题。传统的系统级编程语言（主要指C/C++）中，程序开发者必须对内存小心的进行管理操作，控制内存的申请及释放。 因为稍有不慎，就可能产生内存泄露问题，这种问题不易发现并且难以定位，一直成为困扰程序开发者的噩梦。</p><span id="more"></span><h2 id="0x0-Garbage-Collection"><a href="#0x0-Garbage-Collection" class="headerlink" title="0x0.Garbage Collection"></a>0x0.Garbage Collection</h2><p>GC(Garbage Collection)，垃圾回收是一种自动内存管理机制。当某个程序占用的一部分内存空间不再被这个程序访问时，这个程序会借助<strong>垃圾回收</strong>算法向操作系统归还这部分内存空间。垃圾回收器可以减轻程序员的负担，也减少程序中的错误。垃圾回收最早起源于<a href="https://zh.wikipedia.org/wiki/LISP">LISP</a>语言。</p><p>垃圾回收器的执行过程通常被划分成两个独立的组件：</p><ul><li>赋值器：指代用户态的代码。对于垃圾回收器来说，用户态的代码只是在修改对象之间的引用关系。</li><li>回收器：负责执行垃圾回收的代码。</li></ul><h2 id="0x1-根对象"><a href="#0x1-根对象" class="headerlink" title="0x1.根对象"></a>0x1.根对象</h2><p>根集合是垃圾回收器在标记过程中最先检查的对象，包括：</p><ul><li>全局变量</li><li>执行栈：每个goroutine都包含自己的执行栈，包含栈上的变量以及指向分配的堆内存区块的指针。</li><li>寄存器</li></ul><h2 id="0x2-GC实现方式"><a href="#0x2-GC实现方式" class="headerlink" title="0x2.GC实现方式"></a>0x2.GC实现方式</h2><p>GC的常见实现方式有追踪式GC和引用计数式GC。</p><ul><li><p>追踪式GC</p><p>从根对象出发，根据对象之间的引用信息，逐步扫描直至扫完整个堆并确定保留的对象，从而回收所有可回收的对象。</p></li><li><p>引用计数式GC</p><p>每个对象自身包含一个被引用的计数器，当计数器归零时自动得到回收。</p></li></ul><p>Go 的 GC 目前使用的是无分代（对象没有代际之分）、非移动（回收过程中不对对象进行移动与整理）、并发（与用户代码并发执行）的三色标记清扫算法。属于追踪式GC的一种。</p><h2 id="0x3-三色标记法"><a href="#0x3-三色标记法" class="headerlink" title="0x3.三色标记法"></a>0x3.三色标记法</h2><p>golang的垃圾回收是基于标记清扫算法，这种算法需要进行STW(stop the world)，这个过程会导致程序卡顿，所以频繁的GC是会严重影响程序性能的。golang在此基础上进行了改进，通过<strong>三色标记清扫算法</strong>和<strong>写屏障</strong>来减少STW的时间。</p><h4 id="GC的四个过程"><a href="#GC的四个过程" class="headerlink" title="GC的四个过程"></a>GC的四个过程</h4><ul><li>1、栈扫描（开始时STW），所有对象开始都是白色。</li><li>2、从root开始找到所有可达对象（所有可以找到的对象），标记成灰色，放入待处理队列。</li><li>3、遍历灰色对象队列，将其<strong>引用对象</strong>标记成灰色放入待处理队列，自身标记为黑色。</li><li>4、清除（并发）循环步骤3直到灰色队列为空。此时所有的引用对象都被标记为黑色，所有不可达的对象依然是白色，白色的就是需要进行回收的对象。</li></ul><p>三色标记法相对于普通的标记清扫，减少了STW的时间，这主要得益于标记过程是”on-the-fly”的，标记过程中是不需要STW的，它与程序是并发执行的，大大缩短了STW的时间。Golang gc优化的核心就是尽量使得STW的时间越来越短。</p><table><thead><tr><th align="center">阶段</th><th align="center">说明</th><th align="center">赋值器状态</th></tr></thead><tbody><tr><td align="center">SweepTermination</td><td align="center">清扫终止阶段，为下一个阶段的并发标记做准备工作，启动写屏障</td><td align="center">STW</td></tr><tr><td align="center">Mark</td><td align="center">扫描标记阶段，与赋值器并发执行，写屏障开启</td><td align="center">并发</td></tr><tr><td align="center">MarkTermination</td><td align="center">标记终止阶段，保证一个周期内标记任务完成，停止写屏障</td><td align="center">STW</td></tr><tr><td align="center">GCoff</td><td align="center">内存清扫阶段，将需要回收的内存归还到堆中，写屏障关闭</td><td align="center">并发</td></tr><tr><td align="center">GCoff</td><td align="center">内存归还阶段，将过多的内存归还给操作系统，写屏障关闭</td><td align="center">并发</td></tr></tbody></table><h4 id="写屏障"><a href="#写屏障" class="headerlink" title="写屏障"></a>写屏障</h4><p>当标记的程序是并发执行的，有可能在标记过程中，有新的引用产生，可能会导致误清扫。</p><p>清扫开始前，标记为黑色的对象引用一个新申请的对象，此时它肯定是白色的，而黑色对象不会被再次扫描，那么这个白色对象无法被扫描变成灰色、黑色，它最终会被清扫，而实际上它不应该被清扫。</p><p>golang采取了写屏障，其作用就是为了避免这类误清扫问题。写屏障在内存写操作前，维护一个约束，从而确保清扫开始前，黑色的对象不能引用白色对象。</p><h2 id="0x4-触发GC的时机"><a href="#0x4-触发GC的时机" class="headerlink" title="0x4.触发GC的时机"></a>0x4.触发GC的时机</h2><p>Go 语言中对 GC 的触发时机存在两种形式：</p><ol><li><strong>主动触发</strong>，通过调用 runtime.GC 来触发 GC，此调用阻塞式地等待当前 GC 运行完毕。</li><li><strong>被动触发</strong>，分为两种方式：<ul><li>使用系统监控，当超过两分钟没有产生任何 GC 时，强制触发 GC。</li><li>使用步调（Pacing）算法，其核心思想是控制内存增长的比例，当前内存分配达到一定比例则触发。</li></ul></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;内存管理是程序员开发应用的一大难题。传统的系统级编程语言（主要指C/C++）中，程序开发者必须对内存小心的进行管理操作，控制内存的申请及释放。 因为稍有不慎，就可能产生内存泄露问题，这种问题不易发现并且难以定位，一直成为困扰程序开发者的噩梦。&lt;/p&gt;</summary>
    
    
    
    <category term="Golang" scheme="https://blog.eganx.cn/categories/Golang/"/>
    
    
    <category term="GC" scheme="https://blog.eganx.cn/tags/GC/"/>
    
    <category term="go" scheme="https://blog.eganx.cn/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>Go反射(reflect)</title>
    <link href="https://blog.eganx.cn/2022/11/13/Go_reflect/"/>
    <id>https://blog.eganx.cn/2022/11/13/Go_reflect/</id>
    <published>2022-11-13T11:21:43.000Z</published>
    <updated>2022-12-27T09:04:09.169Z</updated>
    
    <content type="html"><![CDATA[<p>不同语言的反射模型不尽相同。闲来无事，看看Go的反射机制。</p><span id="more"></span><h2 id="0x0-反射的定义"><a href="#0x0-反射的定义" class="headerlink" title="0x0.反射的定义"></a>0x0.反射的定义</h2><p>维基百科上反射的定义：</p><blockquote><p>在计算机科学中，反射是指电脑程序在运行时（runtime）可以访问、检测和修改它本身状态或行为的一种能力。用比喻来说，反射就是程序在运行的时候能够“观察”并且修改自己的行为。</p></blockquote><p>Go 语言提供了一种机制在运行时更新变量和检查它们的值、调用它们的方法，但是在编译时并不知道这些变量的具体类型，这称为反射机制。</p><h2 id="0x1-反射的实现"><a href="#0x1-反射的实现" class="headerlink" title="0x1.反射的实现"></a>0x1.反射的实现</h2><p>反射通过接口的类型信息实现。反射是建立在类型的基础上。</p><p>Go在reflect包中定义了各种类型，实现了反射的各种函数，通过它们可以在运行时检测类型的信息和改变类型的值。</p><h4 id="1-反射的基本函数"><a href="#1-反射的基本函数" class="headerlink" title="1).反射的基本函数"></a>1).反射的基本函数</h4><p>reflect 包里定义了一个接口和一个结构体，即 <code>reflect.Type</code> 和 <code>reflect.Value</code>，它们提供很多函数来获取存储在接口里的类型信息。</p><p><code>reflect.Type</code> 主要提供关于类型相关的信息，所以它和 <code>_type</code> 关联比较紧密；<code>reflect.Value</code> 则结合 <code>_type</code> 和 <code>data</code> 两者，因此我们可以获取甚至改变类型的值。</p><p>reflect 包中提供了两个基础的关于反射的函数来获取上述的接口和结构体：</p><blockquote><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TypeOf</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">Type</span></span> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ValueOf</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">Value</span></span></span><br></pre></td></tr></table></figure></blockquote><p><code>TypeOf</code> 函数用来提取一个接口中值的类型信息。由于它的输入参数是一个空的 <code>interface&#123;&#125;</code>，调用此函数时，实参会先被转化为 <code>interface&#123;&#125;</code>类型。这样，实参的类型信息、方法集、值信息都存储到 <code>interface&#123;&#125;</code> 变量里了。</p><p><code>fmt.Printf()</code> 函数，如果使用 <code>%T</code> 来作为格式参数，输出的是 <code>reflect.TypeOf</code> 的结果，也就是动态类型。</p><p><code>TypeOf()</code> 函数返回一个接口，这个接口定义了一系列方法，利用这些方法可以获取关于类型的所有信息； <code>ValueOf()</code> 函数返回一个结构体变量，包含类型信息以及实际值。</p><h4 id="2-反射的三大定律"><a href="#2-反射的三大定律" class="headerlink" title="2).反射的三大定律"></a>2).反射的三大定律</h4><ul><li><p> Reflection goes from interface value to reflection object.</p></li><li><p> Reflection goes from reflection object to interface value.</p></li><li><p>To modify a reflection object, the value must be settable.</p><p><code>接口型变量</code> 和 <code>反射类型对象</code> 可以相互转化。如果想要操作原变量，反射变量 <code>Value</code> 必须要 hold 住原变量的地址才行。</p></li></ul><h2 id="0x2-反射的使用场景"><a href="#0x2-反射的使用场景" class="headerlink" title="0x2.反射的使用场景"></a>0x2.反射的使用场景</h2><p>使用反射的常见场景有以下两种：</p><ol><li>不能明确接口调用哪个函数，需要根据传入的参数在运行时决定。</li><li>不能明确传入函数的参数类型，需要在运行时处理任意对象。</li></ol><blockquote><p> 反射对性能影响还是比较大的，比正常代码运行速度慢一到两个数量级。关键代码避免使用反射特性。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;不同语言的反射模型不尽相同。闲来无事，看看Go的反射机制。&lt;/p&gt;</summary>
    
    
    
    <category term="Golang" scheme="https://blog.eganx.cn/categories/Golang/"/>
    
    
    <category term="go" scheme="https://blog.eganx.cn/tags/go/"/>
    
    <category term="reflect" scheme="https://blog.eganx.cn/tags/reflect/"/>
    
  </entry>
  
  <entry>
    <title>Mongo cluster(docker compose)</title>
    <link href="https://blog.eganx.cn/2022/11/10/DB_Mongo_0/"/>
    <id>https://blog.eganx.cn/2022/11/10/DB_Mongo_0/</id>
    <published>2022-11-10T13:12:34.000Z</published>
    <updated>2022-12-31T02:39:20.851Z</updated>
    
    <content type="html"><![CDATA[<p>初次使用docker compose搭建mongo集群，记录一下。虽然问题还很多，但至少跑起来了。。。</p><span id="more"></span><h2 id="0x0-文件目录结构"><a href="#0x0-文件目录结构" class="headerlink" title="0x0.文件目录结构"></a>0x0.文件目录结构</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mongodb</span><br><span class="line">└── mongo</span><br><span class="line">    ├── data</span><br><span class="line">    │   ├── hosts</span><br><span class="line">    │   └── mongod.conf</span><br><span class="line">    └── docker-compose.yml</span><br></pre></td></tr></table></figure><h2 id="0x1-mongod-conf"><a href="#0x1-mongod-conf" class="headerlink" title="0x1.mongod.conf"></a>0x1.mongod.conf</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemLog:</span><br><span class="line">  destination: file</span><br><span class="line">  path: &#x2F;data&#x2F;log&#x2F;mongo.log</span><br><span class="line">  logAppend: true</span><br><span class="line">storage:</span><br><span class="line">  dbPath: &#x2F;data&#x2F;db</span><br><span class="line">net:</span><br><span class="line">  bindIp: 0.0.0.0</span><br><span class="line">replication:</span><br><span class="line">  replSetName: rs0</span><br></pre></td></tr></table></figure><h2 id="0x2-hosts"><a href="#0x2-hosts" class="headerlink" title="0x2.hosts"></a>0x2.hosts</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1localhost</span><br><span class="line">255.255.255.255broadcasthost</span><br><span class="line">::1                     localhost</span><br></pre></td></tr></table></figure><h2 id="0x3-docker-compose-yml"><a href="#0x3-docker-compose-yml" class="headerlink" title="0x3.docker-compose.yml"></a>0x3.docker-compose.yml</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">db:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">mongo1:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mongo</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">mongo1</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">mongod</span> <span class="string">--config</span> <span class="string">/etc/mongod.conf</span></span><br><span class="line">    <span class="attr">expose:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">27017</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./data/mongo1/db:/data/db</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./data/mongo1/configdb:/data/configdb</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./data/mongo1/log:/data/log</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./data/mongod.conf:/etc/mongod.conf</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./data/hosts:/etc/hosts</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;27017:27017&quot;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">db</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">mongo2:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mongo</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">mongo2</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">mongod</span> <span class="string">--config</span> <span class="string">/etc/mongod.conf</span></span><br><span class="line">    <span class="attr">expose:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">27017</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./data/mongo2/db:/data/db</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./data/mongo2/configdb:/data/configdb</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./data/mongo2/log:/data/log</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./data/mongod.conf:/etc/mongod.conf</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./data/hosts:/etc/hosts</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;27018:27017&quot;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">db</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">mongo3:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mongo</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">mongo3</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">mongod</span> <span class="string">--config</span> <span class="string">/etc/mongod.conf</span></span><br><span class="line">    <span class="attr">expose:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">27017</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./data/mongo3/db:/data/db</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./data/mongo3/configdb:/data/configdb</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./data/mongo3/log:/data/log</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./data/mongod.conf:/etc/mongod.conf</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./data/hosts:/etc/hosts</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;27019:27017&quot;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">db</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="0x4-开始部署"><a href="#0x4-开始部署" class="headerlink" title="0x4.开始部署"></a>0x4.开始部署</h2><ul><li>进入docker-compose.yml文件所在目录</li><li>执行命令：<code>docker compose -f docker-compose.yml up -d</code></li></ul><h2 id="0x5-建立副本集"><a href="#0x5-建立副本集" class="headerlink" title="0x5.建立副本集"></a>0x5.建立副本集</h2><ul><li><p>进入mongo容器：<code>docker exec -it mongo1 bash</code></p></li><li><p>进入mongo：<code>mongosh</code> ,老版本的mongo到指令是<code>mongo</code></p></li><li><p>切换管理员用户：<code>use admin</code></p></li><li><p>初始化副本集：<code>rs.initiate()</code>,无参初始化时，会默认当前节点PRIMARY节点</p></li><li><p>添加副节点：<code>rs.add(&#39;mongo2:27017&#39;)</code></p></li><li><p>添加仲裁节点：<code>rs.addArb(&#39;mongo3:27017&#39;)</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 添加仲裁节点要是报错，可以试试运行以下代码</span><br><span class="line"> db.adminCommand(&#123;</span><br><span class="line">  &quot;setDefaultRWConcern&quot; : 1,</span><br><span class="line">  &quot;defaultWriteConcern&quot; : &#123;</span><br><span class="line">    &quot;w&quot; : 2</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>查看副本集配置信息：<code>rs.conf()</code></p></li><li><p>查看副本集运行状态：<code>rs.status()</code></p></li></ul><p>要是需要修改配置，可以按照以下步骤来：</p><ul><li><code>cfg = rs.conf()</code></li><li><code>cfg.members[0].xxx = xxx</code></li><li><code>rs.reconfig(cfg)</code></li></ul><h2 id="0x6-验证副本集"><a href="#0x6-验证副本集" class="headerlink" title="0x6.验证副本集"></a>0x6.验证副本集</h2><p>切换节点查看同步状态：<code>rs.printReplicationInfo()</code></p><p>仅当建立了集合后副节点才会进行同步。</p><h2 id="0x7-外部连接"><a href="#0x7-外部连接" class="headerlink" title="0x7.外部连接"></a>0x7.外部连接</h2><p>准备使用Robo 3T(现在变成Studio 3T Free)连接数据库时，会有连接失败的异常，可以将WSL的IP地址写入电脑C盘hosts文件里：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">172.23.224.1mongo1</span><br><span class="line">172.23.224.1mongo2</span><br><span class="line">172.23.224.1mongo3</span><br></pre></td></tr></table></figure><p>然后使用以下链接来连接数据库</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mongo1:27017</span><br><span class="line">mongo2:27017</span><br><span class="line">mongo3:27017</span><br></pre></td></tr></table></figure><p>但是如果还是连接不上，或者重启后连接不上，可以将<code>mongo</code>容器的IP写到<code>mongo\data\hosts</code>文件里，容器的IP可以使用<code>docker inspect mongo1</code>来获取。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">172.30.0.2 mongo1</span><br><span class="line">172.30.0.3 mongo2</span><br><span class="line">172.30.0.4 mongo3</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;初次使用docker compose搭建mongo集群，记录一下。虽然问题还很多，但至少跑起来了。。。&lt;/p&gt;</summary>
    
    
    
    <category term="Database" scheme="https://blog.eganx.cn/categories/Database/"/>
    
    
    <category term="DB" scheme="https://blog.eganx.cn/tags/DB/"/>
    
    <category term="mongo" scheme="https://blog.eganx.cn/tags/mongo/"/>
    
  </entry>
  
  <entry>
    <title>Go语言中new和make的区别</title>
    <link href="https://blog.eganx.cn/2022/11/07/Go_New_and_Make/"/>
    <id>https://blog.eganx.cn/2022/11/07/Go_New_and_Make/</id>
    <published>2022-11-07T01:07:12.000Z</published>
    <updated>2022-12-27T09:04:20.424Z</updated>
    
    <content type="html"><![CDATA[<p>在Go语言中，make关键字在初始化的时候被频繁使用，之前写C# 的时候都是使用new关键字，Go中new关键字也是存在的。准备看看两者的区别。</p><span id="more"></span><h2 id="0x0-new"><a href="#0x0-new" class="headerlink" title="0x0.new"></a>0x0.new</h2><p><code>new</code>可以对类型进行内存创建和初始化，<strong>其返回值是所创建类型的指针引用</strong>。<code>new</code>会根据变量类型返回一个指向该类型的指针。</p><h2 id="0x1-make"><a href="#0x1-make" class="headerlink" title="0x1.make"></a>0x1.make</h2><p><code>make</code> 函数也是用于内存分配的，但是和<code>new</code>不同，仅支持 <code>slice</code>、<code>map</code>、<code>channel</code> 三种数据类型的内存创建，其返回值是所创建类型的本身，而不是新的指针引用。<code>make</code>不仅可以开辟一个内存，还能给这个内存的类型初始化其零值。</p><h2 id="0x2-总结"><a href="#0x2-总结" class="headerlink" title="0x2.总结"></a>0x2.总结</h2><ul><li>make和new都是golang用来分配内存的函数，且在堆上分配内存，make 即分配内存，也初始化内存。new只是将内存清零，并没有初始化内存。</li><li>make返回的还是引用类型本身；而new返回的是指向类型的指针。</li><li>make只能用来分配及初始化类型为slice，map，channel的数据；new可以分配任意类型的数据。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;在Go语言中，make关键字在初始化的时候被频繁使用，之前写C# 的时候都是使用new关键字，Go中new关键字也是存在的。准备看看两者的区别。&lt;/p&gt;</summary>
    
    
    
    <category term="Golang" scheme="https://blog.eganx.cn/categories/Golang/"/>
    
    
    <category term="make" scheme="https://blog.eganx.cn/tags/make/"/>
    
    <category term="new" scheme="https://blog.eganx.cn/tags/new/"/>
    
  </entry>
  
  <entry>
    <title>Windows10下WSL2和Docker的安装和配置</title>
    <link href="https://blog.eganx.cn/2022/11/06/Win10_WSL_Docker/"/>
    <id>https://blog.eganx.cn/2022/11/06/Win10_WSL_Docker/</id>
    <published>2022-11-06T04:12:32.000Z</published>
    <updated>2022-12-17T13:27:04.083Z</updated>
    
    <content type="html"><![CDATA[<p>最近需要搭建mongo集群，看教程说使用docker比较好部署，准备在公司电脑（ThinkPad）上先试一下，所以需要安装一下WSL和docker。自己也没有在Windows环境下使用过docker，所以记录一下。</p><span id="more"></span><h2 id="0x0-Windows-Terminal"><a href="#0x0-Windows-Terminal" class="headerlink" title="0x0.Windows Terminal"></a>0x0.Windows Terminal</h2><p>用过 <code>Windows</code> 默认终端的都知道，真的不怎么美观。 微软也逐渐意识到这个问题，并在 <code>Build2019</code> 大会上发布了 新一代 <code>Windows</code> 终端程序：<code>Windows Terminal</code> 。</p><p><code>Windows Terminal</code> 是一款新式、快速、高效、强大且高效的终端应用程序，适用于命令行工具和命令提示符，PowerShell和 WSL 等 Shell 用户。主要功能包括多个选项卡、窗格、Unicode、和 UTF-8 字符支持，GPU 加速文本渲染引擎以及自定义主题、样式和配置。</p><p>而且这个是开源的，如果不喜欢在Microsoft Store里安装软件，可以直接去GitHub里下载，这里给出GitHub项目地址：<code>https://github.com/microsoft/terminal</code>。</p><h2 id="0x1-Windows-WSL2"><a href="#0x1-Windows-WSL2" class="headerlink" title="0x1.Windows WSL2"></a>0x1.Windows WSL2</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1).概述"></a>1).概述</h3><p>WSL是windows推出的可让开发人员不需要安装虚拟机（vmware，virtbox）或者设置双系统启动就可以原生支持运行GNU/Linux的系统环境，简称WSL子系统。目前最新的版本是WSL2，在原先的基础上提高了文件系统的性能并添加了完全的的系统调用支持。WSL2使用全新体系架构使其能真正的运行一个Linux内核。</p><h3 id="2-安装"><a href="#2-安装" class="headerlink" title="2).安装"></a>2).安装</h3><ul><li>WSL2对系统版本有一定的要求：必须运行 Windows 10 版本 2004 及更高版本（内部版本 19041 及更高版本）或 Windows 11。</li><li>在 <code>控制面板</code>-<code>程序</code>- <code>启用或关闭 Windows 功能</code> 中勾选 <code>适用于 Linux 的 Windows 子系统</code>以及 <code>虚拟机平台</code>(wsl2 需要)。<font color=red>此步骤完成后需要重启电脑。</font></li><li>打开微软商店应用，在搜索框中输入“Linux”或者“ubuntu”然后搜索，你可以看到搜索结果中有很多的 Linux 发行版可以选择。我选Ubuntu22.04<ul><li>有可能启动ubuntu报告<code>WslRegisterDistribution failed with error: 0x800701bc</code>是因为没有升级linux内核使用<code>wsl --update</code>下载更新即可。</li><li>在商店安装后并没有完全完成子系统安装，还需要运行一次Ubuntu来完成内核下载以及用户名密码的设置。</li></ul></li><li>启动WSL2<ul><li><code>Windows Terminal</code>里面使用<code>wsl -l</code>命令来查看所有的子系统。使用<code>wsl --set-default-version 2</code>设置为每个安装的发行版默认WSL2启动。</li></ul></li></ul><h3 id="3-导出Ubuntu-22-04到D盘下"><a href="#3-导出Ubuntu-22-04到D盘下" class="headerlink" title="3).导出Ubuntu-22.04到D盘下"></a>3).导出Ubuntu-22.04到D盘下</h3><p>这一步可以缓解一下C盘的压力，C盘没有压力的就当没看见这一步。</p><ul><li>查看已安装的Linux发行版: <code>wsl -l --all -v</code></li><li>导出Linux发行版tar文件到指定文件夹: <code>wsl --export Ubuntu-22.04 d:/wsl/ubuntu/wsl-ubuntu-22.04.tar</code></li><li>注销Ubuntu-22.04: <code>wsl --unregister Ubuntu-22.04</code></li><li>重新导入并安装WSL2到D盘: <code>wsl --import Ubuntu-22.04 d:/wsl/ubuntu/ d:/wsl/ubuntu/wsl-ubuntu-22.04.tar --version 2</code></li></ul><h2 id="0x2-Windows-Docker-Desktop"><a href="#0x2-Windows-Docker-Desktop" class="headerlink" title="0x2.Windows Docker Desktop"></a>0x2.Windows Docker Desktop</h2><p>这个没啥好说的，官网下载，直接安装就完了。官网地址传送：<code>https://www.docker.com/products/docker-desktop/</code>.</p><p>安装完成后，打开Docker Desktop的设置，找到<code>Resources-WSL Integration</code>，打开Enable integration with additional distors，将自己的WSL打开。这样docker就会跑在WSL上。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近需要搭建mongo集群，看教程说使用docker比较好部署，准备在公司电脑（ThinkPad）上先试一下，所以需要安装一下WSL和docker。自己也没有在Windows环境下使用过docker，所以记录一下。&lt;/p&gt;</summary>
    
    
    
    <category term="Database" scheme="https://blog.eganx.cn/categories/Database/"/>
    
    
    <category term="mongo" scheme="https://blog.eganx.cn/tags/mongo/"/>
    
    <category term="tool" scheme="https://blog.eganx.cn/tags/tool/"/>
    
  </entry>
  
  <entry>
    <title>Studio 3T Free跳过一个月Full product的登陆试用(Windows)</title>
    <link href="https://blog.eganx.cn/2022/11/05/Tool_Studio3t/"/>
    <id>https://blog.eganx.cn/2022/11/05/Tool_Studio3t/</id>
    <published>2022-11-05T14:32:12.000Z</published>
    <updated>2022-12-16T02:16:06.630Z</updated>
    
    <content type="html"><![CDATA[<p>当Robo 3T变成了Studio 3T Free，不想试用Studio 3T的Full product。只想使用Robo 3T Free(Robo 3T)，该如何跳过一个月Full product的登陆试用呢？</p><span id="more"></span><h2 id="0x0-尊重付费软件"><a href="#0x0-尊重付费软件" class="headerlink" title="0x0.尊重付费软件"></a>0x0.尊重付费软件</h2><p>Robo 3T作为常用的MongoDB GUI，现在变成了Studio 3T Free。依旧是免费，但是在Windows下初次打开Studio 3T软件时，会要求必须登陆，然后开始一个月的Full product trial。这个就很烦，我就只想用免费版的，毕竟免费版就可以满足我的需求。体验试用是好事，但是当这件事成为必选项时，就会让人很不爽😕</p><p>所以在不进行非正规手段进行软件破解时，该如何进行跳过登陆激活进行免费版的使用呢？</p><p>找到位于<code>C:\Windows\System32\drivers\ect</code>下的<code>hosts</code>文件，将下面两行添加进去。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1        update.studio3t.com</span><br><span class="line">127.0.0.1        license-portal-eb.studio3t.com</span><br></pre></td></tr></table></figure><p>然后重启Studio 3T时，Product activation弹窗就会跳过<code>Login/Register</code>这一步，直接到达<code>Finish</code>。Nice! 大功告成。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;当Robo 3T变成了Studio 3T Free，不想试用Studio 3T的Full product。只想使用Robo 3T Free(Robo 3T)，该如何跳过一个月Full product的登陆试用呢？&lt;/p&gt;</summary>
    
    
    
    <category term="Tool" scheme="https://blog.eganx.cn/categories/Tool/"/>
    
    
    <category term="tool" scheme="https://blog.eganx.cn/tags/tool/"/>
    
    <category term="studio3t" scheme="https://blog.eganx.cn/tags/studio3t/"/>
    
  </entry>
  
  <entry>
    <title>Go Context</title>
    <link href="https://blog.eganx.cn/2022/11/04/Go_Context/"/>
    <id>https://blog.eganx.cn/2022/11/04/Go_Context/</id>
    <published>2022-11-04T03:45:19.000Z</published>
    <updated>2022-12-05T10:54:58.287Z</updated>
    
    <content type="html"><![CDATA[<p>context是Go的一个标准库，中文一般叫做”上下文”。context主要是用来在goroutine之间传递上下午信息，包括取消信号、超时时间等。context.Context类型的值可以协调多个goroutine中的代码执行“取消”操作，并且可以存储键值对。而且还是并发安全的。与它协作可以在API的外部控制执行“取消”操作，比如取消一个HTTP请求的执行。</p><span id="more"></span><h2 id="0x0-context的作用"><a href="#0x0-context的作用" class="headerlink" title="0x0.context的作用"></a>0x0.context的作用</h2><p>在http server中，一个请求有可能会起若干个协程，这些goroutine有时候是需要共享请求的基本数据的，包括token，超时时间和取消信号等。当请求迟迟得不到回应或者此次请求被取消，可能是使用者关闭了浏览器或已经超过了请求方的超时时间，请求方直接放弃了这次请求的结果。这个时候，所有为这个请求工作的goroutine需要快速退出，因为工作成果变成了无意义的。在相关的goroutine退出后，系统可以回收相关资源。</p><p>正常关闭协程是采用<code>channel+select</code>方式来控制。但是当一个请求相关联的协程数量过多，且相互关联，能够同时关闭，可以使用context来实现。</p><blockquote><p><font color=ligblue>context用来解决goroutine之间退出通知、元数据传递的功能。    </font></p></blockquote><p>context的使用建议：</p><ul><li><p>不要将 Context 塞到结构体里。直接将 Context 类型作为函数的第一参数，而且一般都命名为 ctx。</p></li><li><p>不要向函数传入一个 nil 的 context，如果你实在不知道传什么，标准库给你准备好了一个 context：todo。</p></li><li><p>不要把本应该作为函数参数的类型塞到 context 中，context 存储的应该是一些共同的数据。例如：登陆的 session、cookie 等。</p></li><li><p>同一个 context 可能会被传递到多个 goroutine，别担心，context 是并发安全的。</p></li></ul><h3 id="1-传递共享的数据"><a href="#1-传递共享的数据" class="headerlink" title="1).传递共享的数据"></a>1).传递共享的数据</h3><p>对于web服务端开发，往往希望将一个请求处理的整个过程串起来，因此需要在函数调用的时候传递context。</p><p>context的常见创建函数：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建空白的根节点context</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Background</span><span class="params">()</span> <span class="title">Context</span></span> </span><br><span class="line"><span class="comment">// 创建子节点context</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithCancel</span><span class="params">(parent Context)</span> <span class="params">(ctx Context, cancel CancelFunc)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithDeadline</span><span class="params">(parent Context, deadline time.Time)</span> <span class="params">(Context, CancelFunc)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithTimeout</span><span class="params">(parent Context, timeout time.Duration)</span> <span class="params">(Context, CancelFunc)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithValue</span><span class="params">(parent Context, key, val <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">Context</span></span></span><br></pre></td></tr></table></figure><h3 id="2-取消goroutine"><a href="#2-取消goroutine" class="headerlink" title="2).取消goroutine"></a>2).取消goroutine</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">func_eg</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        ... <span class="comment">// 业务代码：1秒刷新1次</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">            <span class="comment">// 被取消，直接返回</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">case</span> &lt;-time.After(time.Second):</span><br><span class="line">            <span class="comment">// block 1 秒钟 </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main</span></span><br><span class="line">ctx, cancel := context.WithTimeout(context.Background(), time.Hour)</span><br><span class="line"><span class="keyword">go</span> func_eg(ctx)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端取消时，调用cancel函数</span></span><br><span class="line">cancel()</span><br></pre></td></tr></table></figure><p><code>cancel()</code>函数返回的context和cancelFun是分开的。context本身是没有cancel函数，保证取消函数只能由外部调用，防止子节点context调用取消函数，从而严格控制信息流从父节点context流向子节点context。</p><h3 id="3-防止goroutine泄露"><a href="#3-防止goroutine泄露" class="headerlink" title="3).防止goroutine泄露"></a>3).防止goroutine泄露</h3><p>某些goroutine处于无限循环状态，若无外部取消函数，会造成系统资源泄露。</p><h2 id="0x1-context详细解析"><a href="#0x1-context详细解析" class="headerlink" title="0x1.context详细解析"></a>0x1.context详细解析</h2><table><thead><tr><th>类型</th><th>名称</th><th>作用</th></tr></thead><tbody><tr><td>Context</td><td>接口</td><td>定义了 Context 接口的四个方法</td></tr><tr><td>emptyCtx</td><td>结构体</td><td>实现了 Context 接口，它其实是个空的 context</td></tr><tr><td>CancelFunc</td><td>函数</td><td>取消函数</td></tr><tr><td>canceler</td><td>接口</td><td>context 取消接口，定义了两个方法</td></tr><tr><td>cancelCtx</td><td>结构体</td><td>可以被取消</td></tr><tr><td>timerCtx</td><td>结构体</td><td>超时会被取消</td></tr><tr><td>valueCtx</td><td>结构体</td><td>可以存储 k-v 对</td></tr><tr><td>Background</td><td>函数</td><td>返回一个空的 context，常作为根 context</td></tr><tr><td>TODO</td><td>函数</td><td>返回一个空的 context，常用于重构时期，没有合适的 context 可用</td></tr><tr><td>WithCancel</td><td>函数</td><td>基于父 context，生成一个可以取消的 context</td></tr><tr><td>newCancelCtx</td><td>函数</td><td>创建一个可取消的 context</td></tr><tr><td>propagateCancel</td><td>函数</td><td>向下传递 context 节点间的取消关系</td></tr><tr><td>parentCancelCtx</td><td>函数</td><td>找到第一个可取消的父节点</td></tr><tr><td>removeChild</td><td>函数</td><td>去掉父节点的孩子节点</td></tr><tr><td>init</td><td>函数</td><td>包初始化</td></tr><tr><td>WithDeadline</td><td>函数</td><td>创建一个有 deadline 的 context</td></tr><tr><td>WithTimeout</td><td>函数</td><td>创建一个有 timeout 的 context</td></tr><tr><td>WithValue</td><td>函数</td><td>创建一个存储 k-v 对的 context</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;p&gt;context是Go的一个标准库，中文一般叫做”上下文”。context主要是用来在goroutine之间传递上下午信息，包括取消信号、超时时间等。context.Context类型的值可以协调多个goroutine中的代码执行“取消”操作，并且可以存储键值对。而且还是并发安全的。与它协作可以在API的外部控制执行“取消”操作，比如取消一个HTTP请求的执行。&lt;/p&gt;</summary>
    
    
    
    <category term="Golang" scheme="https://blog.eganx.cn/categories/Golang/"/>
    
    
    <category term="go" scheme="https://blog.eganx.cn/tags/go/"/>
    
    <category term="context" scheme="https://blog.eganx.cn/tags/context/"/>
    
  </entry>
  
  <entry>
    <title>Go Channel关闭方式</title>
    <link href="https://blog.eganx.cn/2022/11/02/Go_Channel_Close/"/>
    <id>https://blog.eganx.cn/2022/11/02/Go_Channel_Close/</id>
    <published>2022-11-02T15:56:54.000Z</published>
    <updated>2022-11-24T07:06:51.771Z</updated>
    
    <content type="html"><![CDATA[<p>channel的关闭是比较头疼的，搞不好就panic。直接panic-recover要被喷莽夫，不优雅。所以找了很多资料，总结一下channel的关闭过程，常见的关闭方式和优雅的关闭方式（<strong>没有人会比福杰一家还要优雅</strong>）</p><span id="more"></span><h2 id="0x0-关闭chan过程"><a href="#0x0-关闭chan过程" class="headerlink" title="0x0.关闭chan过程"></a>0x0.关闭chan过程</h2><p>关闭channel的执行函数是<code>closechan</code>，源码如下</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// go version: go1.18.2</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">closechan</span><span class="params">(c *hchan)</span></span> &#123;</span><br><span class="line"><span class="comment">// 关闭一个nil channel，直接panic。</span></span><br><span class="line">  <span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(plainError(<span class="string">&quot;close of nil channel&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 锁</span></span><br><span class="line">lock(&amp;c.lock)</span><br><span class="line">  <span class="comment">// channel已经关闭</span></span><br><span class="line"><span class="keyword">if</span> c.closed != <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// 解锁，然后panic</span></span><br><span class="line">    unlock(&amp;c.lock)</span><br><span class="line"><span class="built_in">panic</span>(plainError(<span class="string">&quot;close of closed channel&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">callerpc := getcallerpc()</span><br><span class="line">racewritepc(c.raceaddr(), callerpc, abi.FuncPCABIInternal(closechan))</span><br><span class="line">racerelease(c.raceaddr())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置chan已关闭</span></span><br><span class="line">c.closed = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> glist gList</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 释放channel里所有等待接收队列里的sudog</span></span><br><span class="line"><span class="comment">// release all readers</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">sg := c.recvq.dequeue()</span><br><span class="line"><span class="keyword">if</span> sg == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// elem不为空，还想要接收数据，给个相对应类型的零值。</span></span><br><span class="line"><span class="keyword">if</span> sg.elem != <span class="literal">nil</span> &#123;</span><br><span class="line">typedmemclr(c.elemtype, sg.elem)</span><br><span class="line">sg.elem = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> sg.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">sg.releasetime = cputicks()</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 取出goroutine</span></span><br><span class="line">gp := sg.g</span><br><span class="line">gp.param = unsafe.Pointer(sg)</span><br><span class="line">sg.success = <span class="literal">false</span></span><br><span class="line"><span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">raceacquireg(gp, c.raceaddr())</span><br><span class="line">&#125;</span><br><span class="line">glist.push(gp)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 释放channel里所有等待发送队列里的sudog，同时这些goroutine将会panic。</span></span><br><span class="line"><span class="comment">// release all writers (they will panic)</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">sg := c.sendq.dequeue()</span><br><span class="line"><span class="keyword">if</span> sg == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">sg.elem = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">if</span> sg.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">sg.releasetime = cputicks()</span><br><span class="line">&#125;</span><br><span class="line">gp := sg.g</span><br><span class="line">gp.param = unsafe.Pointer(sg)</span><br><span class="line">sg.success = <span class="literal">false</span></span><br><span class="line"><span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">raceacquireg(gp, c.raceaddr())</span><br><span class="line">&#125;</span><br><span class="line">glist.push(gp)</span><br><span class="line">&#125;</span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Ready all Gs now that we&#x27;ve dropped the channel lock.</span></span><br><span class="line">  <span class="comment">// 遍历glist，唤醒goroutine</span></span><br><span class="line"><span class="keyword">for</span> !glist.empty() &#123;</span><br><span class="line">gp := glist.pop()</span><br><span class="line">gp.schedlink = <span class="number">0</span></span><br><span class="line">goready(gp, <span class="number">3</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将<code>recvq</code>和<code>sendq</code>两个队列中的Goroutine加入到gList中，并清除掉所有sudog上未被处理掉元素。最后将glist中所有的goroutine加到调度队列，等待被唤醒。</p><blockquote><p><font color=red>发送者在被唤醒之后会panic。</font></p></blockquote><p>总结一下:</p><table><thead><tr><th align="center">操作</th><th align="center">closed channel</th></tr></thead><tbody><tr><td align="center">关闭(close)</td><td align="center">panic</td></tr><tr><td align="center">发送(c&lt;-)</td><td align="center">panic</td></tr><tr><td align="center">接收(&lt;-c)</td><td align="center">永远不阻塞</td></tr></tbody></table><h2 id="0x1-关闭channel的常见方式"><a href="#0x1-关闭channel的常见方式" class="headerlink" title="0x1.关闭channel的常见方式"></a>0x1.关闭channel的常见方式</h2><p>channel的关闭与否都有可能造成panic。如何获取channel是否关闭和如何稳妥的关闭channel是非常重要的事情‼️</p><ul><li>在不改变channel自身状态的情况下，无法获知一个channel是否关闭。</li><li>关闭一个closed channel会导致panic。所以在关闭channel的时候，关闭的一方在不清楚当前channel是否关闭的情况下去关闭channel是很危险的⚠️。</li><li>向一个closed channel发送数据会导致panic。同上，在发送方不知道channel是否关闭的情况下向channel发送数据，也是很危险的⚠️</li></ul><p>关闭channel原则：</p><blockquote><p>一般原则上使用channel是不允许接收方关闭channel和 <strong>不能关闭一个有多个并发发送者的channel</strong>。 换而言之， 你只能在发送方的 goroutine 中关闭只有该发送方的channel。</p></blockquote><h3 id="1-defer-recover粗暴关闭channel"><a href="#1-defer-recover粗暴关闭channel" class="headerlink" title="1).defer-recover粗暴关闭channel"></a>1).<strong>defer-recover粗暴关闭channel</strong></h3><p>使用defer-recover机制来确保程序不会因panic而崩溃，然后直接关闭chan。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SafeClose</span><span class="params">(ch <span class="keyword">chan</span> T)</span> <span class="params">(justClosed <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">recover</span>() != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// 返回值可以被修改</span></span><br><span class="line">            <span class="comment">// 在一个延时函数的调用中。</span></span><br><span class="line">            justClosed = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 假设这里 ch != nil 。</span></span><br><span class="line">    <span class="built_in">close</span>(ch)   <span class="comment">// 如果 ch 已经被关闭将会引发 panic</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span> <span class="comment">// &lt;=&gt; justClosed = true; return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的思想也可以用在发送方，确保向closed channel发送数据不会造成程序崩了。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SafeSend</span><span class="params">(ch <span class="keyword">chan</span> T, value T)</span> <span class="params">(closed <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">recover</span>() != <span class="literal">nil</span> &#123;</span><br><span class="line">            closed = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    ch &lt;- value  <span class="comment">// 如果 ch 已经被关闭将会引发 panic</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span> <span class="comment">// &lt;=&gt; closed = false; return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的方法虽然处理了panic，但是并没有避免panic的发生。</p><h3 id="2-使用sync-Once关闭channel"><a href="#2-使用sync-Once关闭channel" class="headerlink" title="2).使用sync.Once关闭channel"></a>2).<strong>使用sync.Once关闭channel</strong></h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> MyChannel <span class="keyword">struct</span> &#123;</span><br><span class="line">    C    <span class="keyword">chan</span> T</span><br><span class="line">    once sync.Once</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewMyChannel</span><span class="params">()</span> *<span class="title">MyChannel</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;MyChannel&#123;C: <span class="built_in">make</span>(<span class="keyword">chan</span> T)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mc *MyChannel)</span> <span class="title">SafeClose</span><span class="params">()</span></span> &#123;</span><br><span class="line">    mc.once.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">close</span>(mc.C)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-使用sync-Mutex避免多次关闭同一个channel"><a href="#3-使用sync-Mutex避免多次关闭同一个channel" class="headerlink" title="3).使用sync.Mutex避免多次关闭同一个channel"></a>3).<strong>使用sync.Mutex避免多次关闭同一个channel</strong></h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> MyChannel <span class="keyword">struct</span> &#123;</span><br><span class="line">    C      <span class="keyword">chan</span> T</span><br><span class="line">    closed <span class="keyword">bool</span></span><br><span class="line">    mutex  sync.Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewMyChannel</span><span class="params">()</span> *<span class="title">MyChannel</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;MyChannel&#123;C: <span class="built_in">make</span>(<span class="keyword">chan</span> T)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mc *MyChannel)</span> <span class="title">SafeClose</span><span class="params">()</span></span> &#123;</span><br><span class="line">    mc.mutex.Lock()</span><br><span class="line">    <span class="keyword">defer</span> mc.mutex.Unlock()</span><br><span class="line">    <span class="keyword">if</span> !mc.closed &#123;</span><br><span class="line">        <span class="built_in">close</span>(mc.C)</span><br><span class="line">        mc.closed = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mc *MyChannel)</span> <span class="title">IsClosed</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    mc.mutex.Lock()</span><br><span class="line">    <span class="keyword">defer</span> mc.mutex.Unlock()</span><br><span class="line">    <span class="keyword">return</span> mc.closed</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0x2-优雅的关闭channel"><a href="#0x2-优雅的关闭channel" class="headerlink" title="0x2.优雅的关闭channel"></a>0x2.优雅的关闭channel</h2><p>上面的几种关闭channel的方式，用的人应该不少(说实话，我也很喜欢使用<code>sync.Once</code>的方式去关闭channel)。但是，有许多人认为代码在考虑业务实现的同时，应该优雅优雅再优雅！（舍监表示很开心！阿尼亚表示很难受！）</p><p>那么如何优雅的关闭channel？按照发送者和接收者的数量可以分为以下四种：</p><blockquote><p><font color = ligblue>1. 一个 sender，一个 receiver</font><br><font color = ligblue>2. 一个 sender， N个 receiver</font><br><font color = ligblue>3. M个 sender， 一个 receiver</font><br><font color = ligblue>4. M个 sender， N个 receiver</font></p></blockquote><h3 id="1-只有一个发送者，关闭唯一的发送者"><a href="#1-只有一个发送者，关闭唯一的发送者" class="headerlink" title="1).只有一个发送者，关闭唯一的发送者"></a>1).只有一个发送者，关闭唯一的发送者</h3><p>第一种和第二种情况比较好处理，因为只有一个发送者，只需要关闭唯一的发送者就可以。<code>sync.WaitGroup</code> 会被用于完成例子。 它在实践中并不是必要的。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">    <span class="string">&quot;math/rand&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    rand.Seed(time.Now().UnixNano())</span><br><span class="line">    log.SetFlags(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> MaxRandomNumber = <span class="number">100000</span></span><br><span class="line">    <span class="keyword">const</span> NumReceivers = <span class="number">100</span></span><br><span class="line"></span><br><span class="line">    wgReceivers := sync.WaitGroup&#123;&#125;</span><br><span class="line">    wgReceivers.Add(NumReceivers)</span><br><span class="line"></span><br><span class="line">    dataCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送者</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> value := rand.Intn(MaxRandomNumber); value == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="comment">// 唯一的发送者可以安全地关闭通道。</span></span><br><span class="line">                <span class="built_in">close</span>(dataCh)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;            </span><br><span class="line">                dataCh &lt;- value</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收者</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; NumReceivers; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> wgReceivers.Done()</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 接收数据直到 dataCh 被关闭或者</span></span><br><span class="line">            <span class="comment">// dataCh 的数据缓存队列是空的。</span></span><br><span class="line">            <span class="keyword">for</span> value := <span class="keyword">range</span> dataCh &#123;</span><br><span class="line">                log.Println(value)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wgReceivers.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-多个发送者，一个接收者。"><a href="#2-多个发送者，一个接收者。" class="headerlink" title="2).多个发送者，一个接收者。"></a>2).多个发送者，一个接收者。</h3><p>接收者通过关闭一个channel，告诉发送者不要再发了。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">    <span class="string">&quot;math/rand&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    rand.Seed(time.Now().UnixNano())</span><br><span class="line">    log.SetFlags(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">const</span> MaxRandomNumber = <span class="number">100000</span></span><br><span class="line">    <span class="keyword">const</span> NumSenders = <span class="number">1000</span></span><br><span class="line"></span><br><span class="line">    wgReceivers := sync.WaitGroup&#123;&#125;</span><br><span class="line">    wgReceivers.Add(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    dataCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">100</span>)</span><br><span class="line">    stopCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">        <span class="comment">// stopCh 是一个信号通道。</span></span><br><span class="line">        <span class="comment">// 它的发送者是 dataCh 的接收者。</span></span><br><span class="line">        <span class="comment">// 它的接收者是 dataCh 的发送者。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送者</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; NumSenders; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">for</span> &#123;</span><br><span class="line">                <span class="keyword">select</span> &#123;</span><br><span class="line">                <span class="keyword">case</span> &lt;- stopCh:</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                <span class="keyword">case</span> dataCh &lt;- rand.Intn(MaxRandomNumber):</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收者</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> wgReceivers.Done()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> value := <span class="keyword">range</span> dataCh &#123;</span><br><span class="line">            <span class="keyword">if</span> value == MaxRandomNumber<span class="number">-1</span> &#123;</span><br><span class="line">                <span class="comment">// dataCh 通道的接收者也是 stopCh 通道的发送者。</span></span><br><span class="line">                <span class="comment">// 在这里关闭停止通道是安全的。.</span></span><br><span class="line">                <span class="built_in">close</span>(stopCh)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            log.Println(value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    wgReceivers.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-多个发送者，多个接收者。"><a href="#3-多个发送者，多个接收者。" class="headerlink" title="3).多个发送者，多个接收者。"></a>3).多个发送者，多个接收者。</h3><p>当发送者和接收者都是多个的时候，没办法通过任何一方去终止这场游戏。因此需要增加一个中间人的角色来处理。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">    <span class="string">&quot;math/rand&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    rand.Seed(time.Now().UnixNano())</span><br><span class="line">    log.SetFlags(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">const</span> MaxRandomNumber = <span class="number">100000</span></span><br><span class="line">    <span class="keyword">const</span> NumReceivers = <span class="number">100</span></span><br><span class="line">    <span class="keyword">const</span> NumSenders = <span class="number">1000</span></span><br><span class="line"></span><br><span class="line">    wgReceivers := sync.WaitGroup&#123;&#125;</span><br><span class="line">    wgReceivers.Add(NumReceivers)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    dataCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">100</span>)</span><br><span class="line">    stopCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">        <span class="comment">// stopCh 是一个信号通道。</span></span><br><span class="line">        <span class="comment">// 它的发送者是下面的主持人 goroutine。</span></span><br><span class="line">        <span class="comment">// 它的接收者是 dataCh的所有发送者和接收者。</span></span><br><span class="line">    toStop := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">1</span>)</span><br><span class="line">        <span class="comment">// toStop 通道通常用来通知主持人去关闭信号通道( stopCh )。</span></span><br><span class="line">        <span class="comment">// 它的发送者是 dataCh的任意发送者和接收者。</span></span><br><span class="line">        <span class="comment">// 它的接收者是下面的主持人 goroutine</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> stoppedBy <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主持人</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        stoppedBy = &lt;-toStop</span><br><span class="line">        <span class="built_in">close</span>(stopCh)</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送者</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; NumSenders; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(id <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">for</span> &#123;</span><br><span class="line">                value := rand.Intn(MaxRandomNumber)</span><br><span class="line">                <span class="keyword">if</span> value == <span class="number">0</span> &#123;</span><br><span class="line">                    <span class="comment">// 用于通知主持人关闭信号通道。</span></span><br><span class="line">                    <span class="keyword">select</span> &#123;</span><br><span class="line">                    <span class="keyword">case</span> toStop &lt;- <span class="string">&quot;sender#&quot;</span> + id:</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">select</span> &#123;</span><br><span class="line">                <span class="keyword">case</span> &lt;- stopCh:</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                <span class="keyword">case</span> dataCh &lt;- value:</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;(strconv.Itoa(i))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收者</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; NumReceivers; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(id <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> wgReceivers.Done()</span><br><span class="line">            <span class="keyword">for</span> &#123;</span><br><span class="line">                <span class="keyword">select</span> &#123;</span><br><span class="line">                <span class="keyword">case</span> &lt;- stopCh:</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                <span class="keyword">case</span> value := &lt;-dataCh:</span><br><span class="line">                    <span class="keyword">if</span> value == MaxRandomNumber<span class="number">-1</span> &#123;</span><br><span class="line">                        <span class="comment">// 同样用于通知主持人去关闭信号通道。</span></span><br><span class="line">                        <span class="keyword">select</span> &#123;</span><br><span class="line">                        <span class="keyword">case</span> toStop &lt;- <span class="string">&quot;receiver#&quot;</span> + id:</span><br><span class="line">                        <span class="keyword">default</span>:</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">return</span></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    log.Println(value)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;(strconv.Itoa(i))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    wgReceivers.Wait()</span><br><span class="line">    log.Println(<span class="string">&quot;stopped by&quot;</span>, stoppedBy)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时<code>toStop</code>通道的缓存大小是1。不使用非缓冲型channel是为了避免第一个关闭信号在主持人准备好从<code>toStop</code>接收数据之前发送，造成丢失。</p><p>也可以设置<code>toStop</code>通道的buf为发送者和接收者数量之和。toStop的容量足够的时候，就不用担心阻塞了。也就不需要借助select语句了。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">toStop := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, NumReceivers + NumSenders)</span><br><span class="line">...</span><br><span class="line">            value := rand.Intn(MaxRandomNumber)</span><br><span class="line">            <span class="keyword">if</span> value == <span class="number">0</span> &#123;</span><br><span class="line">                toStop &lt;- <span class="string">&quot;sender#&quot;</span> + id</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">...</span><br><span class="line">                <span class="keyword">if</span> value == MaxRandomNumber<span class="number">-1</span> &#123;</span><br><span class="line">                    toStop &lt;- <span class="string">&quot;receiver#&quot;</span> + id</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><font color = green>Q&amp;A: 关闭的channel还能读吗？</font></p><blockquote><p>可以。从一个带缓冲的chan里读取数据时，当channel被关闭，是可以读到有效值的。可以是comma-ok的方式读取chan数据，当ok值为false时，说明channel已经关闭且通道无数据，读出的数据开始无效。</p></blockquote><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">3</span>)</span><br><span class="line">ch &lt;- <span class="number">0</span></span><br><span class="line">ch &lt;- <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">close</span>(ch)</span><br><span class="line">x, ok := &lt;-ch</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;received: &quot;</span>, x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">y, ok := &lt;-ch</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;received: &quot;</span>, y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">z, ok := &lt;-ch</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;received false &quot;</span>, z)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果：<br>received:  0<br>received:  1<br>received false:  0</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;channel的关闭是比较头疼的，搞不好就panic。直接panic-recover要被喷莽夫，不优雅。所以找了很多资料，总结一下channel的关闭过程，常见的关闭方式和优雅的关闭方式（&lt;strong&gt;没有人会比福杰一家还要优雅&lt;/strong&gt;）&lt;/p&gt;</summary>
    
    
    
    <category term="Golang" scheme="https://blog.eganx.cn/categories/Golang/"/>
    
    
    <category term="go" scheme="https://blog.eganx.cn/tags/go/"/>
    
    <category term="channel" scheme="https://blog.eganx.cn/tags/channel/"/>
    
  </entry>
  
  <entry>
    <title>Go Channel数据结构和创建</title>
    <link href="https://blog.eganx.cn/2022/11/01/Go_Channel_DS/"/>
    <id>https://blog.eganx.cn/2022/11/01/Go_Channel_DS/</id>
    <published>2022-11-01T13:09:13.000Z</published>
    <updated>2022-11-24T06:59:34.802Z</updated>
    
    <content type="html"><![CDATA[<p>Go语言的并发是最好用的，而channel也算是Go语言并发机制的半壁江山了。</p><span id="more"></span><h2 id="0x0-CSP"><a href="#0x0-CSP" class="headerlink" title="0x0.CSP"></a>0x0.CSP</h2><p>CSP全称“Communicating Sequential Processes”，中文可以叫做通信顺序进程。go的并发是基于channel实现，依赖的就是CSP模型。CSP描述了并发系统中的互动模式，实际上Go只是用到了CSP理论中一部分，即理论中的Process/Channel，在Go中对应goroutine/channel。这两个并发原语之间没有从属关系， Process 可以订阅任意个 Channel，Channel 也并不关心是哪个 Process 在利用它进行通信；Process 围绕 Channel 进行读写，形成一套有序阻塞和可预测的并发模型。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">┌─────────────┐     ┌─────────────┐      ┌─────────────┐</span><br><span class="line">│             │     │             │      │             │</span><br><span class="line">│  Goroutine  ├────►│   Channel   ├─────►│  Goroutine  │</span><br><span class="line">│             │     │             │      │             │</span><br><span class="line">└─────────────┘     └─────────────┘      └─────────────┘</span><br></pre></td></tr></table></figure><p>Goroutine + channel支撑起了Go语言的并发机制。</p><h2 id="0x1-channel数据结构"><a href="#0x1-channel数据结构" class="headerlink" title="0x1.channel数据结构"></a>0x1.channel数据结构</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123;</span><br><span class="line">qcount   <span class="keyword">uint</span>           <span class="comment">// total data in the queue //循环队列元素个数</span></span><br><span class="line">dataqsiz <span class="keyword">uint</span>           <span class="comment">// size of the circular queue //循环队列大小</span></span><br><span class="line">buf      unsafe.Pointer <span class="comment">// points to an array of dataqsiz elements //循环队列指针</span></span><br><span class="line">elemsize <span class="keyword">uint16</span> <span class="comment">//chan元素大小</span></span><br><span class="line">closed   <span class="keyword">uint32</span> <span class="comment">//是否已经关闭</span></span><br><span class="line">elemtype *_type <span class="comment">// element type //chan元素类型</span></span><br><span class="line">sendx    <span class="keyword">uint</span>   <span class="comment">// send index //chan发送操作处理到的位置</span></span><br><span class="line">recvx    <span class="keyword">uint</span>   <span class="comment">// receive index //chan接收操作处理到的位置</span></span><br><span class="line">recvq    waitq  <span class="comment">// list of recv waiters //等待接收数据的goroutine列表</span></span><br><span class="line">sendq    waitq  <span class="comment">// list of send waiters //等待发送数据的goroutine列表</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// lock protects all fields in hchan, as well as several</span></span><br><span class="line"><span class="comment">// fields in sudogs blocked on this channel.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Do not change another G&#x27;s status while holding this lock</span></span><br><span class="line"><span class="comment">// (in particular, do not ready a G), as this can deadlock</span></span><br><span class="line"><span class="comment">// with stack shrinking.</span></span><br><span class="line">lock mutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>buf</code>字段只有在缓冲型的channel才有，指向底层的循环数组。</p><p><code>sendx</code>和<code>recvx</code>分别表示已发送和已接收的元素在循环数组中的索引。</p><p><code>sendq</code>和<code>recvq</code>分别表示等待接收和等待发送的goroutine队列。这些goroutine由于尝试读取channel或者向channel发送数据而被阻塞。</p><p><code>lock</code>用来保护hchan中所有的字段。保证每个channel的读写都是原子的。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sudog 双向列表，sudog实际上是对goroutine的一个封装。</span></span><br><span class="line"><span class="keyword">type</span> waitq <span class="keyword">struct</span> &#123;</span><br><span class="line">first *sudog</span><br><span class="line">last  *sudog</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> ┌─────┐</span><br><span class="line"> │hchan│</span><br><span class="line"> ├─────┴────────────┐</span><br><span class="line">5│   qcount uint    │</span><br><span class="line"> ├──────────────────┤</span><br><span class="line">8│  dataqsiz uint   │                 0   1   2   3   4   5   6   7</span><br><span class="line"> ├──────────────────┤               ┌───┬───┬───┬───┬───┬───┬───┬───┐</span><br><span class="line"> │buf unsafe.Pointer├──────────────►│ a │ b │ c │ d │ e │   │   │   │</span><br><span class="line"> ├──────────────────┤               └───┴───┴───┴───┴───┴───┴───┴───┘</span><br><span class="line"> │ elemsize uint16  │                 ▲                   ▲</span><br><span class="line"> ├──────────────────┤                 │                   │</span><br><span class="line"> │  closed uint32   │                 │                   │</span><br><span class="line"> ├──────────────────┤                 │                   │</span><br><span class="line"> │  elemtype *_type │                 │                   │</span><br><span class="line"> ├──────────────────┤                 │                   │</span><br><span class="line">0│    sendx uint    ├─────────────────┘                   │</span><br><span class="line"> ├──────────────────┤                                     │</span><br><span class="line">5│    recvx uint    ├─────────────────────────────────────┘</span><br><span class="line"> ├──────────────────┤</span><br><span class="line"> │    recvq waitq   ├─────────┬───────────────────────────────────────────┐</span><br><span class="line"> ├──────────────────┤         │                                           │</span><br><span class="line"> │    sendq waitq   ├─────┐   │   ┌───────┐     ┌───────┐     ┌───────┐   │</span><br><span class="line"> ├──────────────────┤     │   └──►│ sudog │◄───►│ sudog │◄───►│ sudog │◄──┘</span><br><span class="line"> │    lock mutex    │     │       └───────┘     └───────┘     └───────┘</span><br><span class="line"> └──────────────────┘     │</span><br><span class="line">                          │</span><br><span class="line">                          │       ┌───────┐     ┌───────┐     ┌───────┐</span><br><span class="line">                          │   ┌──►│ sudog │◄───►│ sudog │◄───►│ sudog │◄──┐</span><br><span class="line">                          │   │   └───────┘     └───────┘     └───────┘   │</span><br><span class="line">                          │   │                                           │</span><br><span class="line">                          └───┴───────────────────────────────────────────┘</span><br></pre></td></tr></table></figure><h2 id="0x2-创建channel"><a href="#0x2-创建channel" class="headerlink" title="0x2.创建channel"></a>0x2.创建channel</h2><p>创建<code>chan</code>一般使用<code>make</code>关键字。其中<code>chan</code>的类型分为有无缓冲两种模式。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>) <span class="comment">//无缓冲</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">2</span>) <span class="comment">//有缓冲</span></span><br></pre></td></tr></table></figure><p>翻翻源码，有些看不太明白，只能是能看多少看多少了😭。在runtime/chan.go中都是使用<code>makechan</code>来创建<code>chan</code>。中文是个人注释，英文是官方注释。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">maxAlign  = <span class="number">8</span></span><br><span class="line">hchanSize = unsafe.Sizeof(hchan&#123;&#125;) + <span class="keyword">uintptr</span>(-<span class="keyword">int</span>(unsafe.Sizeof(hchan&#123;&#125;))&amp;(maxAlign<span class="number">-1</span>)) <span class="comment">//hchan结构体大小</span></span><br><span class="line">debugChan = <span class="literal">false</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makechan64</span><span class="params">(t *chantype, size <span class="keyword">int64</span>)</span> *<span class="title">hchan</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">int64</span>(<span class="keyword">int</span>(size)) != size &#123;</span><br><span class="line"><span class="built_in">panic</span>(plainError(<span class="string">&quot;makechan: size out of range&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> makechan(t, <span class="keyword">int</span>(size))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makechan</span><span class="params">(t *chantype, size <span class="keyword">int</span>)</span> *<span class="title">hchan</span></span> &#123;</span><br><span class="line">elem := t.elem</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 检查channel size和align</span></span><br><span class="line"><span class="comment">// compiler checks this but be safe.</span></span><br><span class="line"><span class="keyword">if</span> elem.size &gt;= <span class="number">1</span>&lt;&lt;<span class="number">16</span> &#123;</span><br><span class="line">throw(<span class="string">&quot;makechan: invalid channel element type&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> hchanSize%maxAlign != <span class="number">0</span> || elem.align &gt; maxAlign &#123;</span><br><span class="line">throw(<span class="string">&quot;makechan: bad alignment&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 元素大小*个数，计算buf需要的内存大小</span></span><br><span class="line">mem, overflow := math.MulUintptr(elem.size, <span class="keyword">uintptr</span>(size))</span><br><span class="line"><span class="keyword">if</span> overflow || mem &gt; maxAlloc-hchanSize || size &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(plainError(<span class="string">&quot;makechan: size out of range&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Hchan does not contain pointers interesting for GC when elements stored in buf do not contain pointers.</span></span><br><span class="line"><span class="comment">// buf points into the same allocation, elemtype is persistent.</span></span><br><span class="line"><span class="comment">// SudoG&#x27;s are referenced from their owning thread so they can&#x27;t be collected.</span></span><br><span class="line"><span class="comment">// TODO(dvyukov,rlh): Rethink when collector can move allocated objects.</span></span><br><span class="line"><span class="keyword">var</span> c *hchan</span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line">  <span class="comment">// 表示元素大小为零或者缓冲区大小为0（无缓冲类型），不需要创建buf。只进行一次内存分配。分配内存的大小就是hchan结构体大小。</span></span><br><span class="line"><span class="keyword">case</span> mem == <span class="number">0</span>:</span><br><span class="line"><span class="comment">// Queue or element size is zero.</span></span><br><span class="line">c = (*hchan)(mallocgc(hchanSize, <span class="literal">nil</span>, <span class="literal">true</span>))</span><br><span class="line"><span class="comment">// Race detector uses this location for synchronization.</span></span><br><span class="line">c.buf = c.raceaddr()</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 元素类型不含指针，进行一次内存分配，分配一块连续的内存，大小是“hchan结构体大小+个数*元素大小”。</span></span><br><span class="line">  <span class="comment">// 同时元素大小不等于0且是缓冲区大小不为0</span></span><br><span class="line"><span class="keyword">case</span> elem.ptrdata == <span class="number">0</span>:</span><br><span class="line"><span class="comment">// Elements do not contain pointers.</span></span><br><span class="line"><span class="comment">// Allocate hchan and buf in one call.</span></span><br><span class="line">c = (*hchan)(mallocgc(hchanSize+mem, <span class="literal">nil</span>, <span class="literal">true</span>))</span><br><span class="line">c.buf = add(unsafe.Pointer(c), hchanSize)</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 元素包含指针，缓冲区大小不为0，进行两次内存分配，单独为hchan和buf分配内存。</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="comment">// Elements contain pointers.</span></span><br><span class="line">c = <span class="built_in">new</span>(hchan)</span><br><span class="line">c.buf = mallocgc(mem, elem, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">c.elemsize = <span class="keyword">uint16</span>(elem.size)</span><br><span class="line">c.elemtype = elem</span><br><span class="line">c.dataqsiz = <span class="keyword">uint</span>(size)</span><br><span class="line">lockInit(&amp;c.lock, lockRankHchan)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> debugChan &#123;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;makechan: chan=&quot;</span>, c, <span class="string">&quot;; elemsize=&quot;</span>, elem.size, <span class="string">&quot;; dataqsiz=&quot;</span>, size, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据channel中收发的元素类型和缓冲区的大小，初始化hchan时有以下三种情况：</p><ul><li>元素大小为零或者缓冲区大小为0（无缓冲类型），不需要创建buf。进行一次内存分配。分配内存的大小就是hchan结构体大小。</li><li>元素大小和缓冲区大小均不为0，且元素类型不含指针。进行一次内存分配，分配一块连续的内存，大小是“hchan结构体大小+个数*元素大小”。</li><li>元素包含指针，缓冲区大小不为0。进行两次内存分配，单独为hchan和buf分配内存。</li></ul><h2 id="0x3-channel的基本应用"><a href="#0x3-channel的基本应用" class="headerlink" title="0x3.channel的基本应用"></a>0x3.channel的基本应用</h2><h3 id="1-超时处理"><a href="#1-超时处理" class="headerlink" title="1).超时处理"></a>1).超时处理</h3><p><code>res := &lt;- c1</code> 等待结果，<code>&lt;-time.After</code> 等待超时（1秒钟）以后发送的值。 由于 <code>select</code> 默认处理第一个已准备好的接收操作， 因此如果操作耗时超过了允许的 1 秒的话，将会执行超时 <code>case</code>。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    c1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">        c1 &lt;- <span class="string">&quot;result 1&quot;</span></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> res := &lt;-c1:</span><br><span class="line">        fmt.Println(res)</span><br><span class="line">    <span class="keyword">case</span> &lt;-time.After(<span class="number">1</span> * time.Second):</span><br><span class="line">        fmt.Println(<span class="string">&quot;timeout 1&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    c2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">        c2 &lt;- <span class="string">&quot;result 2&quot;</span></span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> res := &lt;-c2:</span><br><span class="line">        fmt.Println(res)</span><br><span class="line">    <span class="keyword">case</span> &lt;-time.After(<span class="number">3</span> * time.Second):</span><br><span class="line">        fmt.Println(<span class="string">&quot;timeout 2&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">timeout 1</span><br><span class="line">result 2</span><br></pre></td></tr></table></figure></blockquote><h3 id="2-控制并发"><a href="#2-控制并发" class="headerlink" title="2).控制并发"></a>2).控制并发</h3><p>构建一个缓冲型的 channel，容量为 3。接着遍历任务列表，每个任务启动一个 goroutine 去完成。真正执行任务，访问第三方的动作在 w() 中完成，在执行 w() 之前，先要从 limit 中拿“许可证”，拿到许可证之后，才能执行 w()，并且在执行完任务，要将“许可证”归还。这样就可以控制同时运行的 goroutine 数。如果 w() 发生 panic，那“许可证”可能就还不回去了，因此需要使用 defer 来保证。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> limit = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">// ......</span></span><br><span class="line">    <span class="keyword">for</span> _, w := <span class="keyword">range</span> work &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            limit &lt;- <span class="number">1</span></span><br><span class="line">            w()</span><br><span class="line">            &lt;-limit</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-生产者消费者模型"><a href="#3-生产者消费者模型" class="headerlink" title="3).生产者消费者模型"></a>3).生产者消费者模型</h3><p>并发编程中最常见的例子就是生产者消费者模式，该模式主要通过平衡生产线程和消费线程的工作能力来提高程序的整体处理数据的速度。简单地说，就是生产者生产一些数据，然后放到成果队列中，同时消费者从成果队列中来取这些数据。这样就让生产消费变成了异步的两个过程。当成果队列中没有数据时，消费者就进入饥饿的等待中；而当成果队列中数据已满时，生产者则面临因产品挤压导致 CPU 被剥夺的下岗问题。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 生产者: 生成 factor 整数倍的序列</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Producer</span><span class="params">(factor <span class="keyword">int</span>, out <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; ; i++ &#123;</span><br><span class="line">        out &lt;- i*factor</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Consumer</span><span class="params">(in &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> v := <span class="keyword">range</span> in &#123;</span><br><span class="line">        fmt.Println(v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">64</span>) <span class="comment">// 成果队列</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> Producer(<span class="number">3</span>, ch) <span class="comment">// 生成 3 的倍数的序列</span></span><br><span class="line">    <span class="keyword">go</span> Producer(<span class="number">5</span>, ch) <span class="comment">// 生成 5 的倍数的序列</span></span><br><span class="line">    <span class="keyword">go</span> Consumer(ch)    <span class="comment">// 消费生成的队列</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Ctrl+C 退出</span></span><br><span class="line">    sig := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal, <span class="number">1</span>)</span><br><span class="line">    signal.Notify(sig, syscall.SIGINT, syscall.SIGTERM)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;quit (%v)\n&quot;</span>, &lt;-sig)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;Go语言的并发是最好用的，而channel也算是Go语言并发机制的半壁江山了。&lt;/p&gt;</summary>
    
    
    
    <category term="Golang" scheme="https://blog.eganx.cn/categories/Golang/"/>
    
    
    <category term="go" scheme="https://blog.eganx.cn/tags/go/"/>
    
    <category term="channel" scheme="https://blog.eganx.cn/tags/channel/"/>
    
  </entry>
  
  <entry>
    <title>Go Interface理解(2)</title>
    <link href="https://blog.eganx.cn/2022/10/30/Go_Interface_2/"/>
    <id>https://blog.eganx.cn/2022/10/30/Go_Interface_2/</id>
    <published>2022-10-30T13:45:56.000Z</published>
    <updated>2022-11-22T06:15:48.152Z</updated>
    
    <content type="html"><![CDATA[<p>接口有动态值和动态类型，只有当两者都是nil的时候，才有<code>接口值==nil</code>。这很重要‼️ 接口变量时常需要进行类型断言，找到真实类型。这也很重要‼️</p><span id="more"></span><h2 id="0x0-空接口-amp-nil"><a href="#0x0-空接口-amp-nil" class="headerlink" title="0x0.空接口&amp;nil"></a>0x0.空接口&amp;nil</h2><p>上来一个经典问题：一个包含nil指针的接口是不是nil接口？这个是真坑，在判空的时候，有可能就中招了。</p><p>空接口(<code>interface&#123;&#125;</code>)不包含任何的方法，但与此同时，所有的类型都实现了<code>interface&#123;&#125;</code>。在存储任意类型的时候，<code>interface&#123;&#125;</code>相当的有用。</p><p>nil 不是关键字，是一个预先声明的标识符，指针、通道、函数、接口、map、切片的零值就是nil，nil 是没有默认类型的，他的类型具有不确定性，我们在使用它时必须要提供足够的信息能够让编译器 推断nil期望的类型;</p><p>两个nil不能进行比较，因为nil是无类型的;</p><blockquote><ol><li>声明一个nil的map，map可以读数据，但是不能写数据</li><li>关闭一个nil的channel会引发panic</li><li>nil切片不能进行索引访问，会引发panic</li><li>方法接收者为nil时，如果在方法内使用到了会引发panic </li><li>空指针一个没有任何值的指针</li></ol></blockquote><p>接口的底层结构体有<code>iface、eface</code>两种不同的表示。前者是有方法的接口，后者是无任何方法的空接口：<code>interface&#123;&#125;</code>。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//src/runtime/runtime2.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> iface <span class="keyword">struct</span> &#123;</span><br><span class="line">tab  *itab</span><br><span class="line">data unsafe.Pointer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> eface <span class="keyword">struct</span> &#123;</span><br><span class="line">_type *_type</span><br><span class="line">data  unsafe.Pointer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> itab <span class="keyword">struct</span> &#123;</span><br><span class="line">inter *interfacetype</span><br><span class="line">_type *_type</span><br><span class="line">hash  <span class="keyword">uint32</span> <span class="comment">// copy of _type.hash. Used for type switches.</span></span><br><span class="line">_     [<span class="number">4</span>]<span class="keyword">byte</span></span><br><span class="line">fun   [<span class="number">1</span>]<span class="keyword">uintptr</span> <span class="comment">// variable sized. fun[0]==0 means _type does not implement inter.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>iface</code> 内部维护两个指针，<code>tab</code> 指向一个 <code>itab</code> 实体， 它表示接口的类型以及赋给这个接口的实体类型。<code>data</code> 则指向接口具体的值，一般而言是一个指向堆内存的指针。<code>tab</code>和<code>data</code>也分别被称为动态类型和动态值，接口值包括动态类型和动态值。只有当接口的动态类型和动态值都为nil的时候，才有<code>接口值==nil</code>。</p><h2 id="0x1-接口类型断言"><a href="#0x1-接口类型断言" class="headerlink" title="0x1.接口类型断言"></a>0x1.接口类型断言</h2><p>隐士类型转换在Go中是不允许的，这个时候类型就需要进行转换成另一个类型。有两种方式实现：<code>类型转换</code>，<code>类型断言</code>。两者的不同之处在于<font color=lgiblue>类型断言是针对接口变量。</font></p><h3 id="1-类型转换"><a href="#1-类型转换" class="headerlink" title="1).类型转换"></a>1).类型转换</h3><p><code>&lt;结果&gt; := &lt;目标类型&gt;(&lt;表达式&gt;)</code></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">f = <span class="number">10.101</span></span><br><span class="line">i := <span class="keyword">int</span>(f)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%T, %v\n&quot;</span>, i, i) <span class="comment">//output: int, 10</span></span><br></pre></td></tr></table></figure><p>类型转换前后的两个类型需要相互兼容才可以，不然编译器会报错。</p><h3 id="2-类型断言"><a href="#2-类型断言" class="headerlink" title="2).类型断言"></a>2).类型断言</h3><p>因为空接口 <code>interface&#123;&#125;</code> 没有定义任何函数，因此 Go 中所有类型都实现了空接口。当一个函数的形参是 <code>interface&#123;&#125;</code>，那么在函数中，需要对形参进行断言，从而得到它的真实类型。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;目标类型的值&gt; :&#x3D; &lt;表达式&gt;.( 目标类型 )　　&#x2F;&#x2F;非安全类型断言</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Duck <span class="keyword">struct</span> &#123;</span><br><span class="line">age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> d <span class="keyword">interface</span>&#123;&#125; = <span class="built_in">new</span>(Duck)</span><br><span class="line">s := d.(Duck)</span><br><span class="line">fmt.Println(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//run main.go</span></span><br><span class="line"><span class="comment">//panic: &quot;interface conversion: interface &#123;&#125; is *main.Duck, not main.Duck&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;目标类型的值&gt;，&lt;布尔参数&gt; :&#x3D; &lt;表达式&gt;.( 目标类型 ) &#x2F;&#x2F; comma-ok断言,安全类型断言 </span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Duck <span class="keyword">struct</span> &#123;</span><br><span class="line">age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> d <span class="keyword">interface</span>&#123;&#125; = <span class="built_in">new</span>(Duck)</span><br><span class="line">s, ok := d.(Duck)</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">fmt.Println(s)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;d type is %T&quot;</span>, d)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//run main.go</span></span><br><span class="line"><span class="comment">//d type is *main.Duck</span></span><br></pre></td></tr></table></figure><p>尽量使用comma-ok断言，即使断言失败也不会panic。</p><p>断言其实也可以使用 <code>switch</code> 语句判断接口的类型，每一个 <code>case</code> 会被顺序地考虑。当命中一个 <code>case</code> 时，就会执行 <code>case</code> 中的语句，因此 <code>case</code> 语句的顺序是很重要的，因为很有可能会有多个 <code>case</code> 匹配的情况。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> m := m.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="literal">nil</span>:</span><br><span class="line"><span class="keyword">case</span> Duck:</span><br><span class="line"><span class="keyword">case</span> *Duck:</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;接口有动态值和动态类型，只有当两者都是nil的时候，才有&lt;code&gt;接口值==nil&lt;/code&gt;。这很重要‼️ 接口变量时常需要进行类型断言，找到真实类型。这也很重要‼️&lt;/p&gt;</summary>
    
    
    
    <category term="Golang" scheme="https://blog.eganx.cn/categories/Golang/"/>
    
    
    <category term="go" scheme="https://blog.eganx.cn/tags/go/"/>
    
    <category term="interface" scheme="https://blog.eganx.cn/tags/interface/"/>
    
  </entry>
  
  <entry>
    <title>Go Interface理解(1)</title>
    <link href="https://blog.eganx.cn/2022/10/29/Go_Interface_1/"/>
    <id>https://blog.eganx.cn/2022/10/29/Go_Interface_1/</id>
    <published>2022-10-29T11:23:19.000Z</published>
    <updated>2022-11-22T06:10:18.113Z</updated>
    
    <content type="html"><![CDATA[<p>Go语言中，接口是不需要像传统的静态编程语言一样进行声明后才能使用。它引用了动态语言的接口使用方式，只需要实现接口要求的相关方法就行，同时还会在编译阶段进行类型匹配，个人觉得非常好用。</p><span id="more"></span><h2 id="0x0-Interface-amp-Duck-Typing"><a href="#0x0-Interface-amp-Duck-Typing" class="headerlink" title="0x0.Interface &amp; Duck Typing"></a>0x0.Interface &amp; Duck Typing</h2><p>所谓Go语言式的接口，就是不用显示声明类型<code>T</code>实现了接口<code>I</code>，只要类型<code>T</code>的公开方法完全满足接口<code>I</code>的要求，就可以把类型<code>T</code>的对象用在需要接口<code>I</code>的地方。这种做法的学名叫做<a href="http://en.wikipedia.org/wiki/Structural_type_system">Structural Typing</a>，也有人称它为一种静态的Duck Typing。</p><p>Duck Typing一般常见于动态语言中（比如python），但是动态语言不会在编译阶段去进行类型匹配，只有在运行到当前行代码的时候才会报错。而传统的静态语言（比如Java），必须显示地去声明实现了某个接口，然后才可以去使用。这跟动态语言静态语言的讨论类似，可以讨论优缺点，但是不能以好坏去下结论。</p><p>Go语言本身作为一种静态语言，静态语言的类型检查是肯定有的。但是在接口的使用上，引用了动态语言的接口使用方式。即不要求类型显示地去声明实现了某个接口，只需要实现接口要求的相关方法就行，编译阶段会去进行类型检查。如果没有实现相关方法，编译是会报错的。</p><p>举个🌰：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> IDuck <span class="keyword">interface</span> &#123;</span><br><span class="line">gaga()</span><br><span class="line">swimming()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Duck <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d Duck)</span> <span class="title">gaga</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Duck gaga&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Duck)</span> <span class="title">swimming</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Duck swimming&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> _ IDuck = (*Duck)(<span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color=red><code>var _ IDuck = (*Duck)(nil)  //这个很实用，编译器会由此检查 *Duck类型是否实现了 IDuck 接口。</code></font></p><p>以上的代码编译可以通过，表示A实现了Duck接口，那么A就是一只鸭子🦆。</p><p>但是当注释了A的游泳方法时，就会出现编译器会直接爆出以下错误，表示A并没有完全实现Duck接口，A不是一只鸭子🦆。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// func (d *Duck) swimming() &#123;</span></span><br><span class="line"><span class="comment">// fmt.Println(&quot;Duck swimming&quot;)</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> _ IDuck = (*Duck)(<span class="literal">nil</span>) <span class="comment">//编译报错：cannot use (*A)(nil) (value of type *A) as Duck value in variable declaration: *A does not implement Duck (missing method swimming) compiler(InvalidIfaceAssign)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0x1-方法"><a href="#0x1-方法" class="headerlink" title="0x1.方法"></a>0x1.方法</h2><p>接口方法方便接口添加新的行为。方法有接收者，当没有了接收者，方法就变成了函数。接收者有两种类型，一种是值接收者，另一种是指针接收者。</p><p>方法的调用者不必满足接收者类型。换句话说，无论方法的接收者是什么类型，该类型的值和指针都可以调用。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> _ IDuck = (*Duck)(<span class="literal">nil</span>) </span><br><span class="line">  </span><br><span class="line">  d := Duck&#123;&#125; <span class="comment">//d := &amp;Duck&#123;&#125; 也是可以的</span></span><br><span class="line">d.gaga() </span><br><span class="line">d.swimming()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当方法的接收者是值类型的时候，无论调用者是值类型还是指针类型，该方法操作的都是对应接收者的值的副本。即使你用指针类型去调用，方法内部操作还是对副本的操作，而不是指针操作。同理，当接收者是指针时，即使用值类型调用，方法内部也是对指针的操作，修改的是值指针指向的值本身。</p><h2 id="0x2-接口实现"><a href="#0x2-接口实现" class="headerlink" title="0x2.接口实现"></a>0x2.接口实现</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> IDuck <span class="keyword">interface</span> &#123;</span><br><span class="line">gaga()</span><br><span class="line">swimming()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Duck <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d Duck)</span> <span class="title">gaga</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;A gaga&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Duck)</span> <span class="title">swimming</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;A swimming&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">d := &amp;Duck&#123;&#125;</span><br><span class="line">dd := Duck&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _ IDuck = (*Duck)(d) <span class="comment">//OK</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _ IDuck = (Duck)(dd) <span class="comment">//编译报错：cannot use (Duck)(dd) (value of type Duck) as IDuck value in variable declaration: Duck does not implement IDuck (method swimming has pointer receiver)compilerInvalidIfaceAssign</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器不考虑我们的值是实现该接口的类型，接口的调用规则是建立在这些方法的接受者和接口如何被调用的基础上。下面的是语言规范里定义的规则，这些规则用来说明是否我们一个类型的值或者指针该接口：</p><ul><li>接收者是指针 <code>*T</code> 时，接口的实例必须是指针</li><li>接收者是值 <code>T</code> 时，接口的实例可以是指针也可以是值</li></ul><blockquote><p> 也就是说：实现了接收者是值类型的方法，相当于自动实现了接收者是指针类型的方法；而实现了接收者是指针类型的方法，不会自动生成对应接收者是值类型的方法。</p></blockquote><p><font color=green>Q&amp;A：既然实现接收者是值类型的方法时，会自动实现接收者是指针类型的方法，那么为啥要用指针类型去做接收者？什么时候会去使用指针作为方法的接收者？</font></p><blockquote><p>方法的接收者是值类型的时候，修改的永远是对象的副本，不会对调用者有影响。但是接收者是指针的时候，在方法里修改，就是修改了指针指向的对象本身。当类型是大型的结构体或者不能被安全的复制时，就定义指针接收者方法，例如文件结构体（struct File）。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;Go语言中，接口是不需要像传统的静态编程语言一样进行声明后才能使用。它引用了动态语言的接口使用方式，只需要实现接口要求的相关方法就行，同时还会在编译阶段进行类型匹配，个人觉得非常好用。&lt;/p&gt;</summary>
    
    
    
    <category term="Golang" scheme="https://blog.eganx.cn/categories/Golang/"/>
    
    
    <category term="go" scheme="https://blog.eganx.cn/tags/go/"/>
    
    <category term="interface" scheme="https://blog.eganx.cn/tags/interface/"/>
    
  </entry>
  
  <entry>
    <title>Go Map的遍历</title>
    <link href="https://blog.eganx.cn/2022/10/26/Go_Map_Range/"/>
    <id>https://blog.eganx.cn/2022/10/26/Go_Map_Range/</id>
    <published>2022-10-26T13:33:01.000Z</published>
    <updated>2022-11-20T04:33:57.713Z</updated>
    
    <content type="html"><![CDATA[<p>Map的遍历过程是便利所有的bucket(一般称之为桶)以及挂载的overflow bucket，然后逐一遍历bucket的所有cell，从有key的cell中取出key和value，遍历完成。实际在遍历的时候，有可能map处于扩容过程中,这时候map的状态就相当于是处于一个中间态，即有些bucket已经迁移，有些bucket还在原来的位置。也就是说遍历如果发生在扩容的过程中，就会涉及到遍历新老 bucket 的过程，就比较麻烦。</p><span id="more"></span><h2 id="0x0-Map遍历是无序的"><a href="#0x0-Map遍历是无序的" class="headerlink" title="0x0.Map遍历是无序的"></a>0x0.Map遍历是无序的</h2><p>在遍历map的时候，可以发现key是无序的。正常来说从一个固定Map的第一个bucket的第一个cell逐步遍历取出key的话，key应该是有序的。因为扩容会带来某些key的bucket或者cell发生变化，Go为了避免我们误认为遍历map会得到有序key，在遍历开始的时候，不是从0号bucket开始，而是会给一个随机数，从一个随机的bucket开始，更绝的是在开始bucket中的开始cell也是随机选择的。这样的话，<font color=red>就算是一个写死的map在遍历的时候依旧不会返回一个固定序列的key集合。</font></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// decide where to start</span></span><br><span class="line">r := <span class="keyword">uintptr</span>(fastrand())</span><br><span class="line"><span class="keyword">if</span> h.B &gt; <span class="number">31</span>-bucketCntBits &#123;</span><br><span class="line">r += <span class="keyword">uintptr</span>(fastrand()) &lt;&lt; <span class="number">31</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// start bucket</span></span><br><span class="line">it.startBucket = r &amp; bucketMask(h.B)</span><br><span class="line"><span class="comment">// start cell</span></span><br><span class="line">it.offset = <span class="keyword">uint8</span>(r &gt;&gt; h.B &amp; (bucketCnt - <span class="number">1</span>))</span><br></pre></td></tr></table></figure><h2 id="0x1-遍历过程"><a href="#0x1-遍历过程" class="headerlink" title="0x1.遍历过程"></a>0x1.遍历过程</h2><p>假如有一个起始<code>B=1</code>的map（有0号和1号两个bucket），现在触发扩容，B变成了2（有0-3号4个bucket）。假设现在老0号bucket已经迁移到新0号和新2号bucket中，老1号中的bucket尚未开始迁移。此时开始对map的遍历，假设<code>startBucket = 2,offset = 4</code>，遍历的起点就是2号bucket中第4个cell。bucket的遍历顺序就是：<code>2-&gt;3-&gt;0-&gt;1</code>。</p><ul><li><p>2号bucket对应的是老0号bucket，检查老0号bucket的迁移状态，发现完成已经完成迁移，从4号cell依次遍历2号bucket中所有cell。如果2号bucket返回的key是非空的，就会继续遍历2号bucket的overflow bucket。</p></li><li><p>完成2号bucket的遍历后，开始3号bucket的遍历，检查后发现3号bucket对应的老1号bucket并没有迁移，这个时候就会去遍历老1号bucket。但是并不会取出老1号bucket的全部key，只会取出hash值后两位为<code>11</code>的key，因为这些key最终会迁移进新3号bucket。</p></li><li><p>完成3号bucket的遍历，继续0号bucket的遍历，已迁移，取出新0号bucket中的key。</p></li><li><p>继续1号bucket的遍历，未迁移，遍历老1号bucket，取出hash值后两位为<code>01</code>的key。</p></li><li><p>再次到2号bucket的时候，表示所有bucket遍历完成，map的遍历也就结束了。</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Map的遍历过程是便利所有的bucket(一般称之为桶)以及挂载的overflow bucket，然后逐一遍历bucket的所有cell，从有key的cell中取出key和value，遍历完成。实际在遍历的时候，有可能map处于扩容过程中,这时候map的状态就相当于是处于一个中间态，即有些bucket已经迁移，有些bucket还在原来的位置。也就是说遍历如果发生在扩容的过程中，就会涉及到遍历新老 bucket 的过程，就比较麻烦。&lt;/p&gt;</summary>
    
    
    
    <category term="Golang" scheme="https://blog.eganx.cn/categories/Golang/"/>
    
    
    <category term="go" scheme="https://blog.eganx.cn/tags/go/"/>
    
    <category term="map" scheme="https://blog.eganx.cn/tags/map/"/>
    
  </entry>
  
  <entry>
    <title>Go Map的扩容</title>
    <link href="https://blog.eganx.cn/2022/10/24/Go_Map_Grow/"/>
    <id>https://blog.eganx.cn/2022/10/24/Go_Map_Grow/</id>
    <published>2022-10-24T07:53:19.000Z</published>
    <updated>2022-11-20T04:33:16.832Z</updated>
    
    <content type="html"><![CDATA[<p>在使用slice的时候，如果向slice中追加元素的时候，导致元素数量大于cap，这时候就会发生slice的扩容。那么在go语言中，什么时候map会发生扩容呢？扩容的策略有哪些呢？扩容的过程是怎样的呢？很是好奇，心动不如行动。开始学习，又是收获满满的一天。</p><span id="more"></span><h2 id="0x0-触发扩容的条件"><a href="#0x0-触发扩容的条件" class="headerlink" title="0x0.触发扩容的条件"></a>0x0.触发扩容的条件</h2><p>众所周知，map是使用hash表的。使用hash表的目的就是追求更加快速的找到key，但是当map中key的数量逐渐增加，逐渐离谱的时候，那么碰撞的几率就越来越大，效率也就随之下降了。最离谱的时候就是所有的key都在一个bucket里面 (<del>这是碳基生物能干出来的事?这和链表有个锤子的区别吗？</del>)，最好就是一个bucket里面就一个key，找到了bucket就找到了key，效率贼高，直接拉到o(1)。但是空间不允许啊，为了效率用空间换时间不寒碜？(<del>很寒碜，贼TM寒碜</del>)。</p><p>最好最坏都属于极端，其实都很难遇到，只是在举🌰的时候夸张表述才会用到。在go语言中，有一个<code>loadFactor</code>指标来对上面的两种情况进行衡量。废话不多说，直接上源码(/go1.18.2/src/runtime/map.go)</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断条件在mapassign函数中。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// If we hit the max load factor or we have too many overflow buckets,</span></span><br><span class="line"><span class="comment">// and we&#x27;re not already in the middle of growing, start growing.</span></span><br><span class="line"><span class="keyword">if</span> !h.growing() &amp;&amp; (overLoadFactor(h.count+<span class="number">1</span>, h.B) || tooManyOverflowBuckets(h.noverflow, h.B)) &#123;</span><br><span class="line">hashGrow(t, h)</span><br><span class="line"><span class="keyword">goto</span> again <span class="comment">// Growing the table invalidates everything, so try again</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的条件可以看出，map扩容一个是在<code>overLoadFactor</code>的时候，一个是在<code>tooManyOverflowBuckets</code>。下面是这两个函数所用到的常量以及主要的引用函数。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line"><span class="comment">// Maximum number of key/elem pairs a bucket can hold.</span></span><br><span class="line">bucketCntBits = <span class="number">3</span></span><br><span class="line">bucketCnt     = <span class="number">1</span> &lt;&lt; bucketCntBits <span class="comment">//8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Maximum average load of a bucket that triggers growth is 6.5.</span></span><br><span class="line"><span class="comment">// Represent as loadFactorNum/loadFactorDen, to allow integer math.</span></span><br><span class="line">loadFactorNum = <span class="number">13</span></span><br><span class="line">loadFactorDen = <span class="number">2</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// PtrSize is the size of a pointer in bytes - unsafe.Sizeof(uintptr(0)) but as an ideal constant.</span></span><br><span class="line"><span class="comment">// It is also the size of the machine&#x27;s native word size (that is, 4 on 32-bit systems, 8 on 64-bit).</span></span><br><span class="line"><span class="keyword">const</span> PtrSize = <span class="number">4</span> &lt;&lt; (^<span class="keyword">uintptr</span>(<span class="number">0</span>) &gt;&gt; <span class="number">63</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// bucketShift returns 1&lt;&lt;b, optimized for code generation.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bucketShift</span><span class="params">(b <span class="keyword">uint8</span>)</span> <span class="title">uintptr</span></span> &#123;</span><br><span class="line"><span class="comment">// Masking the shift amount allows overflow checks to be elided.</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">uintptr</span>(<span class="number">1</span>) &lt;&lt; (b &amp; (goarch.PtrSize*<span class="number">8</span> - <span class="number">1</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// overLoadFactor reports whether count items placed in 1&lt;&lt;B buckets is over loadFactor.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">overLoadFactor</span><span class="params">(count <span class="keyword">int</span>, B <span class="keyword">uint8</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> count &gt; bucketCnt &amp;&amp; <span class="keyword">uintptr</span>(count) &gt; loadFactorNum*(bucketShift(B)/loadFactorDen)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// tooManyOverflowBuckets reports whether noverflow buckets is too many for a map with 1&lt;&lt;B buckets.</span></span><br><span class="line"><span class="comment">// Note that most of these overflow buckets must be in sparse use;</span></span><br><span class="line"><span class="comment">// if use was dense, then we&#x27;d have already triggered regular map growth.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tooManyOverflowBuckets</span><span class="params">(noverflow <span class="keyword">uint16</span>, B <span class="keyword">uint8</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="comment">// If the threshold is too low, we do extraneous work.</span></span><br><span class="line"><span class="comment">// If the threshold is too high, maps that grow and shrink can hold on to lots of unused memory.</span></span><br><span class="line"><span class="comment">// &quot;too many&quot; means (approximately) as many overflow buckets as regular buckets.</span></span><br><span class="line"><span class="comment">// See incrnoverflow for more details.</span></span><br><span class="line"><span class="keyword">if</span> B &gt; <span class="number">15</span> &#123;</span><br><span class="line">B = <span class="number">15</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// The compiler doesn&#x27;t see here that B &lt; 16; mask B to generate shorter shift code.</span></span><br><span class="line"><span class="keyword">return</span> noverflow &gt;= <span class="keyword">uint16</span>(<span class="number">1</span>)&lt;&lt;(B&amp;<span class="number">15</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1）第一种情况"><a href="#1）第一种情况" class="headerlink" title="1）第一种情况"></a>1）第一种情况</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// overLoadFactor reports whether count items placed in 1&lt;&lt;B buckets is over loadFactor.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">overLoadFactor</span><span class="params">(count <span class="keyword">int</span>, B <span class="keyword">uint8</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">  <span class="comment">// 换算一下下: count &gt; 8 &amp;&amp; count &gt; 13*((2^B)/2)</span></span><br><span class="line">  <span class="comment">// loadFactor = count/(2^B) &gt; 6.5</span></span><br><span class="line"><span class="keyword">return</span> count &gt; bucketCnt &amp;&amp; <span class="keyword">uintptr</span>(count) &gt; loadFactorNum*(bucketShift(B)/loadFactorDen)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>count</code>是map的元素个数，<code>1&lt;&lt;B</code>表示bucket数组长度。也就是说<font color=red>在<code>loadFactor := count/(2^B)</code>超过6.5的时候，会触发map的扩容</font>。按照<code>loadFactor</code>的计算方式，当所有bucket都满的时候是8。达到6.5的时候也就差不多算是满了大半了，无论查找还是插入，这个时候碰撞的几率很高，效率也会下降的厉害，所以这是触发扩容的时机。</p><p>如果不停的插入元素、删除元素，然后在插入元素。刚开始插入元素的时候会创建大量bucket。但是只要没有达到第一种扩容情况，也就是说loadFactor的值低于6.5。这个时候进行删除元素的操作，降低loadFactor的分子。然后重复操作，就会产生大量overflow bucket。这个时候key就会过于分散，导致查找和插入的效率过低。为了避免这种情况的发生，就有了下面第二种触发扩容的条件。</p><h3 id="2-第二种情况"><a href="#2-第二种情况" class="headerlink" title="2) 第二种情况"></a>2) 第二种情况</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// tooManyOverflowBuckets reports whether noverflow buckets is too many for a map with 1&lt;&lt;B buckets.</span></span><br><span class="line"><span class="comment">// Note that most of these overflow buckets must be in sparse use;</span></span><br><span class="line"><span class="comment">// if use was dense, then we&#x27;d have already triggered regular map growth.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tooManyOverflowBuckets</span><span class="params">(noverflow <span class="keyword">uint16</span>, B <span class="keyword">uint8</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="comment">// If the threshold is too low, we do extraneous work.</span></span><br><span class="line"><span class="comment">// If the threshold is too high, maps that grow and shrink can hold on to lots of unused memory.</span></span><br><span class="line"><span class="comment">// &quot;too many&quot; means (approximately) as many overflow buckets as regular buckets.</span></span><br><span class="line"><span class="comment">// See incrnoverflow for more details.</span></span><br><span class="line"><span class="keyword">if</span> B &gt; <span class="number">15</span> &#123;</span><br><span class="line">B = <span class="number">15</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// The compiler doesn&#x27;t see here that B &lt; 16; mask B to generate shorter shift code.</span></span><br><span class="line"><span class="keyword">return</span> noverflow &gt;= <span class="keyword">uint16</span>(<span class="number">1</span>)&lt;&lt;(B&amp;<span class="number">15</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>翻译成人话：overflow的bucket数量太多了。<font color=red>当<code>B &gt;= 15</code>的时候，如果overflow的bucket数量超过<code>2^15</code>就触发扩容；当<code>B &lt; 15</code>的时候，如果overflow的bucket数量超过<code>2^B</code>就触发扩容。</font>第二种的这个情况主要是为了避免loadFactor的分子小的时候，却有大量的bucket(包括大量的overflow bucket)。</p><h2 id="0x1-扩容策略"><a href="#0x1-扩容策略" class="headerlink" title="0x1.扩容策略"></a>0x1.扩容策略</h2><p>针对两种不同的触发扩容的条件，进行扩容的策略也有所不同。</p><p>第一种情况是由于元素数量过多，导致了bucket数组快满了。这个时候采用的扩容策略就是<code>B+1</code>，bucket的数组长度变成之前的2倍（<font color=red>2倍扩容</font>）</p><p>第二种情况是由于flowbucket的过多造成，元素没有那么多，主要是位置分散，造成查找和插入的效率较低。采用第一种的扩容策略肯定是不行的，解决的办法是采用<font color=red>等量扩容</font>，创建一个和老buckets数组相同长度的新buckets数组。将老buckets中处于同一个bucket的元素进行紧密排列，尽可能的消除overflow bucket，节省空间，提高效率。</p><p>map的扩容不是原子操作，不会一步到位。扩容需要将原本的键值对迁移到新bucket得内存地址中，大量键值对同时迁移会影响性能，所以Go map的扩容是采用“渐进式”方式。每次最多只会迁移2个bucket。</p><h2 id="0x2-迁移过程"><a href="#0x2-迁移过程" class="headerlink" title="0x2.迁移过程"></a>0x2.迁移过程</h2><p>第一种扩容策略，因为<code>B+1</code>会导致key的hash值需要重新计算，才能确定它会落入那个bucket中，毕竟确定bucket位置的是根据hash值的后B位。这样的话就会导致某些key在迁移前后的bucket序号是不一样的。</p><p>举个🌰：初始状态下B=2，3号bucket里有两个key的hash值后3位值<code>011,111</code>，经过B+1扩容之后，这两个原本处于3号bucket的key会分别落入3号和7号bucket。key在迁移前后是否还是处于原本的bucket取决于倒数第3位是0还是1。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">                     ┌───────────────────────┐</span><br><span class="line">                     │                       │</span><br><span class="line">               ┌─────┼─────────────────┐     │</span><br><span class="line">               │     │                 │     │</span><br><span class="line">         ┌─────┼─────┼───────────┐     │     │</span><br><span class="line">         │     │     │           │     │     │</span><br><span class="line">   ┌─────┼─────┼─────┼─────┐     │     │     │</span><br><span class="line">   │     │     │     │     │     │     │     │</span><br><span class="line">┌──┴──┬──┴──┬──┴──┬──┴──┐  │     │     │     │</span><br><span class="line">│     │     │     │     │  │     │     │     │</span><br><span class="line">│  0  │  1  │  2  │  3  │  │     │     │     │</span><br><span class="line">│     │     │     │     │  │     │     │     │</span><br><span class="line">└──┬──┴──┬──┴──┬──┴──┬──┘  │     │     │     │</span><br><span class="line">   │     │     │     │     │     │     │     │</span><br><span class="line">   │     │     │     │     │     │     │     │</span><br><span class="line">   │     │     │     │     │     │     │     │</span><br><span class="line">   │     │     │     │     │     │     │     │</span><br><span class="line">   ▼     ▼     ▼     ▼     ▼     ▼     ▼     ▼</span><br><span class="line">┌─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┐</span><br><span class="line">│     │     │     │     │     │     │     │     │</span><br><span class="line">│  0  │  1  │  2  │  3  │  4  │  5  │  6  │  7  │</span><br><span class="line">│     │     │     │     │     │     │     │     │</span><br><span class="line">└─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┘</span><br></pre></td></tr></table></figure><p>第二种扩容策略，等量扩容因为B是不变的，所以key还是在原来的bucket。主要是为了收拢过于分散的key(<font color=linblue>大多数都分散在overflow bucket中</font>)。下面的图是迁移完成的情况。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">buckets     B&#x3D;2                         buckets     B&#x3D;2</span><br><span class="line">┌─────┬─────┬─────┬─────┐               ┌─────┬─────┬─────┬─────┐</span><br><span class="line">│     │     │     │     │               │     │     │     │     │</span><br><span class="line">│  0  │  1  │  2  │  3  │               │  0  │  1  │  2  │  3  │</span><br><span class="line">│     │     │     │     │               │     │     │     │     │</span><br><span class="line">└─────┴─────┴─────┴──┬──┘               └─────┴─────┴─────┴──┬──┘</span><br><span class="line">                     │                                       │</span><br><span class="line">   ┌─────────────────┘                               ┌───────┘</span><br><span class="line">   │                                                 │</span><br><span class="line">   ▼                                                 ▼</span><br><span class="line">┌────┐      ┌────┐     ┌────┐                     ┌────┐</span><br><span class="line">│bmap│   ┌─►│bmap│  ┌─►│bmap│                     │bmap│</span><br><span class="line">├────┴┐  │  ├────┴┐ │  ├────┴┐                    ├────┴┐</span><br><span class="line">│key:a│  │  │     │ │  │key:f│                    │key:a│</span><br><span class="line">│ 111 │  │  │     │ │  │ 111 │                    │ 111 │</span><br><span class="line">├─────┤  │  ├─────┤ │  ├─────┤                    ├─────┤</span><br><span class="line">│key:b│  │  │     │ │  │     │                    │key:b│</span><br><span class="line">│ 011 │  │  │     │ │  │     │                    │ 011 │</span><br><span class="line">├─────┤  │  ├─────┤ │  ├─────┤                    ├─────┤</span><br><span class="line">│     │  │  │key:d│ │  │     │                    │key:c│</span><br><span class="line">│     │  │  │ 111 │ │  │     │                    │ 011 │</span><br><span class="line">├─────┤  │  ├─────┤ │  ├─────┤                    ├─────┤</span><br><span class="line">│     │  │  │     │ │  │     │                    │key:d│</span><br><span class="line">│     │  │  │     │ │  │     │                    │ 111 │</span><br><span class="line">├─────┤  │  ├─────┤ │  ├─────┤                    ├─────┤</span><br><span class="line">│key:c│  │  │key:e│ │  │     │                    │key:e│</span><br><span class="line">│ 011 │  │  │ 111 │ │  │     │                    │ 111 │</span><br><span class="line">├─────┤  │  ├─────┤ │  ├─────┤                    ├─────┤</span><br><span class="line">│     │  │  │     │ │  │key:g│                    │key:f│</span><br><span class="line">│     │  │  │     │ │  │ 011 │                    │ 111 │</span><br><span class="line">├─────┤  │  ├─────┤ │  ├─────┤                    ├─────┤</span><br><span class="line">│     │  │  │     │ │  │     │                    │key:g│</span><br><span class="line">│     │  │  │     │ │  │     │                    │ 011 │</span><br><span class="line">├─────┤  │  ├─────┤ │  ├─────┤                    ├─────┤</span><br><span class="line">│     │  │  │     │ │  │     │                    │     │</span><br><span class="line">│     │  │  │     │ │  │     │                    │     │</span><br><span class="line">├─────┤  │  ├─────┤ │  ├─────┤                    ├─────┤</span><br><span class="line">│*over│  │  │*over│ │  │*over│                    │*over│</span><br><span class="line">│flow ├──┘  │flow ├─┘  │flow │                    │flow │</span><br><span class="line">└─────┘     └─────┘    └─────┘                    └─────┘</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;在使用slice的时候，如果向slice中追加元素的时候，导致元素数量大于cap，这时候就会发生slice的扩容。那么在go语言中，什么时候map会发生扩容呢？扩容的策略有哪些呢？扩容的过程是怎样的呢？很是好奇，心动不如行动。开始学习，又是收获满满的一天。&lt;/p&gt;</summary>
    
    
    
    <category term="Golang" scheme="https://blog.eganx.cn/categories/Golang/"/>
    
    
    <category term="go" scheme="https://blog.eganx.cn/tags/go/"/>
    
    <category term="map" scheme="https://blog.eganx.cn/tags/map/"/>
    
  </entry>
  
</feed>
