<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Egan&#39;s Blog</title>
  
  <subtitle>The winter is coming</subtitle>
  <link href="https://blog.eganx.cn/atom.xml" rel="self"/>
  
  <link href="https://blog.eganx.cn/"/>
  <updated>2022-12-26T03:43:15.399Z</updated>
  <id>https://blog.eganx.cn/</id>
  
  <author>
    <name>Egan Dong</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Mongo cluster(docker compose)</title>
    <link href="https://blog.eganx.cn/2022/11/10/Mongo_0/"/>
    <id>https://blog.eganx.cn/2022/11/10/Mongo_0/</id>
    <published>2022-11-10T13:12:34.000Z</published>
    <updated>2022-12-26T03:43:15.399Z</updated>
    
    <content type="html"><![CDATA[<p>初次使用docker compose搭建mongo集群，记录一下。虽然问题还很多，但至少跑起来了。。。</p><span id="more"></span><h2 id="0x0-文件目录结构"><a href="#0x0-文件目录结构" class="headerlink" title="0x0.文件目录结构"></a>0x0.文件目录结构</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mongodb</span><br><span class="line">└── mongo</span><br><span class="line">    ├── data</span><br><span class="line">    │   ├── hosts</span><br><span class="line">    │   └── mongod.conf</span><br><span class="line">    └── docker-compose.yml</span><br></pre></td></tr></table></figure><h2 id="0x1-mongod-conf"><a href="#0x1-mongod-conf" class="headerlink" title="0x1.mongod.conf"></a>0x1.mongod.conf</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemLog:</span><br><span class="line">  destination: file</span><br><span class="line">  path: &#x2F;data&#x2F;log&#x2F;mongo.log</span><br><span class="line">  logAppend: true</span><br><span class="line">storage:</span><br><span class="line">  dbPath: &#x2F;data&#x2F;db</span><br><span class="line">net:</span><br><span class="line">  bindIp: 0.0.0.0</span><br><span class="line">replication:</span><br><span class="line">  replSetName: rs0</span><br></pre></td></tr></table></figure><h2 id="0x2-hosts"><a href="#0x2-hosts" class="headerlink" title="0x2.hosts"></a>0x2.hosts</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1localhost</span><br><span class="line">255.255.255.255broadcasthost</span><br><span class="line">::1                     localhost</span><br></pre></td></tr></table></figure><h2 id="0x3-docker-compose-yml"><a href="#0x3-docker-compose-yml" class="headerlink" title="0x3.docker-compose.yml"></a>0x3.docker-compose.yml</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">db:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">mongo1:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mongo</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">mongo1</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">mongod</span> <span class="string">--config</span> <span class="string">/etc/mongod.conf</span></span><br><span class="line">    <span class="attr">expose:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">27017</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./data/mongo1/db:/data/db</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./data/mongo1/configdb:/data/configdb</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./data/mongo1/log:/data/log</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./data/mongod.conf:/etc/mongod.conf</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./data/hosts:/etc/hosts</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;27017:27017&quot;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">db</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">mongo2:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mongo</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">mongo2</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">mongod</span> <span class="string">--config</span> <span class="string">/etc/mongod.conf</span></span><br><span class="line">    <span class="attr">expose:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">27017</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./data/mongo2/db:/data/db</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./data/mongo2/configdb:/data/configdb</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./data/mongo2/log:/data/log</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./data/mongod.conf:/etc/mongod.conf</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./data/hosts:/etc/hosts</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;27018:27017&quot;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">db</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">mongo3:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mongo</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">mongo3</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">mongod</span> <span class="string">--config</span> <span class="string">/etc/mongod.conf</span></span><br><span class="line">    <span class="attr">expose:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">27017</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./data/mongo3/db:/data/db</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./data/mongo3/configdb:/data/configdb</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./data/mongo3/log:/data/log</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./data/mongod.conf:/etc/mongod.conf</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./data/hosts:/etc/hosts</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;27019:27017&quot;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">db</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="0x4-开始部署"><a href="#0x4-开始部署" class="headerlink" title="0x4.开始部署"></a>0x4.开始部署</h2><ul><li>进入docker-compose.yml文件所在目录</li><li>执行命令：<code>docker compose -f docker-compose.yml up -d</code></li></ul><h2 id="0x5-建立副本集"><a href="#0x5-建立副本集" class="headerlink" title="0x5.建立副本集"></a>0x5.建立副本集</h2><ul><li><p>进入mongo容器：<code>docker exec -it mongo1 bash</code></p></li><li><p>进入mongo：<code>mongosh</code> ,老版本的mongo到指令是<code>mongo</code></p></li><li><p>切换管理员用户：<code>use admin</code></p></li><li><p>初始化副本集：<code>rs.initiate()</code>,无参初始化时，会默认当前节点PRIMARY节点</p></li><li><p>添加副节点：<code>rs.add(&#39;mongo2:27017&#39;)</code></p></li><li><p>添加仲裁节点：<code>rs.addArb(&#39;mongo3:27017&#39;)</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 添加仲裁节点要是报错，可以试试运行以下代码</span><br><span class="line"> db.adminCommand(&#123;</span><br><span class="line">  &quot;setDefaultRWConcern&quot; : 1,</span><br><span class="line">  &quot;defaultWriteConcern&quot; : &#123;</span><br><span class="line">    &quot;w&quot; : 2</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>查看副本集配置信息：<code>rs.conf()</code></p></li><li><p>查看副本集运行状态：<code>rs.status()</code></p></li></ul><p>要是需要修改配置，可以按照以下步骤来：</p><ul><li><code>cfg = rs.conf()</code></li><li><code>cfg.members[0].xxx = xxx</code></li><li><code>rs.reconfig(cfg)</code></li></ul><h2 id="0x6-验证副本集"><a href="#0x6-验证副本集" class="headerlink" title="0x6.验证副本集"></a>0x6.验证副本集</h2><p>切换节点查看同步状态：<code>rs.printReplicationInfo()</code></p><p>仅当建立了集合后副节点才会进行同步。</p><h2 id="0x7-外部连接"><a href="#0x7-外部连接" class="headerlink" title="0x7.外部连接"></a>0x7.外部连接</h2><p>准备使用Robo 3T(现在变成Studio 3T Free)连接数据库时，会有连接失败的异常，可以将WSL的IP地址写入电脑C盘hosts文件里：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">172.23.224.1mongo1</span><br><span class="line">172.23.224.1mongo2</span><br><span class="line">172.23.224.1mongo3</span><br></pre></td></tr></table></figure><p>然后使用以下链接来连接数据库</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mongo1:27017</span><br><span class="line">mongo2:27017</span><br><span class="line">mongo3:27017</span><br></pre></td></tr></table></figure><p>但是如果还是连接不上，或者重启后连接不上，可以将<code>mongo</code>容器的IP写到<code>mongo\data\hosts</code>文件里，容器的IP可以使用<code>docker inspect mongo1</code>来获取。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">172.30.0.2 mongo1</span><br><span class="line">172.30.0.3 mongo2</span><br><span class="line">172.30.0.4 mongo3</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;初次使用docker compose搭建mongo集群，记录一下。虽然问题还很多，但至少跑起来了。。。&lt;/p&gt;</summary>
    
    
    
    <category term="Database" scheme="https://blog.eganx.cn/categories/Database/"/>
    
    
    <category term="DB" scheme="https://blog.eganx.cn/tags/DB/"/>
    
    <category term="mongo" scheme="https://blog.eganx.cn/tags/mongo/"/>
    
  </entry>
  
  <entry>
    <title>Go语言中new和make的区别</title>
    <link href="https://blog.eganx.cn/2022/11/07/Go_New_and_Make/"/>
    <id>https://blog.eganx.cn/2022/11/07/Go_New_and_Make/</id>
    <published>2022-11-07T01:07:12.000Z</published>
    <updated>2022-12-26T03:44:33.213Z</updated>
    
    <content type="html"><![CDATA[<p>在Go语言中，make关键字在初始化的时候被频繁使用，之前写C# 的时候都是使用new关键字，Go中new关键字也是存在的。准备看看两者的区别。</p><span id="more"></span><h2 id="0x0-new"><a href="#0x0-new" class="headerlink" title="0x0.new"></a>0x0.new</h2><p><code>new</code>可以对类型进行内存创建和初始化，<strong>其返回值是所创建类型的指针引用</strong>。<code>new</code>会根据变量类型返回一个指向该类型的指针。</p><h2 id="0x1-make"><a href="#0x1-make" class="headerlink" title="0x1.make"></a>0x1.make</h2><p><code>make</code> 函数也是用于内存分配的，但是和<code>new</code>不同，仅支持 <code>slice</code>、<code>map</code>、<code>channel</code> 三种数据类型的内存创建，其返回值是所创建类型的本身，而不是新的指针引用。<code>make</code>不仅可以开辟一个内存，还能给这个内存的类型初始化其零值。</p><h2 id="0x2-总结"><a href="#0x2-总结" class="headerlink" title="0x2.总结"></a>0x2.总结</h2><ul><li>make和new都是golang用来分配内存的函数，且在堆上分配内存，make 即分配内存，也初始化内存。new只是将内存清零，并没有初始化内存。</li><li>make返回的还是引用类型本身；而new返回的是指向类型的指针。</li><li>make只能用来分配及初始化类型为slice，map，channel的数据；new可以分配任意类型的数据。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;在Go语言中，make关键字在初始化的时候被频繁使用，之前写C# 的时候都是使用new关键字，Go中new关键字也是存在的。准备看看两者的区别。&lt;/p&gt;</summary>
    
    
    
    <category term="Go" scheme="https://blog.eganx.cn/categories/Go/"/>
    
    
    <category term="make" scheme="https://blog.eganx.cn/tags/make/"/>
    
    <category term="new" scheme="https://blog.eganx.cn/tags/new/"/>
    
  </entry>
  
  <entry>
    <title>Windows10下WSL2和Docker的安装和配置</title>
    <link href="https://blog.eganx.cn/2022/11/06/Win10_WSL_Docker/"/>
    <id>https://blog.eganx.cn/2022/11/06/Win10_WSL_Docker/</id>
    <published>2022-11-06T04:12:32.000Z</published>
    <updated>2022-12-17T13:27:04.083Z</updated>
    
    <content type="html"><![CDATA[<p>最近需要搭建mongo集群，看教程说使用docker比较好部署，准备在公司电脑（ThinkPad）上先试一下，所以需要安装一下WSL和docker。自己也没有在Windows环境下使用过docker，所以记录一下。</p><span id="more"></span><h2 id="0x0-Windows-Terminal"><a href="#0x0-Windows-Terminal" class="headerlink" title="0x0.Windows Terminal"></a>0x0.Windows Terminal</h2><p>用过 <code>Windows</code> 默认终端的都知道，真的不怎么美观。 微软也逐渐意识到这个问题，并在 <code>Build2019</code> 大会上发布了 新一代 <code>Windows</code> 终端程序：<code>Windows Terminal</code> 。</p><p><code>Windows Terminal</code> 是一款新式、快速、高效、强大且高效的终端应用程序，适用于命令行工具和命令提示符，PowerShell和 WSL 等 Shell 用户。主要功能包括多个选项卡、窗格、Unicode、和 UTF-8 字符支持，GPU 加速文本渲染引擎以及自定义主题、样式和配置。</p><p>而且这个是开源的，如果不喜欢在Microsoft Store里安装软件，可以直接去GitHub里下载，这里给出GitHub项目地址：<code>https://github.com/microsoft/terminal</code>。</p><h2 id="0x1-Windows-WSL2"><a href="#0x1-Windows-WSL2" class="headerlink" title="0x1.Windows WSL2"></a>0x1.Windows WSL2</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1).概述"></a>1).概述</h3><p>WSL是windows推出的可让开发人员不需要安装虚拟机（vmware，virtbox）或者设置双系统启动就可以原生支持运行GNU/Linux的系统环境，简称WSL子系统。目前最新的版本是WSL2，在原先的基础上提高了文件系统的性能并添加了完全的的系统调用支持。WSL2使用全新体系架构使其能真正的运行一个Linux内核。</p><h3 id="2-安装"><a href="#2-安装" class="headerlink" title="2).安装"></a>2).安装</h3><ul><li>WSL2对系统版本有一定的要求：必须运行 Windows 10 版本 2004 及更高版本（内部版本 19041 及更高版本）或 Windows 11。</li><li>在 <code>控制面板</code>-<code>程序</code>- <code>启用或关闭 Windows 功能</code> 中勾选 <code>适用于 Linux 的 Windows 子系统</code>以及 <code>虚拟机平台</code>(wsl2 需要)。<font color=red>此步骤完成后需要重启电脑。</font></li><li>打开微软商店应用，在搜索框中输入“Linux”或者“ubuntu”然后搜索，你可以看到搜索结果中有很多的 Linux 发行版可以选择。我选Ubuntu22.04<ul><li>有可能启动ubuntu报告<code>WslRegisterDistribution failed with error: 0x800701bc</code>是因为没有升级linux内核使用<code>wsl --update</code>下载更新即可。</li><li>在商店安装后并没有完全完成子系统安装，还需要运行一次Ubuntu来完成内核下载以及用户名密码的设置。</li></ul></li><li>启动WSL2<ul><li><code>Windows Terminal</code>里面使用<code>wsl -l</code>命令来查看所有的子系统。使用<code>wsl --set-default-version 2</code>设置为每个安装的发行版默认WSL2启动。</li></ul></li></ul><h3 id="3-导出Ubuntu-22-04到D盘下"><a href="#3-导出Ubuntu-22-04到D盘下" class="headerlink" title="3).导出Ubuntu-22.04到D盘下"></a>3).导出Ubuntu-22.04到D盘下</h3><p>这一步可以缓解一下C盘的压力，C盘没有压力的就当没看见这一步。</p><ul><li>查看已安装的Linux发行版: <code>wsl -l --all -v</code></li><li>导出Linux发行版tar文件到指定文件夹: <code>wsl --export Ubuntu-22.04 d:/wsl/ubuntu/wsl-ubuntu-22.04.tar</code></li><li>注销Ubuntu-22.04: <code>wsl --unregister Ubuntu-22.04</code></li><li>重新导入并安装WSL2到D盘: <code>wsl --import Ubuntu-22.04 d:/wsl/ubuntu/ d:/wsl/ubuntu/wsl-ubuntu-22.04.tar --version 2</code></li></ul><h2 id="0x2-Windows-Docker-Desktop"><a href="#0x2-Windows-Docker-Desktop" class="headerlink" title="0x2.Windows Docker Desktop"></a>0x2.Windows Docker Desktop</h2><p>这个没啥好说的，官网下载，直接安装就完了。官网地址传送：<code>https://www.docker.com/products/docker-desktop/</code>.</p><p>安装完成后，打开Docker Desktop的设置，找到<code>Resources-WSL Integration</code>，打开Enable integration with additional distors，将自己的WSL打开。这样docker就会跑在WSL上。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近需要搭建mongo集群，看教程说使用docker比较好部署，准备在公司电脑（ThinkPad）上先试一下，所以需要安装一下WSL和docker。自己也没有在Windows环境下使用过docker，所以记录一下。&lt;/p&gt;</summary>
    
    
    
    <category term="Database" scheme="https://blog.eganx.cn/categories/Database/"/>
    
    
    <category term="mongo" scheme="https://blog.eganx.cn/tags/mongo/"/>
    
    <category term="tool" scheme="https://blog.eganx.cn/tags/tool/"/>
    
  </entry>
  
  <entry>
    <title>Studio 3T Free跳过一个月Full product的登陆试用(Windows)</title>
    <link href="https://blog.eganx.cn/2022/11/05/Tool_Studio3t/"/>
    <id>https://blog.eganx.cn/2022/11/05/Tool_Studio3t/</id>
    <published>2022-11-05T14:32:12.000Z</published>
    <updated>2022-12-16T02:16:06.630Z</updated>
    
    <content type="html"><![CDATA[<p>当Robo 3T变成了Studio 3T Free，不想试用Studio 3T的Full product。只想使用Robo 3T Free(Robo 3T)，该如何跳过一个月Full product的登陆试用呢？</p><span id="more"></span><h2 id="0x0-尊重付费软件"><a href="#0x0-尊重付费软件" class="headerlink" title="0x0.尊重付费软件"></a>0x0.尊重付费软件</h2><p>Robo 3T作为常用的MongoDB GUI，现在变成了Studio 3T Free。依旧是免费，但是在Windows下初次打开Studio 3T软件时，会要求必须登陆，然后开始一个月的Full product trial。这个就很烦，我就只想用免费版的，毕竟免费版就可以满足我的需求。体验试用是好事，但是当这件事成为必选项时，就会让人很不爽😕</p><p>所以在不进行非正规手段进行软件破解时，该如何进行跳过登陆激活进行免费版的使用呢？</p><p>找到位于<code>C:\Windows\System32\drivers\ect</code>下的<code>hosts</code>文件，将下面两行添加进去。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1        update.studio3t.com</span><br><span class="line">127.0.0.1        license-portal-eb.studio3t.com</span><br></pre></td></tr></table></figure><p>然后重启Studio 3T时，Product activation弹窗就会跳过<code>Login/Register</code>这一步，直接到达<code>Finish</code>。Nice! 大功告成。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;当Robo 3T变成了Studio 3T Free，不想试用Studio 3T的Full product。只想使用Robo 3T Free(Robo 3T)，该如何跳过一个月Full product的登陆试用呢？&lt;/p&gt;</summary>
    
    
    
    <category term="Tool" scheme="https://blog.eganx.cn/categories/Tool/"/>
    
    
    <category term="tool" scheme="https://blog.eganx.cn/tags/tool/"/>
    
    <category term="studio3t" scheme="https://blog.eganx.cn/tags/studio3t/"/>
    
  </entry>
  
  <entry>
    <title>Go Context</title>
    <link href="https://blog.eganx.cn/2022/11/04/Go_Context/"/>
    <id>https://blog.eganx.cn/2022/11/04/Go_Context/</id>
    <published>2022-11-04T03:45:19.000Z</published>
    <updated>2022-12-05T10:54:58.287Z</updated>
    
    <content type="html"><![CDATA[<p>context是Go的一个标准库，中文一般叫做”上下文”。context主要是用来在goroutine之间传递上下午信息，包括取消信号、超时时间等。context.Context类型的值可以协调多个goroutine中的代码执行“取消”操作，并且可以存储键值对。而且还是并发安全的。与它协作可以在API的外部控制执行“取消”操作，比如取消一个HTTP请求的执行。</p><span id="more"></span><h2 id="0x0-context的作用"><a href="#0x0-context的作用" class="headerlink" title="0x0.context的作用"></a>0x0.context的作用</h2><p>在http server中，一个请求有可能会起若干个协程，这些goroutine有时候是需要共享请求的基本数据的，包括token，超时时间和取消信号等。当请求迟迟得不到回应或者此次请求被取消，可能是使用者关闭了浏览器或已经超过了请求方的超时时间，请求方直接放弃了这次请求的结果。这个时候，所有为这个请求工作的goroutine需要快速退出，因为工作成果变成了无意义的。在相关的goroutine退出后，系统可以回收相关资源。</p><p>正常关闭协程是采用<code>channel+select</code>方式来控制。但是当一个请求相关联的协程数量过多，且相互关联，能够同时关闭，可以使用context来实现。</p><blockquote><p><font color=ligblue>context用来解决goroutine之间退出通知、元数据传递的功能。    </font></p></blockquote><p>context的使用建议：</p><ul><li><p>不要将 Context 塞到结构体里。直接将 Context 类型作为函数的第一参数，而且一般都命名为 ctx。</p></li><li><p>不要向函数传入一个 nil 的 context，如果你实在不知道传什么，标准库给你准备好了一个 context：todo。</p></li><li><p>不要把本应该作为函数参数的类型塞到 context 中，context 存储的应该是一些共同的数据。例如：登陆的 session、cookie 等。</p></li><li><p>同一个 context 可能会被传递到多个 goroutine，别担心，context 是并发安全的。</p></li></ul><h3 id="1-传递共享的数据"><a href="#1-传递共享的数据" class="headerlink" title="1).传递共享的数据"></a>1).传递共享的数据</h3><p>对于web服务端开发，往往希望将一个请求处理的整个过程串起来，因此需要在函数调用的时候传递context。</p><p>context的常见创建函数：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建空白的根节点context</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Background</span><span class="params">()</span> <span class="title">Context</span></span> </span><br><span class="line"><span class="comment">// 创建子节点context</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithCancel</span><span class="params">(parent Context)</span> <span class="params">(ctx Context, cancel CancelFunc)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithDeadline</span><span class="params">(parent Context, deadline time.Time)</span> <span class="params">(Context, CancelFunc)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithTimeout</span><span class="params">(parent Context, timeout time.Duration)</span> <span class="params">(Context, CancelFunc)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithValue</span><span class="params">(parent Context, key, val <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">Context</span></span></span><br></pre></td></tr></table></figure><h3 id="2-取消goroutine"><a href="#2-取消goroutine" class="headerlink" title="2).取消goroutine"></a>2).取消goroutine</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">func_eg</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        ... <span class="comment">// 业务代码：1秒刷新1次</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">            <span class="comment">// 被取消，直接返回</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">case</span> &lt;-time.After(time.Second):</span><br><span class="line">            <span class="comment">// block 1 秒钟 </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main</span></span><br><span class="line">ctx, cancel := context.WithTimeout(context.Background(), time.Hour)</span><br><span class="line"><span class="keyword">go</span> func_eg(ctx)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端取消时，调用cancel函数</span></span><br><span class="line">cancel()</span><br></pre></td></tr></table></figure><p><code>cancel()</code>函数返回的context和cancelFun是分开的。context本身是没有cancel函数，保证取消函数只能由外部调用，防止子节点context调用取消函数，从而严格控制信息流从父节点context流向子节点context。</p><h3 id="3-防止goroutine泄露"><a href="#3-防止goroutine泄露" class="headerlink" title="3).防止goroutine泄露"></a>3).防止goroutine泄露</h3><p>某些goroutine处于无限循环状态，若无外部取消函数，会造成系统资源泄露。</p><h2 id="0x1-context详细解析"><a href="#0x1-context详细解析" class="headerlink" title="0x1.context详细解析"></a>0x1.context详细解析</h2><table><thead><tr><th>类型</th><th>名称</th><th>作用</th></tr></thead><tbody><tr><td>Context</td><td>接口</td><td>定义了 Context 接口的四个方法</td></tr><tr><td>emptyCtx</td><td>结构体</td><td>实现了 Context 接口，它其实是个空的 context</td></tr><tr><td>CancelFunc</td><td>函数</td><td>取消函数</td></tr><tr><td>canceler</td><td>接口</td><td>context 取消接口，定义了两个方法</td></tr><tr><td>cancelCtx</td><td>结构体</td><td>可以被取消</td></tr><tr><td>timerCtx</td><td>结构体</td><td>超时会被取消</td></tr><tr><td>valueCtx</td><td>结构体</td><td>可以存储 k-v 对</td></tr><tr><td>Background</td><td>函数</td><td>返回一个空的 context，常作为根 context</td></tr><tr><td>TODO</td><td>函数</td><td>返回一个空的 context，常用于重构时期，没有合适的 context 可用</td></tr><tr><td>WithCancel</td><td>函数</td><td>基于父 context，生成一个可以取消的 context</td></tr><tr><td>newCancelCtx</td><td>函数</td><td>创建一个可取消的 context</td></tr><tr><td>propagateCancel</td><td>函数</td><td>向下传递 context 节点间的取消关系</td></tr><tr><td>parentCancelCtx</td><td>函数</td><td>找到第一个可取消的父节点</td></tr><tr><td>removeChild</td><td>函数</td><td>去掉父节点的孩子节点</td></tr><tr><td>init</td><td>函数</td><td>包初始化</td></tr><tr><td>WithDeadline</td><td>函数</td><td>创建一个有 deadline 的 context</td></tr><tr><td>WithTimeout</td><td>函数</td><td>创建一个有 timeout 的 context</td></tr><tr><td>WithValue</td><td>函数</td><td>创建一个存储 k-v 对的 context</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;p&gt;context是Go的一个标准库，中文一般叫做”上下文”。context主要是用来在goroutine之间传递上下午信息，包括取消信号、超时时间等。context.Context类型的值可以协调多个goroutine中的代码执行“取消”操作，并且可以存储键值对。而且还是并发安全的。与它协作可以在API的外部控制执行“取消”操作，比如取消一个HTTP请求的执行。&lt;/p&gt;</summary>
    
    
    
    <category term="Golang" scheme="https://blog.eganx.cn/categories/Golang/"/>
    
    
    <category term="go" scheme="https://blog.eganx.cn/tags/go/"/>
    
    <category term="context" scheme="https://blog.eganx.cn/tags/context/"/>
    
  </entry>
  
  <entry>
    <title>Go Channel关闭方式</title>
    <link href="https://blog.eganx.cn/2022/11/02/Go_Channel_Close/"/>
    <id>https://blog.eganx.cn/2022/11/02/Go_Channel_Close/</id>
    <published>2022-11-02T15:56:54.000Z</published>
    <updated>2022-11-24T07:06:51.771Z</updated>
    
    <content type="html"><![CDATA[<p>channel的关闭是比较头疼的，搞不好就panic。直接panic-recover要被喷莽夫，不优雅。所以找了很多资料，总结一下channel的关闭过程，常见的关闭方式和优雅的关闭方式（<strong>没有人会比福杰一家还要优雅</strong>）</p><span id="more"></span><h2 id="0x0-关闭chan过程"><a href="#0x0-关闭chan过程" class="headerlink" title="0x0.关闭chan过程"></a>0x0.关闭chan过程</h2><p>关闭channel的执行函数是<code>closechan</code>，源码如下</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// go version: go1.18.2</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">closechan</span><span class="params">(c *hchan)</span></span> &#123;</span><br><span class="line"><span class="comment">// 关闭一个nil channel，直接panic。</span></span><br><span class="line">  <span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(plainError(<span class="string">&quot;close of nil channel&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 锁</span></span><br><span class="line">lock(&amp;c.lock)</span><br><span class="line">  <span class="comment">// channel已经关闭</span></span><br><span class="line"><span class="keyword">if</span> c.closed != <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// 解锁，然后panic</span></span><br><span class="line">    unlock(&amp;c.lock)</span><br><span class="line"><span class="built_in">panic</span>(plainError(<span class="string">&quot;close of closed channel&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">callerpc := getcallerpc()</span><br><span class="line">racewritepc(c.raceaddr(), callerpc, abi.FuncPCABIInternal(closechan))</span><br><span class="line">racerelease(c.raceaddr())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置chan已关闭</span></span><br><span class="line">c.closed = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> glist gList</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 释放channel里所有等待接收队列里的sudog</span></span><br><span class="line"><span class="comment">// release all readers</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">sg := c.recvq.dequeue()</span><br><span class="line"><span class="keyword">if</span> sg == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// elem不为空，还想要接收数据，给个相对应类型的零值。</span></span><br><span class="line"><span class="keyword">if</span> sg.elem != <span class="literal">nil</span> &#123;</span><br><span class="line">typedmemclr(c.elemtype, sg.elem)</span><br><span class="line">sg.elem = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> sg.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">sg.releasetime = cputicks()</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 取出goroutine</span></span><br><span class="line">gp := sg.g</span><br><span class="line">gp.param = unsafe.Pointer(sg)</span><br><span class="line">sg.success = <span class="literal">false</span></span><br><span class="line"><span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">raceacquireg(gp, c.raceaddr())</span><br><span class="line">&#125;</span><br><span class="line">glist.push(gp)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 释放channel里所有等待发送队列里的sudog，同时这些goroutine将会panic。</span></span><br><span class="line"><span class="comment">// release all writers (they will panic)</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">sg := c.sendq.dequeue()</span><br><span class="line"><span class="keyword">if</span> sg == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">sg.elem = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">if</span> sg.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">sg.releasetime = cputicks()</span><br><span class="line">&#125;</span><br><span class="line">gp := sg.g</span><br><span class="line">gp.param = unsafe.Pointer(sg)</span><br><span class="line">sg.success = <span class="literal">false</span></span><br><span class="line"><span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">raceacquireg(gp, c.raceaddr())</span><br><span class="line">&#125;</span><br><span class="line">glist.push(gp)</span><br><span class="line">&#125;</span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Ready all Gs now that we&#x27;ve dropped the channel lock.</span></span><br><span class="line">  <span class="comment">// 遍历glist，唤醒goroutine</span></span><br><span class="line"><span class="keyword">for</span> !glist.empty() &#123;</span><br><span class="line">gp := glist.pop()</span><br><span class="line">gp.schedlink = <span class="number">0</span></span><br><span class="line">goready(gp, <span class="number">3</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将<code>recvq</code>和<code>sendq</code>两个队列中的Goroutine加入到gList中，并清除掉所有sudog上未被处理掉元素。最后将glist中所有的goroutine加到调度队列，等待被唤醒。</p><blockquote><p><font color=red>发送者在被唤醒之后会panic。</font></p></blockquote><p>总结一下:</p><table><thead><tr><th align="center">操作</th><th align="center">closed channel</th></tr></thead><tbody><tr><td align="center">关闭(close)</td><td align="center">panic</td></tr><tr><td align="center">发送(c&lt;-)</td><td align="center">panic</td></tr><tr><td align="center">接收(&lt;-c)</td><td align="center">永远不阻塞</td></tr></tbody></table><h2 id="0x1-关闭channel的常见方式"><a href="#0x1-关闭channel的常见方式" class="headerlink" title="0x1.关闭channel的常见方式"></a>0x1.关闭channel的常见方式</h2><p>channel的关闭与否都有可能造成panic。如何获取channel是否关闭和如何稳妥的关闭channel是非常重要的事情‼️</p><ul><li>在不改变channel自身状态的情况下，无法获知一个channel是否关闭。</li><li>关闭一个closed channel会导致panic。所以在关闭channel的时候，关闭的一方在不清楚当前channel是否关闭的情况下去关闭channel是很危险的⚠️。</li><li>向一个closed channel发送数据会导致panic。同上，在发送方不知道channel是否关闭的情况下向channel发送数据，也是很危险的⚠️</li></ul><p>关闭channel原则：</p><blockquote><p>一般原则上使用channel是不允许接收方关闭channel和 <strong>不能关闭一个有多个并发发送者的channel</strong>。 换而言之， 你只能在发送方的 goroutine 中关闭只有该发送方的channel。</p></blockquote><h3 id="1-defer-recover粗暴关闭channel"><a href="#1-defer-recover粗暴关闭channel" class="headerlink" title="1).defer-recover粗暴关闭channel"></a>1).<strong>defer-recover粗暴关闭channel</strong></h3><p>使用defer-recover机制来确保程序不会因panic而崩溃，然后直接关闭chan。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SafeClose</span><span class="params">(ch <span class="keyword">chan</span> T)</span> <span class="params">(justClosed <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">recover</span>() != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// 返回值可以被修改</span></span><br><span class="line">            <span class="comment">// 在一个延时函数的调用中。</span></span><br><span class="line">            justClosed = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 假设这里 ch != nil 。</span></span><br><span class="line">    <span class="built_in">close</span>(ch)   <span class="comment">// 如果 ch 已经被关闭将会引发 panic</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span> <span class="comment">// &lt;=&gt; justClosed = true; return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的思想也可以用在发送方，确保向closed channel发送数据不会造成程序崩了。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SafeSend</span><span class="params">(ch <span class="keyword">chan</span> T, value T)</span> <span class="params">(closed <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">recover</span>() != <span class="literal">nil</span> &#123;</span><br><span class="line">            closed = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    ch &lt;- value  <span class="comment">// 如果 ch 已经被关闭将会引发 panic</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span> <span class="comment">// &lt;=&gt; closed = false; return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的方法虽然处理了panic，但是并没有避免panic的发生。</p><h3 id="2-使用sync-Once关闭channel"><a href="#2-使用sync-Once关闭channel" class="headerlink" title="2).使用sync.Once关闭channel"></a>2).<strong>使用sync.Once关闭channel</strong></h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> MyChannel <span class="keyword">struct</span> &#123;</span><br><span class="line">    C    <span class="keyword">chan</span> T</span><br><span class="line">    once sync.Once</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewMyChannel</span><span class="params">()</span> *<span class="title">MyChannel</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;MyChannel&#123;C: <span class="built_in">make</span>(<span class="keyword">chan</span> T)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mc *MyChannel)</span> <span class="title">SafeClose</span><span class="params">()</span></span> &#123;</span><br><span class="line">    mc.once.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">close</span>(mc.C)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-使用sync-Mutex避免多次关闭同一个channel"><a href="#3-使用sync-Mutex避免多次关闭同一个channel" class="headerlink" title="3).使用sync.Mutex避免多次关闭同一个channel"></a>3).<strong>使用sync.Mutex避免多次关闭同一个channel</strong></h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> MyChannel <span class="keyword">struct</span> &#123;</span><br><span class="line">    C      <span class="keyword">chan</span> T</span><br><span class="line">    closed <span class="keyword">bool</span></span><br><span class="line">    mutex  sync.Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewMyChannel</span><span class="params">()</span> *<span class="title">MyChannel</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;MyChannel&#123;C: <span class="built_in">make</span>(<span class="keyword">chan</span> T)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mc *MyChannel)</span> <span class="title">SafeClose</span><span class="params">()</span></span> &#123;</span><br><span class="line">    mc.mutex.Lock()</span><br><span class="line">    <span class="keyword">defer</span> mc.mutex.Unlock()</span><br><span class="line">    <span class="keyword">if</span> !mc.closed &#123;</span><br><span class="line">        <span class="built_in">close</span>(mc.C)</span><br><span class="line">        mc.closed = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mc *MyChannel)</span> <span class="title">IsClosed</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    mc.mutex.Lock()</span><br><span class="line">    <span class="keyword">defer</span> mc.mutex.Unlock()</span><br><span class="line">    <span class="keyword">return</span> mc.closed</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0x2-优雅的关闭channel"><a href="#0x2-优雅的关闭channel" class="headerlink" title="0x2.优雅的关闭channel"></a>0x2.优雅的关闭channel</h2><p>上面的几种关闭channel的方式，用的人应该不少(说实话，我也很喜欢使用<code>sync.Once</code>的方式去关闭channel)。但是，有许多人认为代码在考虑业务实现的同时，应该优雅优雅再优雅！（舍监表示很开心！阿尼亚表示很难受！）</p><p>那么如何优雅的关闭channel？按照发送者和接收者的数量可以分为以下四种：</p><blockquote><p><font color = ligblue>1. 一个 sender，一个 receiver</font><br><font color = ligblue>2. 一个 sender， N个 receiver</font><br><font color = ligblue>3. M个 sender， 一个 receiver</font><br><font color = ligblue>4. M个 sender， N个 receiver</font></p></blockquote><h3 id="1-只有一个发送者，关闭唯一的发送者"><a href="#1-只有一个发送者，关闭唯一的发送者" class="headerlink" title="1).只有一个发送者，关闭唯一的发送者"></a>1).只有一个发送者，关闭唯一的发送者</h3><p>第一种和第二种情况比较好处理，因为只有一个发送者，只需要关闭唯一的发送者就可以。<code>sync.WaitGroup</code> 会被用于完成例子。 它在实践中并不是必要的。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">    <span class="string">&quot;math/rand&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    rand.Seed(time.Now().UnixNano())</span><br><span class="line">    log.SetFlags(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> MaxRandomNumber = <span class="number">100000</span></span><br><span class="line">    <span class="keyword">const</span> NumReceivers = <span class="number">100</span></span><br><span class="line"></span><br><span class="line">    wgReceivers := sync.WaitGroup&#123;&#125;</span><br><span class="line">    wgReceivers.Add(NumReceivers)</span><br><span class="line"></span><br><span class="line">    dataCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送者</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> value := rand.Intn(MaxRandomNumber); value == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="comment">// 唯一的发送者可以安全地关闭通道。</span></span><br><span class="line">                <span class="built_in">close</span>(dataCh)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;            </span><br><span class="line">                dataCh &lt;- value</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收者</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; NumReceivers; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> wgReceivers.Done()</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 接收数据直到 dataCh 被关闭或者</span></span><br><span class="line">            <span class="comment">// dataCh 的数据缓存队列是空的。</span></span><br><span class="line">            <span class="keyword">for</span> value := <span class="keyword">range</span> dataCh &#123;</span><br><span class="line">                log.Println(value)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wgReceivers.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-多个发送者，一个接收者。"><a href="#2-多个发送者，一个接收者。" class="headerlink" title="2).多个发送者，一个接收者。"></a>2).多个发送者，一个接收者。</h3><p>接收者通过关闭一个channel，告诉发送者不要再发了。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">    <span class="string">&quot;math/rand&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    rand.Seed(time.Now().UnixNano())</span><br><span class="line">    log.SetFlags(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">const</span> MaxRandomNumber = <span class="number">100000</span></span><br><span class="line">    <span class="keyword">const</span> NumSenders = <span class="number">1000</span></span><br><span class="line"></span><br><span class="line">    wgReceivers := sync.WaitGroup&#123;&#125;</span><br><span class="line">    wgReceivers.Add(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    dataCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">100</span>)</span><br><span class="line">    stopCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">        <span class="comment">// stopCh 是一个信号通道。</span></span><br><span class="line">        <span class="comment">// 它的发送者是 dataCh 的接收者。</span></span><br><span class="line">        <span class="comment">// 它的接收者是 dataCh 的发送者。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送者</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; NumSenders; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">for</span> &#123;</span><br><span class="line">                <span class="keyword">select</span> &#123;</span><br><span class="line">                <span class="keyword">case</span> &lt;- stopCh:</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                <span class="keyword">case</span> dataCh &lt;- rand.Intn(MaxRandomNumber):</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收者</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> wgReceivers.Done()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> value := <span class="keyword">range</span> dataCh &#123;</span><br><span class="line">            <span class="keyword">if</span> value == MaxRandomNumber<span class="number">-1</span> &#123;</span><br><span class="line">                <span class="comment">// dataCh 通道的接收者也是 stopCh 通道的发送者。</span></span><br><span class="line">                <span class="comment">// 在这里关闭停止通道是安全的。.</span></span><br><span class="line">                <span class="built_in">close</span>(stopCh)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            log.Println(value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    wgReceivers.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-多个发送者，多个接收者。"><a href="#3-多个发送者，多个接收者。" class="headerlink" title="3).多个发送者，多个接收者。"></a>3).多个发送者，多个接收者。</h3><p>当发送者和接收者都是多个的时候，没办法通过任何一方去终止这场游戏。因此需要增加一个中间人的角色来处理。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">    <span class="string">&quot;math/rand&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    rand.Seed(time.Now().UnixNano())</span><br><span class="line">    log.SetFlags(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">const</span> MaxRandomNumber = <span class="number">100000</span></span><br><span class="line">    <span class="keyword">const</span> NumReceivers = <span class="number">100</span></span><br><span class="line">    <span class="keyword">const</span> NumSenders = <span class="number">1000</span></span><br><span class="line"></span><br><span class="line">    wgReceivers := sync.WaitGroup&#123;&#125;</span><br><span class="line">    wgReceivers.Add(NumReceivers)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    dataCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">100</span>)</span><br><span class="line">    stopCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">        <span class="comment">// stopCh 是一个信号通道。</span></span><br><span class="line">        <span class="comment">// 它的发送者是下面的主持人 goroutine。</span></span><br><span class="line">        <span class="comment">// 它的接收者是 dataCh的所有发送者和接收者。</span></span><br><span class="line">    toStop := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">1</span>)</span><br><span class="line">        <span class="comment">// toStop 通道通常用来通知主持人去关闭信号通道( stopCh )。</span></span><br><span class="line">        <span class="comment">// 它的发送者是 dataCh的任意发送者和接收者。</span></span><br><span class="line">        <span class="comment">// 它的接收者是下面的主持人 goroutine</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> stoppedBy <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主持人</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        stoppedBy = &lt;-toStop</span><br><span class="line">        <span class="built_in">close</span>(stopCh)</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送者</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; NumSenders; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(id <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">for</span> &#123;</span><br><span class="line">                value := rand.Intn(MaxRandomNumber)</span><br><span class="line">                <span class="keyword">if</span> value == <span class="number">0</span> &#123;</span><br><span class="line">                    <span class="comment">// 用于通知主持人关闭信号通道。</span></span><br><span class="line">                    <span class="keyword">select</span> &#123;</span><br><span class="line">                    <span class="keyword">case</span> toStop &lt;- <span class="string">&quot;sender#&quot;</span> + id:</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">select</span> &#123;</span><br><span class="line">                <span class="keyword">case</span> &lt;- stopCh:</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                <span class="keyword">case</span> dataCh &lt;- value:</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;(strconv.Itoa(i))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收者</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; NumReceivers; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(id <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> wgReceivers.Done()</span><br><span class="line">            <span class="keyword">for</span> &#123;</span><br><span class="line">                <span class="keyword">select</span> &#123;</span><br><span class="line">                <span class="keyword">case</span> &lt;- stopCh:</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                <span class="keyword">case</span> value := &lt;-dataCh:</span><br><span class="line">                    <span class="keyword">if</span> value == MaxRandomNumber<span class="number">-1</span> &#123;</span><br><span class="line">                        <span class="comment">// 同样用于通知主持人去关闭信号通道。</span></span><br><span class="line">                        <span class="keyword">select</span> &#123;</span><br><span class="line">                        <span class="keyword">case</span> toStop &lt;- <span class="string">&quot;receiver#&quot;</span> + id:</span><br><span class="line">                        <span class="keyword">default</span>:</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">return</span></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    log.Println(value)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;(strconv.Itoa(i))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    wgReceivers.Wait()</span><br><span class="line">    log.Println(<span class="string">&quot;stopped by&quot;</span>, stoppedBy)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时<code>toStop</code>通道的缓存大小是1。不使用非缓冲型channel是为了避免第一个关闭信号在主持人准备好从<code>toStop</code>接收数据之前发送，造成丢失。</p><p>也可以设置<code>toStop</code>通道的buf为发送者和接收者数量之和。toStop的容量足够的时候，就不用担心阻塞了。也就不需要借助select语句了。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">toStop := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, NumReceivers + NumSenders)</span><br><span class="line">...</span><br><span class="line">            value := rand.Intn(MaxRandomNumber)</span><br><span class="line">            <span class="keyword">if</span> value == <span class="number">0</span> &#123;</span><br><span class="line">                toStop &lt;- <span class="string">&quot;sender#&quot;</span> + id</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">...</span><br><span class="line">                <span class="keyword">if</span> value == MaxRandomNumber<span class="number">-1</span> &#123;</span><br><span class="line">                    toStop &lt;- <span class="string">&quot;receiver#&quot;</span> + id</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><font color = green>Q&amp;A: 关闭的channel还能读吗？</font></p><blockquote><p>可以。从一个带缓冲的chan里读取数据时，当channel被关闭，是可以读到有效值的。可以是comma-ok的方式读取chan数据，当ok值为false时，说明channel已经关闭且通道无数据，读出的数据开始无效。</p></blockquote><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">3</span>)</span><br><span class="line">ch &lt;- <span class="number">0</span></span><br><span class="line">ch &lt;- <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">close</span>(ch)</span><br><span class="line">x, ok := &lt;-ch</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;received: &quot;</span>, x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">y, ok := &lt;-ch</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;received: &quot;</span>, y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">z, ok := &lt;-ch</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;received false &quot;</span>, z)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果：<br>received:  0<br>received:  1<br>received false:  0</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;channel的关闭是比较头疼的，搞不好就panic。直接panic-recover要被喷莽夫，不优雅。所以找了很多资料，总结一下channel的关闭过程，常见的关闭方式和优雅的关闭方式（&lt;strong&gt;没有人会比福杰一家还要优雅&lt;/strong&gt;）&lt;/p&gt;</summary>
    
    
    
    <category term="Golang" scheme="https://blog.eganx.cn/categories/Golang/"/>
    
    
    <category term="go" scheme="https://blog.eganx.cn/tags/go/"/>
    
    <category term="channel" scheme="https://blog.eganx.cn/tags/channel/"/>
    
  </entry>
  
  <entry>
    <title>Go Channel数据结构和创建</title>
    <link href="https://blog.eganx.cn/2022/11/01/Go_Channel_DS/"/>
    <id>https://blog.eganx.cn/2022/11/01/Go_Channel_DS/</id>
    <published>2022-11-01T13:09:13.000Z</published>
    <updated>2022-11-24T06:59:34.802Z</updated>
    
    <content type="html"><![CDATA[<p>Go语言的并发是最好用的，而channel也算是Go语言并发机制的半壁江山了。</p><span id="more"></span><h2 id="0x0-CSP"><a href="#0x0-CSP" class="headerlink" title="0x0.CSP"></a>0x0.CSP</h2><p>CSP全称“Communicating Sequential Processes”，中文可以叫做通信顺序进程。go的并发是基于channel实现，依赖的就是CSP模型。CSP描述了并发系统中的互动模式，实际上Go只是用到了CSP理论中一部分，即理论中的Process/Channel，在Go中对应goroutine/channel。这两个并发原语之间没有从属关系， Process 可以订阅任意个 Channel，Channel 也并不关心是哪个 Process 在利用它进行通信；Process 围绕 Channel 进行读写，形成一套有序阻塞和可预测的并发模型。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">┌─────────────┐     ┌─────────────┐      ┌─────────────┐</span><br><span class="line">│             │     │             │      │             │</span><br><span class="line">│  Goroutine  ├────►│   Channel   ├─────►│  Goroutine  │</span><br><span class="line">│             │     │             │      │             │</span><br><span class="line">└─────────────┘     └─────────────┘      └─────────────┘</span><br></pre></td></tr></table></figure><p>Goroutine + channel支撑起了Go语言的并发机制。</p><h2 id="0x1-channel数据结构"><a href="#0x1-channel数据结构" class="headerlink" title="0x1.channel数据结构"></a>0x1.channel数据结构</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123;</span><br><span class="line">qcount   <span class="keyword">uint</span>           <span class="comment">// total data in the queue //循环队列元素个数</span></span><br><span class="line">dataqsiz <span class="keyword">uint</span>           <span class="comment">// size of the circular queue //循环队列大小</span></span><br><span class="line">buf      unsafe.Pointer <span class="comment">// points to an array of dataqsiz elements //循环队列指针</span></span><br><span class="line">elemsize <span class="keyword">uint16</span> <span class="comment">//chan元素大小</span></span><br><span class="line">closed   <span class="keyword">uint32</span> <span class="comment">//是否已经关闭</span></span><br><span class="line">elemtype *_type <span class="comment">// element type //chan元素类型</span></span><br><span class="line">sendx    <span class="keyword">uint</span>   <span class="comment">// send index //chan发送操作处理到的位置</span></span><br><span class="line">recvx    <span class="keyword">uint</span>   <span class="comment">// receive index //chan接收操作处理到的位置</span></span><br><span class="line">recvq    waitq  <span class="comment">// list of recv waiters //等待接收数据的goroutine列表</span></span><br><span class="line">sendq    waitq  <span class="comment">// list of send waiters //等待发送数据的goroutine列表</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// lock protects all fields in hchan, as well as several</span></span><br><span class="line"><span class="comment">// fields in sudogs blocked on this channel.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Do not change another G&#x27;s status while holding this lock</span></span><br><span class="line"><span class="comment">// (in particular, do not ready a G), as this can deadlock</span></span><br><span class="line"><span class="comment">// with stack shrinking.</span></span><br><span class="line">lock mutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>buf</code>字段只有在缓冲型的channel才有，指向底层的循环数组。</p><p><code>sendx</code>和<code>recvx</code>分别表示已发送和已接收的元素在循环数组中的索引。</p><p><code>sendq</code>和<code>recvq</code>分别表示等待接收和等待发送的goroutine队列。这些goroutine由于尝试读取channel或者向channel发送数据而被阻塞。</p><p><code>lock</code>用来保护hchan中所有的字段。保证每个channel的读写都是原子的。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sudog 双向列表，sudog实际上是对goroutine的一个封装。</span></span><br><span class="line"><span class="keyword">type</span> waitq <span class="keyword">struct</span> &#123;</span><br><span class="line">first *sudog</span><br><span class="line">last  *sudog</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> ┌─────┐</span><br><span class="line"> │hchan│</span><br><span class="line"> ├─────┴────────────┐</span><br><span class="line">5│   qcount uint    │</span><br><span class="line"> ├──────────────────┤</span><br><span class="line">8│  dataqsiz uint   │                 0   1   2   3   4   5   6   7</span><br><span class="line"> ├──────────────────┤               ┌───┬───┬───┬───┬───┬───┬───┬───┐</span><br><span class="line"> │buf unsafe.Pointer├──────────────►│ a │ b │ c │ d │ e │   │   │   │</span><br><span class="line"> ├──────────────────┤               └───┴───┴───┴───┴───┴───┴───┴───┘</span><br><span class="line"> │ elemsize uint16  │                 ▲                   ▲</span><br><span class="line"> ├──────────────────┤                 │                   │</span><br><span class="line"> │  closed uint32   │                 │                   │</span><br><span class="line"> ├──────────────────┤                 │                   │</span><br><span class="line"> │  elemtype *_type │                 │                   │</span><br><span class="line"> ├──────────────────┤                 │                   │</span><br><span class="line">0│    sendx uint    ├─────────────────┘                   │</span><br><span class="line"> ├──────────────────┤                                     │</span><br><span class="line">5│    recvx uint    ├─────────────────────────────────────┘</span><br><span class="line"> ├──────────────────┤</span><br><span class="line"> │    recvq waitq   ├─────────┬───────────────────────────────────────────┐</span><br><span class="line"> ├──────────────────┤         │                                           │</span><br><span class="line"> │    sendq waitq   ├─────┐   │   ┌───────┐     ┌───────┐     ┌───────┐   │</span><br><span class="line"> ├──────────────────┤     │   └──►│ sudog │◄───►│ sudog │◄───►│ sudog │◄──┘</span><br><span class="line"> │    lock mutex    │     │       └───────┘     └───────┘     └───────┘</span><br><span class="line"> └──────────────────┘     │</span><br><span class="line">                          │</span><br><span class="line">                          │       ┌───────┐     ┌───────┐     ┌───────┐</span><br><span class="line">                          │   ┌──►│ sudog │◄───►│ sudog │◄───►│ sudog │◄──┐</span><br><span class="line">                          │   │   └───────┘     └───────┘     └───────┘   │</span><br><span class="line">                          │   │                                           │</span><br><span class="line">                          └───┴───────────────────────────────────────────┘</span><br></pre></td></tr></table></figure><h2 id="0x2-创建channel"><a href="#0x2-创建channel" class="headerlink" title="0x2.创建channel"></a>0x2.创建channel</h2><p>创建<code>chan</code>一般使用<code>make</code>关键字。其中<code>chan</code>的类型分为有无缓冲两种模式。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>) <span class="comment">//无缓冲</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">2</span>) <span class="comment">//有缓冲</span></span><br></pre></td></tr></table></figure><p>翻翻源码，有些看不太明白，只能是能看多少看多少了😭。在runtime/chan.go中都是使用<code>makechan</code>来创建<code>chan</code>。中文是个人注释，英文是官方注释。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">maxAlign  = <span class="number">8</span></span><br><span class="line">hchanSize = unsafe.Sizeof(hchan&#123;&#125;) + <span class="keyword">uintptr</span>(-<span class="keyword">int</span>(unsafe.Sizeof(hchan&#123;&#125;))&amp;(maxAlign<span class="number">-1</span>)) <span class="comment">//hchan结构体大小</span></span><br><span class="line">debugChan = <span class="literal">false</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makechan64</span><span class="params">(t *chantype, size <span class="keyword">int64</span>)</span> *<span class="title">hchan</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">int64</span>(<span class="keyword">int</span>(size)) != size &#123;</span><br><span class="line"><span class="built_in">panic</span>(plainError(<span class="string">&quot;makechan: size out of range&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> makechan(t, <span class="keyword">int</span>(size))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makechan</span><span class="params">(t *chantype, size <span class="keyword">int</span>)</span> *<span class="title">hchan</span></span> &#123;</span><br><span class="line">elem := t.elem</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 检查channel size和align</span></span><br><span class="line"><span class="comment">// compiler checks this but be safe.</span></span><br><span class="line"><span class="keyword">if</span> elem.size &gt;= <span class="number">1</span>&lt;&lt;<span class="number">16</span> &#123;</span><br><span class="line">throw(<span class="string">&quot;makechan: invalid channel element type&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> hchanSize%maxAlign != <span class="number">0</span> || elem.align &gt; maxAlign &#123;</span><br><span class="line">throw(<span class="string">&quot;makechan: bad alignment&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 元素大小*个数，计算buf需要的内存大小</span></span><br><span class="line">mem, overflow := math.MulUintptr(elem.size, <span class="keyword">uintptr</span>(size))</span><br><span class="line"><span class="keyword">if</span> overflow || mem &gt; maxAlloc-hchanSize || size &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(plainError(<span class="string">&quot;makechan: size out of range&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Hchan does not contain pointers interesting for GC when elements stored in buf do not contain pointers.</span></span><br><span class="line"><span class="comment">// buf points into the same allocation, elemtype is persistent.</span></span><br><span class="line"><span class="comment">// SudoG&#x27;s are referenced from their owning thread so they can&#x27;t be collected.</span></span><br><span class="line"><span class="comment">// TODO(dvyukov,rlh): Rethink when collector can move allocated objects.</span></span><br><span class="line"><span class="keyword">var</span> c *hchan</span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line">  <span class="comment">// 表示元素大小为零或者缓冲区大小为0（无缓冲类型），不需要创建buf。只进行一次内存分配。分配内存的大小就是hchan结构体大小。</span></span><br><span class="line"><span class="keyword">case</span> mem == <span class="number">0</span>:</span><br><span class="line"><span class="comment">// Queue or element size is zero.</span></span><br><span class="line">c = (*hchan)(mallocgc(hchanSize, <span class="literal">nil</span>, <span class="literal">true</span>))</span><br><span class="line"><span class="comment">// Race detector uses this location for synchronization.</span></span><br><span class="line">c.buf = c.raceaddr()</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 元素类型不含指针，进行一次内存分配，分配一块连续的内存，大小是“hchan结构体大小+个数*元素大小”。</span></span><br><span class="line">  <span class="comment">// 同时元素大小不等于0且是缓冲区大小不为0</span></span><br><span class="line"><span class="keyword">case</span> elem.ptrdata == <span class="number">0</span>:</span><br><span class="line"><span class="comment">// Elements do not contain pointers.</span></span><br><span class="line"><span class="comment">// Allocate hchan and buf in one call.</span></span><br><span class="line">c = (*hchan)(mallocgc(hchanSize+mem, <span class="literal">nil</span>, <span class="literal">true</span>))</span><br><span class="line">c.buf = add(unsafe.Pointer(c), hchanSize)</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 元素包含指针，缓冲区大小不为0，进行两次内存分配，单独为hchan和buf分配内存。</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="comment">// Elements contain pointers.</span></span><br><span class="line">c = <span class="built_in">new</span>(hchan)</span><br><span class="line">c.buf = mallocgc(mem, elem, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">c.elemsize = <span class="keyword">uint16</span>(elem.size)</span><br><span class="line">c.elemtype = elem</span><br><span class="line">c.dataqsiz = <span class="keyword">uint</span>(size)</span><br><span class="line">lockInit(&amp;c.lock, lockRankHchan)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> debugChan &#123;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;makechan: chan=&quot;</span>, c, <span class="string">&quot;; elemsize=&quot;</span>, elem.size, <span class="string">&quot;; dataqsiz=&quot;</span>, size, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据channel中收发的元素类型和缓冲区的大小，初始化hchan时有以下三种情况：</p><ul><li>元素大小为零或者缓冲区大小为0（无缓冲类型），不需要创建buf。进行一次内存分配。分配内存的大小就是hchan结构体大小。</li><li>元素大小和缓冲区大小均不为0，且元素类型不含指针。进行一次内存分配，分配一块连续的内存，大小是“hchan结构体大小+个数*元素大小”。</li><li>元素包含指针，缓冲区大小不为0。进行两次内存分配，单独为hchan和buf分配内存。</li></ul><h2 id="0x3-channel的基本应用"><a href="#0x3-channel的基本应用" class="headerlink" title="0x3.channel的基本应用"></a>0x3.channel的基本应用</h2><h3 id="1-超时处理"><a href="#1-超时处理" class="headerlink" title="1).超时处理"></a>1).超时处理</h3><p><code>res := &lt;- c1</code> 等待结果，<code>&lt;-time.After</code> 等待超时（1秒钟）以后发送的值。 由于 <code>select</code> 默认处理第一个已准备好的接收操作， 因此如果操作耗时超过了允许的 1 秒的话，将会执行超时 <code>case</code>。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    c1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">        c1 &lt;- <span class="string">&quot;result 1&quot;</span></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> res := &lt;-c1:</span><br><span class="line">        fmt.Println(res)</span><br><span class="line">    <span class="keyword">case</span> &lt;-time.After(<span class="number">1</span> * time.Second):</span><br><span class="line">        fmt.Println(<span class="string">&quot;timeout 1&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    c2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">        c2 &lt;- <span class="string">&quot;result 2&quot;</span></span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> res := &lt;-c2:</span><br><span class="line">        fmt.Println(res)</span><br><span class="line">    <span class="keyword">case</span> &lt;-time.After(<span class="number">3</span> * time.Second):</span><br><span class="line">        fmt.Println(<span class="string">&quot;timeout 2&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">timeout 1</span><br><span class="line">result 2</span><br></pre></td></tr></table></figure></blockquote><h3 id="2-控制并发"><a href="#2-控制并发" class="headerlink" title="2).控制并发"></a>2).控制并发</h3><p>构建一个缓冲型的 channel，容量为 3。接着遍历任务列表，每个任务启动一个 goroutine 去完成。真正执行任务，访问第三方的动作在 w() 中完成，在执行 w() 之前，先要从 limit 中拿“许可证”，拿到许可证之后，才能执行 w()，并且在执行完任务，要将“许可证”归还。这样就可以控制同时运行的 goroutine 数。如果 w() 发生 panic，那“许可证”可能就还不回去了，因此需要使用 defer 来保证。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> limit = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">// ......</span></span><br><span class="line">    <span class="keyword">for</span> _, w := <span class="keyword">range</span> work &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            limit &lt;- <span class="number">1</span></span><br><span class="line">            w()</span><br><span class="line">            &lt;-limit</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-生产者消费者模型"><a href="#3-生产者消费者模型" class="headerlink" title="3).生产者消费者模型"></a>3).生产者消费者模型</h3><p>并发编程中最常见的例子就是生产者消费者模式，该模式主要通过平衡生产线程和消费线程的工作能力来提高程序的整体处理数据的速度。简单地说，就是生产者生产一些数据，然后放到成果队列中，同时消费者从成果队列中来取这些数据。这样就让生产消费变成了异步的两个过程。当成果队列中没有数据时，消费者就进入饥饿的等待中；而当成果队列中数据已满时，生产者则面临因产品挤压导致 CPU 被剥夺的下岗问题。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 生产者: 生成 factor 整数倍的序列</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Producer</span><span class="params">(factor <span class="keyword">int</span>, out <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; ; i++ &#123;</span><br><span class="line">        out &lt;- i*factor</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Consumer</span><span class="params">(in &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> v := <span class="keyword">range</span> in &#123;</span><br><span class="line">        fmt.Println(v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">64</span>) <span class="comment">// 成果队列</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> Producer(<span class="number">3</span>, ch) <span class="comment">// 生成 3 的倍数的序列</span></span><br><span class="line">    <span class="keyword">go</span> Producer(<span class="number">5</span>, ch) <span class="comment">// 生成 5 的倍数的序列</span></span><br><span class="line">    <span class="keyword">go</span> Consumer(ch)    <span class="comment">// 消费生成的队列</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Ctrl+C 退出</span></span><br><span class="line">    sig := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal, <span class="number">1</span>)</span><br><span class="line">    signal.Notify(sig, syscall.SIGINT, syscall.SIGTERM)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;quit (%v)\n&quot;</span>, &lt;-sig)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;Go语言的并发是最好用的，而channel也算是Go语言并发机制的半壁江山了。&lt;/p&gt;</summary>
    
    
    
    <category term="Golang" scheme="https://blog.eganx.cn/categories/Golang/"/>
    
    
    <category term="go" scheme="https://blog.eganx.cn/tags/go/"/>
    
    <category term="channel" scheme="https://blog.eganx.cn/tags/channel/"/>
    
  </entry>
  
  <entry>
    <title>Go Interface理解(2)</title>
    <link href="https://blog.eganx.cn/2022/10/30/Go_Interface_2/"/>
    <id>https://blog.eganx.cn/2022/10/30/Go_Interface_2/</id>
    <published>2022-10-30T13:45:56.000Z</published>
    <updated>2022-11-22T06:15:48.152Z</updated>
    
    <content type="html"><![CDATA[<p>接口有动态值和动态类型，只有当两者都是nil的时候，才有<code>接口值==nil</code>。这很重要‼️ 接口变量时常需要进行类型断言，找到真实类型。这也很重要‼️</p><span id="more"></span><h2 id="0x0-空接口-amp-nil"><a href="#0x0-空接口-amp-nil" class="headerlink" title="0x0.空接口&amp;nil"></a>0x0.空接口&amp;nil</h2><p>上来一个经典问题：一个包含nil指针的接口是不是nil接口？这个是真坑，在判空的时候，有可能就中招了。</p><p>空接口(<code>interface&#123;&#125;</code>)不包含任何的方法，但与此同时，所有的类型都实现了<code>interface&#123;&#125;</code>。在存储任意类型的时候，<code>interface&#123;&#125;</code>相当的有用。</p><p>nil 不是关键字，是一个预先声明的标识符，指针、通道、函数、接口、map、切片的零值就是nil，nil 是没有默认类型的，他的类型具有不确定性，我们在使用它时必须要提供足够的信息能够让编译器 推断nil期望的类型;</p><p>两个nil不能进行比较，因为nil是无类型的;</p><blockquote><ol><li>声明一个nil的map，map可以读数据，但是不能写数据</li><li>关闭一个nil的channel会引发panic</li><li>nil切片不能进行索引访问，会引发panic</li><li>方法接收者为nil时，如果在方法内使用到了会引发panic </li><li>空指针一个没有任何值的指针</li></ol></blockquote><p>接口的底层结构体有<code>iface、eface</code>两种不同的表示。前者是有方法的接口，后者是无任何方法的空接口：<code>interface&#123;&#125;</code>。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//src/runtime/runtime2.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> iface <span class="keyword">struct</span> &#123;</span><br><span class="line">tab  *itab</span><br><span class="line">data unsafe.Pointer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> eface <span class="keyword">struct</span> &#123;</span><br><span class="line">_type *_type</span><br><span class="line">data  unsafe.Pointer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> itab <span class="keyword">struct</span> &#123;</span><br><span class="line">inter *interfacetype</span><br><span class="line">_type *_type</span><br><span class="line">hash  <span class="keyword">uint32</span> <span class="comment">// copy of _type.hash. Used for type switches.</span></span><br><span class="line">_     [<span class="number">4</span>]<span class="keyword">byte</span></span><br><span class="line">fun   [<span class="number">1</span>]<span class="keyword">uintptr</span> <span class="comment">// variable sized. fun[0]==0 means _type does not implement inter.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>iface</code> 内部维护两个指针，<code>tab</code> 指向一个 <code>itab</code> 实体， 它表示接口的类型以及赋给这个接口的实体类型。<code>data</code> 则指向接口具体的值，一般而言是一个指向堆内存的指针。<code>tab</code>和<code>data</code>也分别被称为动态类型和动态值，接口值包括动态类型和动态值。只有当接口的动态类型和动态值都为nil的时候，才有<code>接口值==nil</code>。</p><h2 id="0x1-接口类型断言"><a href="#0x1-接口类型断言" class="headerlink" title="0x1.接口类型断言"></a>0x1.接口类型断言</h2><p>隐士类型转换在Go中是不允许的，这个时候类型就需要进行转换成另一个类型。有两种方式实现：<code>类型转换</code>，<code>类型断言</code>。两者的不同之处在于<font color=lgiblue>类型断言是针对接口变量。</font></p><h3 id="1-类型转换"><a href="#1-类型转换" class="headerlink" title="1).类型转换"></a>1).类型转换</h3><p><code>&lt;结果&gt; := &lt;目标类型&gt;(&lt;表达式&gt;)</code></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">f = <span class="number">10.101</span></span><br><span class="line">i := <span class="keyword">int</span>(f)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%T, %v\n&quot;</span>, i, i) <span class="comment">//output: int, 10</span></span><br></pre></td></tr></table></figure><p>类型转换前后的两个类型需要相互兼容才可以，不然编译器会报错。</p><h3 id="2-类型断言"><a href="#2-类型断言" class="headerlink" title="2).类型断言"></a>2).类型断言</h3><p>因为空接口 <code>interface&#123;&#125;</code> 没有定义任何函数，因此 Go 中所有类型都实现了空接口。当一个函数的形参是 <code>interface&#123;&#125;</code>，那么在函数中，需要对形参进行断言，从而得到它的真实类型。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;目标类型的值&gt; :&#x3D; &lt;表达式&gt;.( 目标类型 )　　&#x2F;&#x2F;非安全类型断言</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Duck <span class="keyword">struct</span> &#123;</span><br><span class="line">age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> d <span class="keyword">interface</span>&#123;&#125; = <span class="built_in">new</span>(Duck)</span><br><span class="line">s := d.(Duck)</span><br><span class="line">fmt.Println(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//run main.go</span></span><br><span class="line"><span class="comment">//panic: &quot;interface conversion: interface &#123;&#125; is *main.Duck, not main.Duck&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;目标类型的值&gt;，&lt;布尔参数&gt; :&#x3D; &lt;表达式&gt;.( 目标类型 ) &#x2F;&#x2F; comma-ok断言,安全类型断言 </span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Duck <span class="keyword">struct</span> &#123;</span><br><span class="line">age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> d <span class="keyword">interface</span>&#123;&#125; = <span class="built_in">new</span>(Duck)</span><br><span class="line">s, ok := d.(Duck)</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">fmt.Println(s)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;d type is %T&quot;</span>, d)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//run main.go</span></span><br><span class="line"><span class="comment">//d type is *main.Duck</span></span><br></pre></td></tr></table></figure><p>尽量使用comma-ok断言，即使断言失败也不会panic。</p><p>断言其实也可以使用 <code>switch</code> 语句判断接口的类型，每一个 <code>case</code> 会被顺序地考虑。当命中一个 <code>case</code> 时，就会执行 <code>case</code> 中的语句，因此 <code>case</code> 语句的顺序是很重要的，因为很有可能会有多个 <code>case</code> 匹配的情况。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> m := m.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="literal">nil</span>:</span><br><span class="line"><span class="keyword">case</span> Duck:</span><br><span class="line"><span class="keyword">case</span> *Duck:</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;接口有动态值和动态类型，只有当两者都是nil的时候，才有&lt;code&gt;接口值==nil&lt;/code&gt;。这很重要‼️ 接口变量时常需要进行类型断言，找到真实类型。这也很重要‼️&lt;/p&gt;</summary>
    
    
    
    <category term="Golang" scheme="https://blog.eganx.cn/categories/Golang/"/>
    
    
    <category term="go" scheme="https://blog.eganx.cn/tags/go/"/>
    
    <category term="interface" scheme="https://blog.eganx.cn/tags/interface/"/>
    
  </entry>
  
  <entry>
    <title>Go Interface理解(1)</title>
    <link href="https://blog.eganx.cn/2022/10/29/Go_Interface_1/"/>
    <id>https://blog.eganx.cn/2022/10/29/Go_Interface_1/</id>
    <published>2022-10-29T11:23:19.000Z</published>
    <updated>2022-11-22T06:10:18.113Z</updated>
    
    <content type="html"><![CDATA[<p>Go语言中，接口是不需要像传统的静态编程语言一样进行声明后才能使用。它引用了动态语言的接口使用方式，只需要实现接口要求的相关方法就行，同时还会在编译阶段进行类型匹配，个人觉得非常好用。</p><span id="more"></span><h2 id="0x0-Interface-amp-Duck-Typing"><a href="#0x0-Interface-amp-Duck-Typing" class="headerlink" title="0x0.Interface &amp; Duck Typing"></a>0x0.Interface &amp; Duck Typing</h2><p>所谓Go语言式的接口，就是不用显示声明类型<code>T</code>实现了接口<code>I</code>，只要类型<code>T</code>的公开方法完全满足接口<code>I</code>的要求，就可以把类型<code>T</code>的对象用在需要接口<code>I</code>的地方。这种做法的学名叫做<a href="http://en.wikipedia.org/wiki/Structural_type_system">Structural Typing</a>，也有人称它为一种静态的Duck Typing。</p><p>Duck Typing一般常见于动态语言中（比如python），但是动态语言不会在编译阶段去进行类型匹配，只有在运行到当前行代码的时候才会报错。而传统的静态语言（比如Java），必须显示地去声明实现了某个接口，然后才可以去使用。这跟动态语言静态语言的讨论类似，可以讨论优缺点，但是不能以好坏去下结论。</p><p>Go语言本身作为一种静态语言，静态语言的类型检查是肯定有的。但是在接口的使用上，引用了动态语言的接口使用方式。即不要求类型显示地去声明实现了某个接口，只需要实现接口要求的相关方法就行，编译阶段会去进行类型检查。如果没有实现相关方法，编译是会报错的。</p><p>举个🌰：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> IDuck <span class="keyword">interface</span> &#123;</span><br><span class="line">gaga()</span><br><span class="line">swimming()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Duck <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d Duck)</span> <span class="title">gaga</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Duck gaga&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Duck)</span> <span class="title">swimming</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Duck swimming&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> _ IDuck = (*Duck)(<span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color=red><code>var _ IDuck = (*Duck)(nil)  //这个很实用，编译器会由此检查 *Duck类型是否实现了 IDuck 接口。</code></font></p><p>以上的代码编译可以通过，表示A实现了Duck接口，那么A就是一只鸭子🦆。</p><p>但是当注释了A的游泳方法时，就会出现编译器会直接爆出以下错误，表示A并没有完全实现Duck接口，A不是一只鸭子🦆。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// func (d *Duck) swimming() &#123;</span></span><br><span class="line"><span class="comment">// fmt.Println(&quot;Duck swimming&quot;)</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> _ IDuck = (*Duck)(<span class="literal">nil</span>) <span class="comment">//编译报错：cannot use (*A)(nil) (value of type *A) as Duck value in variable declaration: *A does not implement Duck (missing method swimming) compiler(InvalidIfaceAssign)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0x1-方法"><a href="#0x1-方法" class="headerlink" title="0x1.方法"></a>0x1.方法</h2><p>接口方法方便接口添加新的行为。方法有接收者，当没有了接收者，方法就变成了函数。接收者有两种类型，一种是值接收者，另一种是指针接收者。</p><p>方法的调用者不必满足接收者类型。换句话说，无论方法的接收者是什么类型，该类型的值和指针都可以调用。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> _ IDuck = (*Duck)(<span class="literal">nil</span>) </span><br><span class="line">  </span><br><span class="line">  d := Duck&#123;&#125; <span class="comment">//d := &amp;Duck&#123;&#125; 也是可以的</span></span><br><span class="line">d.gaga() </span><br><span class="line">d.swimming()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当方法的接收者是值类型的时候，无论调用者是值类型还是指针类型，该方法操作的都是对应接收者的值的副本。即使你用指针类型去调用，方法内部操作还是对副本的操作，而不是指针操作。同理，当接收者是指针时，即使用值类型调用，方法内部也是对指针的操作，修改的是值指针指向的值本身。</p><h2 id="0x2-接口实现"><a href="#0x2-接口实现" class="headerlink" title="0x2.接口实现"></a>0x2.接口实现</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> IDuck <span class="keyword">interface</span> &#123;</span><br><span class="line">gaga()</span><br><span class="line">swimming()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Duck <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d Duck)</span> <span class="title">gaga</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;A gaga&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Duck)</span> <span class="title">swimming</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;A swimming&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">d := &amp;Duck&#123;&#125;</span><br><span class="line">dd := Duck&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _ IDuck = (*Duck)(d) <span class="comment">//OK</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _ IDuck = (Duck)(dd) <span class="comment">//编译报错：cannot use (Duck)(dd) (value of type Duck) as IDuck value in variable declaration: Duck does not implement IDuck (method swimming has pointer receiver)compilerInvalidIfaceAssign</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器不考虑我们的值是实现该接口的类型，接口的调用规则是建立在这些方法的接受者和接口如何被调用的基础上。下面的是语言规范里定义的规则，这些规则用来说明是否我们一个类型的值或者指针该接口：</p><ul><li>接收者是指针 <code>*T</code> 时，接口的实例必须是指针</li><li>接收者是值 <code>T</code> 时，接口的实例可以是指针也可以是值</li></ul><blockquote><p> 也就是说：实现了接收者是值类型的方法，相当于自动实现了接收者是指针类型的方法；而实现了接收者是指针类型的方法，不会自动生成对应接收者是值类型的方法。</p></blockquote><p><font color=green>Q&amp;A：既然实现接收者是值类型的方法时，会自动实现接收者是指针类型的方法，那么为啥要用指针类型去做接收者？什么时候会去使用指针作为方法的接收者？</font></p><blockquote><p>方法的接收者是值类型的时候，修改的永远是对象的副本，不会对调用者有影响。但是接收者是指针的时候，在方法里修改，就是修改了指针指向的对象本身。当类型是大型的结构体或者不能被安全的复制时，就定义指针接收者方法，例如文件结构体（struct File）。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;Go语言中，接口是不需要像传统的静态编程语言一样进行声明后才能使用。它引用了动态语言的接口使用方式，只需要实现接口要求的相关方法就行，同时还会在编译阶段进行类型匹配，个人觉得非常好用。&lt;/p&gt;</summary>
    
    
    
    <category term="Golang" scheme="https://blog.eganx.cn/categories/Golang/"/>
    
    
    <category term="go" scheme="https://blog.eganx.cn/tags/go/"/>
    
    <category term="interface" scheme="https://blog.eganx.cn/tags/interface/"/>
    
  </entry>
  
  <entry>
    <title>Go Map的遍历</title>
    <link href="https://blog.eganx.cn/2022/10/26/Go_Map_Range/"/>
    <id>https://blog.eganx.cn/2022/10/26/Go_Map_Range/</id>
    <published>2022-10-26T13:33:01.000Z</published>
    <updated>2022-11-20T04:33:57.713Z</updated>
    
    <content type="html"><![CDATA[<p>Map的遍历过程是便利所有的bucket(一般称之为桶)以及挂载的overflow bucket，然后逐一遍历bucket的所有cell，从有key的cell中取出key和value，遍历完成。实际在遍历的时候，有可能map处于扩容过程中,这时候map的状态就相当于是处于一个中间态，即有些bucket已经迁移，有些bucket还在原来的位置。也就是说遍历如果发生在扩容的过程中，就会涉及到遍历新老 bucket 的过程，就比较麻烦。</p><span id="more"></span><h2 id="0x0-Map遍历是无序的"><a href="#0x0-Map遍历是无序的" class="headerlink" title="0x0.Map遍历是无序的"></a>0x0.Map遍历是无序的</h2><p>在遍历map的时候，可以发现key是无序的。正常来说从一个固定Map的第一个bucket的第一个cell逐步遍历取出key的话，key应该是有序的。因为扩容会带来某些key的bucket或者cell发生变化，Go为了避免我们误认为遍历map会得到有序key，在遍历开始的时候，不是从0号bucket开始，而是会给一个随机数，从一个随机的bucket开始，更绝的是在开始bucket中的开始cell也是随机选择的。这样的话，<font color=red>就算是一个写死的map在遍历的时候依旧不会返回一个固定序列的key集合。</font></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// decide where to start</span></span><br><span class="line">r := <span class="keyword">uintptr</span>(fastrand())</span><br><span class="line"><span class="keyword">if</span> h.B &gt; <span class="number">31</span>-bucketCntBits &#123;</span><br><span class="line">r += <span class="keyword">uintptr</span>(fastrand()) &lt;&lt; <span class="number">31</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// start bucket</span></span><br><span class="line">it.startBucket = r &amp; bucketMask(h.B)</span><br><span class="line"><span class="comment">// start cell</span></span><br><span class="line">it.offset = <span class="keyword">uint8</span>(r &gt;&gt; h.B &amp; (bucketCnt - <span class="number">1</span>))</span><br></pre></td></tr></table></figure><h2 id="0x1-遍历过程"><a href="#0x1-遍历过程" class="headerlink" title="0x1.遍历过程"></a>0x1.遍历过程</h2><p>假如有一个起始<code>B=1</code>的map（有0号和1号两个bucket），现在触发扩容，B变成了2（有0-3号4个bucket）。假设现在老0号bucket已经迁移到新0号和新2号bucket中，老1号中的bucket尚未开始迁移。此时开始对map的遍历，假设<code>startBucket = 2,offset = 4</code>，遍历的起点就是2号bucket中第4个cell。bucket的遍历顺序就是：<code>2-&gt;3-&gt;0-&gt;1</code>。</p><ul><li><p>2号bucket对应的是老0号bucket，检查老0号bucket的迁移状态，发现完成已经完成迁移，从4号cell依次遍历2号bucket中所有cell。如果2号bucket返回的key是非空的，就会继续遍历2号bucket的overflow bucket。</p></li><li><p>完成2号bucket的遍历后，开始3号bucket的遍历，检查后发现3号bucket对应的老1号bucket并没有迁移，这个时候就会去遍历老1号bucket。但是并不会取出老1号bucket的全部key，只会取出hash值后两位为<code>11</code>的key，因为这些key最终会迁移进新3号bucket。</p></li><li><p>完成3号bucket的遍历，继续0号bucket的遍历，已迁移，取出新0号bucket中的key。</p></li><li><p>继续1号bucket的遍历，未迁移，遍历老1号bucket，取出hash值后两位为<code>01</code>的key。</p></li><li><p>再次到2号bucket的时候，表示所有bucket遍历完成，map的遍历也就结束了。</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Map的遍历过程是便利所有的bucket(一般称之为桶)以及挂载的overflow bucket，然后逐一遍历bucket的所有cell，从有key的cell中取出key和value，遍历完成。实际在遍历的时候，有可能map处于扩容过程中,这时候map的状态就相当于是处于一个中间态，即有些bucket已经迁移，有些bucket还在原来的位置。也就是说遍历如果发生在扩容的过程中，就会涉及到遍历新老 bucket 的过程，就比较麻烦。&lt;/p&gt;</summary>
    
    
    
    <category term="Golang" scheme="https://blog.eganx.cn/categories/Golang/"/>
    
    
    <category term="go" scheme="https://blog.eganx.cn/tags/go/"/>
    
    <category term="map" scheme="https://blog.eganx.cn/tags/map/"/>
    
  </entry>
  
  <entry>
    <title>Go Map的扩容</title>
    <link href="https://blog.eganx.cn/2022/10/24/Go_Map_Grow/"/>
    <id>https://blog.eganx.cn/2022/10/24/Go_Map_Grow/</id>
    <published>2022-10-24T07:53:19.000Z</published>
    <updated>2022-11-20T04:33:16.832Z</updated>
    
    <content type="html"><![CDATA[<p>在使用slice的时候，如果向slice中追加元素的时候，导致元素数量大于cap，这时候就会发生slice的扩容。那么在go语言中，什么时候map会发生扩容呢？扩容的策略有哪些呢？扩容的过程是怎样的呢？很是好奇，心动不如行动。开始学习，又是收获满满的一天。</p><span id="more"></span><h2 id="0x0-触发扩容的条件"><a href="#0x0-触发扩容的条件" class="headerlink" title="0x0.触发扩容的条件"></a>0x0.触发扩容的条件</h2><p>众所周知，map是使用hash表的。使用hash表的目的就是追求更加快速的找到key，但是当map中key的数量逐渐增加，逐渐离谱的时候，那么碰撞的几率就越来越大，效率也就随之下降了。最离谱的时候就是所有的key都在一个bucket里面 (<del>这是碳基生物能干出来的事?这和链表有个锤子的区别吗？</del>)，最好就是一个bucket里面就一个key，找到了bucket就找到了key，效率贼高，直接拉到o(1)。但是空间不允许啊，为了效率用空间换时间不寒碜？(<del>很寒碜，贼TM寒碜</del>)。</p><p>最好最坏都属于极端，其实都很难遇到，只是在举🌰的时候夸张表述才会用到。在go语言中，有一个<code>loadFactor</code>指标来对上面的两种情况进行衡量。废话不多说，直接上源码(/go1.18.2/src/runtime/map.go)</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断条件在mapassign函数中。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// If we hit the max load factor or we have too many overflow buckets,</span></span><br><span class="line"><span class="comment">// and we&#x27;re not already in the middle of growing, start growing.</span></span><br><span class="line"><span class="keyword">if</span> !h.growing() &amp;&amp; (overLoadFactor(h.count+<span class="number">1</span>, h.B) || tooManyOverflowBuckets(h.noverflow, h.B)) &#123;</span><br><span class="line">hashGrow(t, h)</span><br><span class="line"><span class="keyword">goto</span> again <span class="comment">// Growing the table invalidates everything, so try again</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的条件可以看出，map扩容一个是在<code>overLoadFactor</code>的时候，一个是在<code>tooManyOverflowBuckets</code>。下面是这两个函数所用到的常量以及主要的引用函数。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line"><span class="comment">// Maximum number of key/elem pairs a bucket can hold.</span></span><br><span class="line">bucketCntBits = <span class="number">3</span></span><br><span class="line">bucketCnt     = <span class="number">1</span> &lt;&lt; bucketCntBits <span class="comment">//8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Maximum average load of a bucket that triggers growth is 6.5.</span></span><br><span class="line"><span class="comment">// Represent as loadFactorNum/loadFactorDen, to allow integer math.</span></span><br><span class="line">loadFactorNum = <span class="number">13</span></span><br><span class="line">loadFactorDen = <span class="number">2</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// PtrSize is the size of a pointer in bytes - unsafe.Sizeof(uintptr(0)) but as an ideal constant.</span></span><br><span class="line"><span class="comment">// It is also the size of the machine&#x27;s native word size (that is, 4 on 32-bit systems, 8 on 64-bit).</span></span><br><span class="line"><span class="keyword">const</span> PtrSize = <span class="number">4</span> &lt;&lt; (^<span class="keyword">uintptr</span>(<span class="number">0</span>) &gt;&gt; <span class="number">63</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// bucketShift returns 1&lt;&lt;b, optimized for code generation.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bucketShift</span><span class="params">(b <span class="keyword">uint8</span>)</span> <span class="title">uintptr</span></span> &#123;</span><br><span class="line"><span class="comment">// Masking the shift amount allows overflow checks to be elided.</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">uintptr</span>(<span class="number">1</span>) &lt;&lt; (b &amp; (goarch.PtrSize*<span class="number">8</span> - <span class="number">1</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// overLoadFactor reports whether count items placed in 1&lt;&lt;B buckets is over loadFactor.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">overLoadFactor</span><span class="params">(count <span class="keyword">int</span>, B <span class="keyword">uint8</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> count &gt; bucketCnt &amp;&amp; <span class="keyword">uintptr</span>(count) &gt; loadFactorNum*(bucketShift(B)/loadFactorDen)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// tooManyOverflowBuckets reports whether noverflow buckets is too many for a map with 1&lt;&lt;B buckets.</span></span><br><span class="line"><span class="comment">// Note that most of these overflow buckets must be in sparse use;</span></span><br><span class="line"><span class="comment">// if use was dense, then we&#x27;d have already triggered regular map growth.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tooManyOverflowBuckets</span><span class="params">(noverflow <span class="keyword">uint16</span>, B <span class="keyword">uint8</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="comment">// If the threshold is too low, we do extraneous work.</span></span><br><span class="line"><span class="comment">// If the threshold is too high, maps that grow and shrink can hold on to lots of unused memory.</span></span><br><span class="line"><span class="comment">// &quot;too many&quot; means (approximately) as many overflow buckets as regular buckets.</span></span><br><span class="line"><span class="comment">// See incrnoverflow for more details.</span></span><br><span class="line"><span class="keyword">if</span> B &gt; <span class="number">15</span> &#123;</span><br><span class="line">B = <span class="number">15</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// The compiler doesn&#x27;t see here that B &lt; 16; mask B to generate shorter shift code.</span></span><br><span class="line"><span class="keyword">return</span> noverflow &gt;= <span class="keyword">uint16</span>(<span class="number">1</span>)&lt;&lt;(B&amp;<span class="number">15</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1）第一种情况"><a href="#1）第一种情况" class="headerlink" title="1）第一种情况"></a>1）第一种情况</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// overLoadFactor reports whether count items placed in 1&lt;&lt;B buckets is over loadFactor.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">overLoadFactor</span><span class="params">(count <span class="keyword">int</span>, B <span class="keyword">uint8</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">  <span class="comment">// 换算一下下: count &gt; 8 &amp;&amp; count &gt; 13*((2^B)/2)</span></span><br><span class="line">  <span class="comment">// loadFactor = count/(2^B) &gt; 6.5</span></span><br><span class="line"><span class="keyword">return</span> count &gt; bucketCnt &amp;&amp; <span class="keyword">uintptr</span>(count) &gt; loadFactorNum*(bucketShift(B)/loadFactorDen)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>count</code>是map的元素个数，<code>1&lt;&lt;B</code>表示bucket数组长度。也就是说<font color=red>在<code>loadFactor := count/(2^B)</code>超过6.5的时候，会触发map的扩容</font>。按照<code>loadFactor</code>的计算方式，当所有bucket都满的时候是8。达到6.5的时候也就差不多算是满了大半了，无论查找还是插入，这个时候碰撞的几率很高，效率也会下降的厉害，所以这是触发扩容的时机。</p><p>如果不停的插入元素、删除元素，然后在插入元素。刚开始插入元素的时候会创建大量bucket。但是只要没有达到第一种扩容情况，也就是说loadFactor的值低于6.5。这个时候进行删除元素的操作，降低loadFactor的分子。然后重复操作，就会产生大量overflow bucket。这个时候key就会过于分散，导致查找和插入的效率过低。为了避免这种情况的发生，就有了下面第二种触发扩容的条件。</p><h3 id="2-第二种情况"><a href="#2-第二种情况" class="headerlink" title="2) 第二种情况"></a>2) 第二种情况</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// tooManyOverflowBuckets reports whether noverflow buckets is too many for a map with 1&lt;&lt;B buckets.</span></span><br><span class="line"><span class="comment">// Note that most of these overflow buckets must be in sparse use;</span></span><br><span class="line"><span class="comment">// if use was dense, then we&#x27;d have already triggered regular map growth.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tooManyOverflowBuckets</span><span class="params">(noverflow <span class="keyword">uint16</span>, B <span class="keyword">uint8</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="comment">// If the threshold is too low, we do extraneous work.</span></span><br><span class="line"><span class="comment">// If the threshold is too high, maps that grow and shrink can hold on to lots of unused memory.</span></span><br><span class="line"><span class="comment">// &quot;too many&quot; means (approximately) as many overflow buckets as regular buckets.</span></span><br><span class="line"><span class="comment">// See incrnoverflow for more details.</span></span><br><span class="line"><span class="keyword">if</span> B &gt; <span class="number">15</span> &#123;</span><br><span class="line">B = <span class="number">15</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// The compiler doesn&#x27;t see here that B &lt; 16; mask B to generate shorter shift code.</span></span><br><span class="line"><span class="keyword">return</span> noverflow &gt;= <span class="keyword">uint16</span>(<span class="number">1</span>)&lt;&lt;(B&amp;<span class="number">15</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>翻译成人话：overflow的bucket数量太多了。<font color=red>当<code>B &gt;= 15</code>的时候，如果overflow的bucket数量超过<code>2^15</code>就触发扩容；当<code>B &lt; 15</code>的时候，如果overflow的bucket数量超过<code>2^B</code>就触发扩容。</font>第二种的这个情况主要是为了避免loadFactor的分子小的时候，却有大量的bucket(包括大量的overflow bucket)。</p><h2 id="0x1-扩容策略"><a href="#0x1-扩容策略" class="headerlink" title="0x1.扩容策略"></a>0x1.扩容策略</h2><p>针对两种不同的触发扩容的条件，进行扩容的策略也有所不同。</p><p>第一种情况是由于元素数量过多，导致了bucket数组快满了。这个时候采用的扩容策略就是<code>B+1</code>，bucket的数组长度变成之前的2倍（<font color=red>2倍扩容</font>）</p><p>第二种情况是由于flowbucket的过多造成，元素没有那么多，主要是位置分散，造成查找和插入的效率较低。采用第一种的扩容策略肯定是不行的，解决的办法是采用<font color=red>等量扩容</font>，创建一个和老buckets数组相同长度的新buckets数组。将老buckets中处于同一个bucket的元素进行紧密排列，尽可能的消除overflow bucket，节省空间，提高效率。</p><p>map的扩容不是原子操作，不会一步到位。扩容需要将原本的键值对迁移到新bucket得内存地址中，大量键值对同时迁移会影响性能，所以Go map的扩容是采用“渐进式”方式。每次最多只会迁移2个bucket。</p><h2 id="0x2-迁移过程"><a href="#0x2-迁移过程" class="headerlink" title="0x2.迁移过程"></a>0x2.迁移过程</h2><p>第一种扩容策略，因为<code>B+1</code>会导致key的hash值需要重新计算，才能确定它会落入那个bucket中，毕竟确定bucket位置的是根据hash值的后B位。这样的话就会导致某些key在迁移前后的bucket序号是不一样的。</p><p>举个🌰：初始状态下B=2，3号bucket里有两个key的hash值后3位值<code>011,111</code>，经过B+1扩容之后，这两个原本处于3号bucket的key会分别落入3号和7号bucket。key在迁移前后是否还是处于原本的bucket取决于倒数第3位是0还是1。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">                     ┌───────────────────────┐</span><br><span class="line">                     │                       │</span><br><span class="line">               ┌─────┼─────────────────┐     │</span><br><span class="line">               │     │                 │     │</span><br><span class="line">         ┌─────┼─────┼───────────┐     │     │</span><br><span class="line">         │     │     │           │     │     │</span><br><span class="line">   ┌─────┼─────┼─────┼─────┐     │     │     │</span><br><span class="line">   │     │     │     │     │     │     │     │</span><br><span class="line">┌──┴──┬──┴──┬──┴──┬──┴──┐  │     │     │     │</span><br><span class="line">│     │     │     │     │  │     │     │     │</span><br><span class="line">│  0  │  1  │  2  │  3  │  │     │     │     │</span><br><span class="line">│     │     │     │     │  │     │     │     │</span><br><span class="line">└──┬──┴──┬──┴──┬──┴──┬──┘  │     │     │     │</span><br><span class="line">   │     │     │     │     │     │     │     │</span><br><span class="line">   │     │     │     │     │     │     │     │</span><br><span class="line">   │     │     │     │     │     │     │     │</span><br><span class="line">   │     │     │     │     │     │     │     │</span><br><span class="line">   ▼     ▼     ▼     ▼     ▼     ▼     ▼     ▼</span><br><span class="line">┌─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┐</span><br><span class="line">│     │     │     │     │     │     │     │     │</span><br><span class="line">│  0  │  1  │  2  │  3  │  4  │  5  │  6  │  7  │</span><br><span class="line">│     │     │     │     │     │     │     │     │</span><br><span class="line">└─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┘</span><br></pre></td></tr></table></figure><p>第二种扩容策略，等量扩容因为B是不变的，所以key还是在原来的bucket。主要是为了收拢过于分散的key(<font color=linblue>大多数都分散在overflow bucket中</font>)。下面的图是迁移完成的情况。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">buckets     B&#x3D;2                         buckets     B&#x3D;2</span><br><span class="line">┌─────┬─────┬─────┬─────┐               ┌─────┬─────┬─────┬─────┐</span><br><span class="line">│     │     │     │     │               │     │     │     │     │</span><br><span class="line">│  0  │  1  │  2  │  3  │               │  0  │  1  │  2  │  3  │</span><br><span class="line">│     │     │     │     │               │     │     │     │     │</span><br><span class="line">└─────┴─────┴─────┴──┬──┘               └─────┴─────┴─────┴──┬──┘</span><br><span class="line">                     │                                       │</span><br><span class="line">   ┌─────────────────┘                               ┌───────┘</span><br><span class="line">   │                                                 │</span><br><span class="line">   ▼                                                 ▼</span><br><span class="line">┌────┐      ┌────┐     ┌────┐                     ┌────┐</span><br><span class="line">│bmap│   ┌─►│bmap│  ┌─►│bmap│                     │bmap│</span><br><span class="line">├────┴┐  │  ├────┴┐ │  ├────┴┐                    ├────┴┐</span><br><span class="line">│key:a│  │  │     │ │  │key:f│                    │key:a│</span><br><span class="line">│ 111 │  │  │     │ │  │ 111 │                    │ 111 │</span><br><span class="line">├─────┤  │  ├─────┤ │  ├─────┤                    ├─────┤</span><br><span class="line">│key:b│  │  │     │ │  │     │                    │key:b│</span><br><span class="line">│ 011 │  │  │     │ │  │     │                    │ 011 │</span><br><span class="line">├─────┤  │  ├─────┤ │  ├─────┤                    ├─────┤</span><br><span class="line">│     │  │  │key:d│ │  │     │                    │key:c│</span><br><span class="line">│     │  │  │ 111 │ │  │     │                    │ 011 │</span><br><span class="line">├─────┤  │  ├─────┤ │  ├─────┤                    ├─────┤</span><br><span class="line">│     │  │  │     │ │  │     │                    │key:d│</span><br><span class="line">│     │  │  │     │ │  │     │                    │ 111 │</span><br><span class="line">├─────┤  │  ├─────┤ │  ├─────┤                    ├─────┤</span><br><span class="line">│key:c│  │  │key:e│ │  │     │                    │key:e│</span><br><span class="line">│ 011 │  │  │ 111 │ │  │     │                    │ 111 │</span><br><span class="line">├─────┤  │  ├─────┤ │  ├─────┤                    ├─────┤</span><br><span class="line">│     │  │  │     │ │  │key:g│                    │key:f│</span><br><span class="line">│     │  │  │     │ │  │ 011 │                    │ 111 │</span><br><span class="line">├─────┤  │  ├─────┤ │  ├─────┤                    ├─────┤</span><br><span class="line">│     │  │  │     │ │  │     │                    │key:g│</span><br><span class="line">│     │  │  │     │ │  │     │                    │ 011 │</span><br><span class="line">├─────┤  │  ├─────┤ │  ├─────┤                    ├─────┤</span><br><span class="line">│     │  │  │     │ │  │     │                    │     │</span><br><span class="line">│     │  │  │     │ │  │     │                    │     │</span><br><span class="line">├─────┤  │  ├─────┤ │  ├─────┤                    ├─────┤</span><br><span class="line">│*over│  │  │*over│ │  │*over│                    │*over│</span><br><span class="line">│flow ├──┘  │flow ├─┘  │flow │                    │flow │</span><br><span class="line">└─────┘     └─────┘    └─────┘                    └─────┘</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;在使用slice的时候，如果向slice中追加元素的时候，导致元素数量大于cap，这时候就会发生slice的扩容。那么在go语言中，什么时候map会发生扩容呢？扩容的策略有哪些呢？扩容的过程是怎样的呢？很是好奇，心动不如行动。开始学习，又是收获满满的一天。&lt;/p&gt;</summary>
    
    
    
    <category term="Golang" scheme="https://blog.eganx.cn/categories/Golang/"/>
    
    
    <category term="go" scheme="https://blog.eganx.cn/tags/go/"/>
    
    <category term="map" scheme="https://blog.eganx.cn/tags/map/"/>
    
  </entry>
  
  <entry>
    <title>Go Map的基本介绍</title>
    <link href="https://blog.eganx.cn/2022/10/22/Go_Map/"/>
    <id>https://blog.eganx.cn/2022/10/22/Go_Map/</id>
    <published>2022-10-22T06:53:19.000Z</published>
    <updated>2022-11-20T04:33:23.564Z</updated>
    
    <content type="html"><![CDATA[<p>map由key-value对组成，并且一个key只会出现一次。对map可以进行增删改查一系列操作。在Go语言，map采用的是哈希查找表实现，解决哈希冲突的方式是链表法。记录一下学习过程中了解到的map基本结构和key的定位过程。</p><span id="more"></span><h2 id="0x0-map的基本结构"><a href="#0x0-map的基本结构" class="headerlink" title="0x0.map的基本结构"></a>0x0.map的基本结构</h2><p>附上源码(go1.18.2/src/runtime/map.go)</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A header for a Go map.</span></span><br><span class="line"><span class="keyword">type</span> hmap <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// Note: the format of the hmap is also encoded in</span></span><br><span class="line">  <span class="comment">// cmd/compile/internal/reflectdata/reflect.go.</span></span><br><span class="line"><span class="comment">// Make sure this stays in sync with the compiler&#x27;s definition.</span></span><br><span class="line">count     <span class="keyword">int</span> <span class="comment">// # live cells == size of map.  Must be first (used by len() builtin)</span></span><br><span class="line">flags     <span class="keyword">uint8</span></span><br><span class="line">B         <span class="keyword">uint8</span>  <span class="comment">// log_2 of # of buckets (can hold up to loadFactor * 2^B items)</span></span><br><span class="line">noverflow <span class="keyword">uint16</span> <span class="comment">// approximate number of overflow buckets; see incrnoverflow for details</span></span><br><span class="line">hash0     <span class="keyword">uint32</span> <span class="comment">// hash seed</span></span><br><span class="line"></span><br><span class="line">buckets    unsafe.Pointer <span class="comment">// array of 2^B Buckets. may be nil if count==0.</span></span><br><span class="line">oldbuckets unsafe.Pointer <span class="comment">// previous bucket array of half the size, non-nil only when growing</span></span><br><span class="line">nevacuate  <span class="keyword">uintptr</span>        <span class="comment">// progress counter for evacuation (buckets less than this have been evacuated)</span></span><br><span class="line"></span><br><span class="line">extra *mapextra <span class="comment">// optional fields</span></span><br><span class="line">&#125;                                                               </span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">┌──────┐</span><br><span class="line">│ hmap │</span><br><span class="line">├──────┴─────────────────────┐ ┌─────┐</span><br><span class="line">│          count int         │ │     │</span><br><span class="line">├────────────────────────────┤ │     ▼</span><br><span class="line">│          flags uint8       │ │  ┌──────┐      ┌───────┐</span><br><span class="line">├────────────────────────────┤ │  │[]bmap│    ┌►│ bmap  │</span><br><span class="line">│           B uint8          │ │  ├──────┴─┐  │ ├───────┴───────────────────────┐</span><br><span class="line">├────────────────────────────┤ │  │   0    ├──┘ │   tophash [bucketCnt]uint8    │</span><br><span class="line">│       noverflow uint16     │ │  ├────────┤    ├───────┬───────────────────────┤</span><br><span class="line">├────────────────────────────┤ │  │   1    │    │ key   │                       │</span><br><span class="line">│        hash0 uint32        │ │  ├────────┤    ├───┬───┼───┬───┬───┬───┬───┬───┤</span><br><span class="line">├────────────────────────────┤ │  │   2    │    │ 0 │ 1 │ 2 │ 3 │ 4 │ 5 │ 6 │ 7 │</span><br><span class="line">│   buckets unsafe.Pointer   ├─┘  ├────────┤    ├───┴───┼───┴───┴───┴───┴───┴───┤</span><br><span class="line">├────────────────────────────┤    │   3    │    │ values│                       │</span><br><span class="line">│  oldbuckets unsafe.Pointer │    ├────────┤    ├───┬───┼───┬───┬───┬───┬───┬───┤</span><br><span class="line">├────────────────────────────┤    │  ...   │    │ 0 │ 1 │ 2 │ 3 │ 4 │ 5 │ 6 │ 7 │</span><br><span class="line">│     nevacuates uintptr     │    ├────────┤    ├───┴───┴───┴───┴───┴───┴───┴───┤</span><br><span class="line">├────────────────────────────┤    │   62   │    │        overflow *bmap         │</span><br><span class="line">│       extra *mapextra      │    ├────────┤    └─────┬─────────────────────────┘</span><br><span class="line">└────┬───────────────────────┘    │   63   ├─┐        │</span><br><span class="line">     │                            └────────┘ │        │      ┌───────┐</span><br><span class="line">     ▼                             size&#x3D;2^B  │        └─────►│ bmap  │</span><br><span class="line">┌──────────┐                                 │               ├───────┴───────────────────────┐</span><br><span class="line">│ mapextra │                                 │               │   tophash [bucketCnt]uint8    │</span><br><span class="line">├──────────┴─────────┐                       │               ├───────┬───────────────────────┤</span><br><span class="line">│ overflow *[]*bmap  │   ┌───────┐ ◄─────────┘               │ key   │                       │</span><br><span class="line">├────────────────────┤   │ bmap  │                           ├───┬───┼───┬───┬───┬───┬───┬───┤</span><br><span class="line">│oldoverflow *[]*bmap│   ├───────┴───────────────────────┐   │ 0 │ 1 │ 2 │ 3 │ 4 │ 5 │ 6 │ 7 │</span><br><span class="line">├────────────────────┤   │   tophash [bucketCnt]uint8    │   ├───┴───┼───┴───┴───┴───┴───┴───┤</span><br><span class="line">│ nextoverflow *bmap │   ├───────┬───────────────────────┤   │ values│                       │</span><br><span class="line">└────────────────────┘   │ key   │                       │   ├───┬───┼───┬───┬───┬───┬───┬───┤</span><br><span class="line">                         ├───┬───┼───┬───┬───┬───┬───┬───┤   │ 0 │ 1 │ 2 │ 3 │ 4 │ 5 │ 6 │ 7 │</span><br><span class="line">                         │ 0 │ 1 │ 2 │ 3 │ 4 │ 5 │ 6 │ 7 │   ├───┴───┴───┴───┴───┴───┴───┴───┤</span><br><span class="line">                         ├───┴───┼───┴───┴───┴───┴───┴───┤   │        overflow *bmap         │</span><br><span class="line">                         │ values│                       │   └───────────────────────────────┘</span><br><span class="line">                         ├───┬───┼───┬───┬───┬───┬───┬───┤</span><br><span class="line">                         │ 0 │ 1 │ 2 │ 3 │ 4 │ 5 │ 6 │ 7 │</span><br><span class="line">                         ├───┴───┴───┴───┴───┴───┴───┴───┤       ┌────────┐</span><br><span class="line">                         │        overflow *bmap         ├──────►│  nil   │</span><br><span class="line">                         └───────────────────────────────┘       └────────┘</span><br></pre></td></tr></table></figure><p>其中B是bucket数组长度的对数，bucket里面存储了key和value。可以看见一个bucket里面最多能装8个key，这8个key在bucket里面的位置根据hash值的高8位决定。nevacuate表示扩容进度，小于此地址的 buckets 迁移完成。Ascii风格的map内存模型图是参考曹大github里的，曹大yyds。</p><p>其中bucket指针指向的结构体如下：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A bucket for a Go map.</span></span><br><span class="line"><span class="keyword">type</span> bmap <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// tophash generally contains the top byte of the hash value</span></span><br><span class="line"><span class="comment">// for each key in this bucket. If tophash[0] &lt; minTopHash,</span></span><br><span class="line"><span class="comment">// tophash[0] is a bucket evacuation state instead.</span></span><br><span class="line">tophash [bucketCnt]<span class="keyword">uint8</span></span><br><span class="line"><span class="comment">// Followed by bucketCnt keys and then bucketCnt elems.</span></span><br><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> packing all the keys together and then all the elems together makes the</span></span><br><span class="line"><span class="comment">// code a bit more complicated than alternating key/elem/key/elem/... but it allows</span></span><br><span class="line"><span class="comment">// us to eliminate padding which would be needed for, e.g., map[int64]int8.</span></span><br><span class="line"><span class="comment">// Followed by an overflow pointer.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">┌───────┐</span><br><span class="line">│ bmap  │</span><br><span class="line">├───────┴───────────────────────┐</span><br><span class="line">│   tophash [bucketCnt]uint8    │</span><br><span class="line">├───────┬───────────────────────┤</span><br><span class="line">│ key   │                       │</span><br><span class="line">├───┬───┼───┬───┬───┬───┬───┬───┤</span><br><span class="line">│ 0 │ 1 │ 2 │ 3 │ 4 │ 5 │ 6 │ 7 │</span><br><span class="line">├───┴───┼───┴───┴───┴───┴───┴───┤</span><br><span class="line">│ values│                       │</span><br><span class="line">├───┬───┼───┬───┬───┬───┬───┬───┤</span><br><span class="line">│ 0 │ 1 │ 2 │ 3 │ 4 │ 5 │ 6 │ 7 │</span><br><span class="line">├───┴───┴───┴───┴───┴───┴───┴───┤</span><br><span class="line">│        overflow *bmap         │</span><br><span class="line">└───────────────────────────────┘</span><br></pre></td></tr></table></figure><p>其中key和value是各自存放在一起的，为什么要这么做呢，以下是在注释中的官方解释。</p><blockquote><pre><code>NOTE: packing all the keys together and then all the elems together makes thecode a bit more complicated than alternating key/elem/key/elem/... but it allowsus to eliminate padding which would be needed for, e.g., map[int64]int8.</code></pre></blockquote><p>主要是为了减少内存对齐带来的padding。注释中给了一个例子<code>map[int64]int8</code>，如果是按照<code>key/elem/key/elem/</code>这种方式存储，相当于每一个<code>key/elem</code>都需要padding7个字节。64位的机器上，默认的对齐系数是8，同时<code>int8</code>的对齐系数是1，<code>int64</code>的对齐系数是8。以下是<code>key/elem</code>方式产生padding的过程：</p><ul><li>第一个key，key1(int64)的大小和对齐值是8，占据8位。暂且写做：kkkkkkkk</li><li>第一个value，value1(int8)的大小和对齐值是1，占据1位。写做：kkkkkkkk｜v</li><li>第二个key，key2(int64)的大小和对齐值是8，偏移量必须是8的倍数。也就产生了padding。不能直接接着value1后面写了，写作：kkkkkkkk｜vxxxxxxx｜kkkkkkkk。其中x表示padding。后面也就是依次类推了。</li></ul><p>如果是按照<code>key/key/key/.../key/elem/elem/.../elem</code>来进行存储的话，只需要在最后面添加padding就行。内存对齐一般好像不怎么会考虑，但是了解还是需要了解的，TODO List再加一项。</p><h2 id="0x1-map中key的位置"><a href="#0x1-map中key的位置" class="headerlink" title="0x1.map中key的位置"></a>0x1.map中key的位置</h2><p>在64位的机器上面，key经过hash计算后会得到一个64bit的哈希值。在key的定位过程中会用到哈希值的高8位和后B位。B就是hmap中的B，如果B=6，buckets数组的长度就是2^6=64。</p><p>举个🌰,现在有一个key的哈希值如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">00000111 | 00001111111011001111111111101010001000000001010000 | 000010</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">                                    key</span><br><span class="line"></span><br><span class="line">┌────────────────────────────────────────────────────────────────────────┐</span><br><span class="line">│ 00000111 | 00001111111011001111111111101010001000000001010000 | 000010 │</span><br><span class="line">└────┬──────────────────────────────────────────────────────────────┬────┘</span><br><span class="line">     │                                                              │</span><br><span class="line">     │                                                              ▼</span><br><span class="line">     │                                     B&#x3D;6          ┌────────────────┐</span><br><span class="line">     │                              bucketMask&#x3D;111111   │ 000010&amp;111111  │</span><br><span class="line">     │                                                  └────────────┬───┘</span><br><span class="line">     │ tophash                                                       │</span><br><span class="line">     │                                                               ▼</span><br><span class="line">     │                                                          ┌────────┐</span><br><span class="line">     │                                    ┌─────────────────────┤000010&#x3D;2│</span><br><span class="line">     ▼                                    │                     └────────┘</span><br><span class="line">┌────────────┐                 buckets    ▼</span><br><span class="line">│ 00000111&#x3D;7 │                  ┌───┬───┬───┬───┬──────────┬────┬────┬────┐</span><br><span class="line">└─────┬──────┘                  │ 0 │ 1 │ 2 │ 3 │    ...   │ 61 │ 62 │ 63 │</span><br><span class="line">      │                         └───┴───┴─┬─┴───┴──────────┴────┴────┴────┘</span><br><span class="line">      │                                   │</span><br><span class="line">      │                                   │</span><br><span class="line">      └─────────────────────────────┐     │</span><br><span class="line">                                    │     ▼</span><br><span class="line">           ┌────────────────────────┼────────────┬──────┐</span><br><span class="line">           │                        │            │bucket│</span><br><span class="line">           │  ┌───────┐             │            ├──────┘</span><br><span class="line">           │  │ bmap  │             ▼            │</span><br><span class="line">           │  ├───┬───┼───┬───┬───┬───┬───┬───┐  │</span><br><span class="line">           │  │111│ 9 │ 3 │ 5 │ 6 │ 7 │ 0 │ 0 │  │</span><br><span class="line">           │  ├───┴───┼───┴───┴───┴───┴───┴───┤  │</span><br><span class="line">           │  │ key   │                       │  │</span><br><span class="line">           │  ├───┬───┼───┬───┬───┬───┬───┬───┤  │</span><br><span class="line">           │  │ 5 │ 2 │ 1 │ 4 │ 3 │ 9 │ 0 │ 0 │  │</span><br><span class="line">           │  ├───┴───┼───┴───┴───┴───┴───┴───┤  │</span><br><span class="line">           │  │ values│                       │  │</span><br><span class="line">           │  ├───┬───┼───┬───┬───┬───┬───┬───┤  │</span><br><span class="line">           │  │ 3 │ 5 │ 4 │ 7 │ 9 │ 6 │ 0 │ 0 │  │</span><br><span class="line">           │  ├───┴───┴───┴───┴───┴───┴───┴───┤  │</span><br><span class="line">           │  │        overflow *bmap         │  │</span><br><span class="line">           │  └───────────────────────────────┘  │</span><br><span class="line">           │                                     │</span><br><span class="line">           └─────────────────────────────────────┘</span><br></pre></td></tr></table></figure><p>如果在 bucket 中没找到，并且 overflow 不为空，还要继续去 overflow bucket 中寻找，直到找到或是所有的 key 槽位都找遍了，包括所有的 overflow bucket。</p><p>实现上有 mapaccess1，mapaccess2，mapaccessK 几个方法，主要区别是在返回内容上。当要查询的 key 不在 map 里，mapaccess2的用法会返回一个 bool 型变量提示 key 是否在 map 中；而mapaccess1 的语句则会返回一个 key 对应 value 类型的零值。如果 value 是 int 型就会返回 0，如果 value 是 string 类型，就会返回空字符串。mapaccess2就是日常代码中<code>v, ok := map[k]</code>的底层函数。</p><h2 id="0x2-Go-Map是线程安全的吗？"><a href="#0x2-Go-Map是线程安全的吗？" class="headerlink" title="0x2.Go Map是线程安全的吗？"></a>0x2.Go Map是线程安全的吗？</h2><p>map不是线程安全的。在对map进行读写操作的时候都会先检测写标志，发现写标志位置1，会panic。所以不能一边写入一边遍历。</p><p>一个协程内一边删除一边遍历的操作是允许的，但是真的这么干了，大概率会被打。毕竟遍历出来的结果有可能会包含已经删除的元素。</p><p>上面的两种情况看看就行，真要写的时候一般都会加读写锁：<code>sync.RWMutex</code>。</p><blockquote><p>map不是线程安全的，但是sync.Map是线程安全。</p></blockquote><h2 id="0x3-如何判断两个map是否相等"><a href="#0x3-如何判断两个map是否相等" class="headerlink" title="0x3.如何判断两个map是否相等"></a>0x3.如何判断两个map是否相等</h2><p>两个map是否相等不能直接通过<code>==</code>判断，编译报错。</p><p>引用书里的map深度相等的条件：</p><blockquote><p>1、都为nil</p><p>2、非空，长度相等，指向同一个map实体</p><p>3、相同的key指向的value“深度”相等</p></blockquote><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> m <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> n <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">fmt.Println(m == <span class="literal">nil</span>) <span class="comment">//OK</span></span><br><span class="line">fmt.Println(n == <span class="literal">nil</span>) <span class="comment">//OK</span></span><br><span class="line">fmt.Println(m == n) <span class="comment">//编译报错</span></span><br></pre></td></tr></table></figure><p>因此只能是遍历map 的每个元素，比较元素是否都是深度相等。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;map由key-value对组成，并且一个key只会出现一次。对map可以进行增删改查一系列操作。在Go语言，map采用的是哈希查找表实现，解决哈希冲突的方式是链表法。记录一下学习过程中了解到的map基本结构和key的定位过程。&lt;/p&gt;</summary>
    
    
    
    <category term="Golang" scheme="https://blog.eganx.cn/categories/Golang/"/>
    
    
    <category term="go" scheme="https://blog.eganx.cn/tags/go/"/>
    
    <category term="map" scheme="https://blog.eganx.cn/tags/map/"/>
    
  </entry>
  
  <entry>
    <title>Go Slice的扩容策略</title>
    <link href="https://blog.eganx.cn/2022/10/15/Go_Slice_growup/"/>
    <id>https://blog.eganx.cn/2022/10/15/Go_Slice_growup/</id>
    <published>2022-10-15T04:56:11.000Z</published>
    <updated>2022-11-20T04:33:01.426Z</updated>
    
    <content type="html"><![CDATA[<p>在写Go的时候，对Slice的操作就很危险，特别是函数参数传的是Slice指针，一不小心就改了。切片支持子切片  和原本切片共享底层数组，那子切片和切片究竟会不会相互影响？ 就看他们是不是还共享底层数组。如果他们的结构没有变化，肯定是共享的。结构发生变化(扩容)，就可能不共享了。</p><p>对子切片的使用建议：只读不改</p><span id="more"></span><h2 id="0x0-Slice和Array的联系"><a href="#0x0-Slice和Array的联系" class="headerlink" title="0x0.Slice和Array的联系"></a>0x0.Slice和Array的联系</h2><p>slice 的底层数据是数组，slice 是对数组的封装。两者都可以通过下标来访问单个元素。</p><p>数组就是一片连续的内存，是定长的，其长度是类型的一部分，比如 [3]int 和 [4]int 就是不同的类型。</p><p>slice可以动态地扩容，切片的类型和长度无关。</p><p>slice 是一个结构体，包含三个字段：长度、容量、底层数组。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type slice struct &#123;</span><br><span class="line">array unsafe.Pointer &#x2F;&#x2F; 元素指针</span><br><span class="line">len   int &#x2F;&#x2F; 长度 </span><br><span class="line">cap   int &#x2F;&#x2F; 容量</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不是每一个Slice都有自己专属的底层数组，底层数组是可以被多个Slice同时指向的，也就是说在修改SliceA的数据时，有可能SliceB的数据也会发生改变。</p><h2 id="0x1-Slice扩容策略"><a href="#0x1-Slice扩容策略" class="headerlink" title="0x1.Slice扩容策略"></a>0x1.Slice扩容策略</h2><p>在golang1.18版本之前，Slice的扩容策略是当原 slice 容量小于 <code>1024</code> 的时候，新 slice 容量变成原来的 <code>2</code> 倍；原 slice 容量超过 <code>1024</code>，新 slice 容量变成原来的<code>1.25</code>倍。</p><p>在golang1.18版本之后，新的Slice扩容策略是当原slice容量(oldcap)小于<code>256</code>的时候，新slice(newcap)容量为原来的<code>2</code>倍；原slice容量超过<code>256</code>，新slice容量<code>newcap = oldcap+(oldcap+3*256)/4</code></p><blockquote><p>在实际的扩容过程中，还需要考虑内存对齐产生的影响，这个和内存分配策略相关。进行内存对齐之后，新 slice 的容量是要 <code>大于等于</code> 理论的扩容量。</p></blockquote><p>经典例题，来自<a href="https://jodezer.github.io/2017/05/golangSlice%E7%9A%84%E6%89%A9%E5%AE%B9%E8%A7%84%E5%88%99">golang Slice的扩容规则</a></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>&#125;</span><br><span class="line">s = <span class="built_in">append</span>(s,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;len=%d, cap=%d&quot;</span>,<span class="built_in">len</span>(s),<span class="built_in">cap</span>(s))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">len&#x3D;5, cap&#x3D;6</span><br></pre></td></tr></table></figure></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;在写Go的时候，对Slice的操作就很危险，特别是函数参数传的是Slice指针，一不小心就改了。切片支持子切片  和原本切片共享底层数组，那子切片和切片究竟会不会相互影响？ 就看他们是不是还共享底层数组。如果他们的结构没有变化，肯定是共享的。结构发生变化(扩容)，就可能不共享了。&lt;/p&gt;
&lt;p&gt;对子切片的使用建议：只读不改&lt;/p&gt;</summary>
    
    
    
    <category term="Golang" scheme="https://blog.eganx.cn/categories/Golang/"/>
    
    
    <category term="go" scheme="https://blog.eganx.cn/tags/go/"/>
    
    <category term="slice" scheme="https://blog.eganx.cn/tags/slice/"/>
    
  </entry>
  
  <entry>
    <title>C# GC机制(Garbage Collector)</title>
    <link href="https://blog.eganx.cn/2022/02/08/CSharp_GC_mechanism/"/>
    <id>https://blog.eganx.cn/2022/02/08/CSharp_GC_mechanism/</id>
    <published>2022-02-08T13:31:19.000Z</published>
    <updated>2022-11-20T02:42:11.675Z</updated>
    
    <content type="html"><![CDATA[<p>记录一下C#中GC的相关知识。不记下来，下次又找不到，就很烦。</p><p>主要针对的是C#中如何判定Garbage和GC的运作方式。</p><span id="more"></span><h2 id="0x0-资源概念"><a href="#0x0-资源概念" class="headerlink" title="0x0.资源概念"></a>0x0.资源概念</h2><p>所谓的资源其实就是程序中可以利用的数据。比如字符串、图片和任何的二进制数据。</p><p>托管资源，非托管资源：托管资源是由CLR全权负责的资源，CLR不负责的资源位非托管资源。<br><strong>对于托管资源通过GC自动清理回收。对于非托管的资源，一般就是Stream，数据库的连接，网络连接，GDI+的相关对象，还有Com对象等等这些操作系统资源，需要我们手动去释放，再由GC回收。</strong>  </p><h2 id="0x1-Garbage的判定"><a href="#0x1-Garbage的判定" class="headerlink" title="0x1.Garbage的判定"></a>0x1.Garbage的判定</h2><p>.Net类型分为两大类，<strong>一个就是值类型，另一个就是引用类型。前者是在堆栈中分配内存，它们有自身的生命周期，所以不用对它们进行管理，会自动分配和释放。后者是在堆中分配内存的。所以它的分配和释放就需要像回收机制来管理。</strong></p><p>GC的全称为“Garbage Collector”,顾名思义就是垃圾回收器，那么只有被称为垃圾的对象才能被GC回收。也就是说， 一个引用类型对象所占用的内存需要被GC回收，需要先成为垃圾。 <strong>.Net判定一个引用类型对象是垃圾，只需要判定此对象或者其包含的子对象没有任何引用是有效的，那么系统就认为它是垃圾。</strong></p><h2 id="0x2-非托管资源的释放方式"><a href="#0x2-非托管资源的释放方式" class="headerlink" title="0x2.非托管资源的释放方式"></a>0x2.非托管资源的释放方式</h2><h3 id="1-Close"><a href="#1-Close" class="headerlink" title="1).Close()"></a>1).Close()</h3><p>关闭对象资源，在显示调用时被调用。</p><h3 id="2-Dispose"><a href="#2-Dispose" class="headerlink" title="2).Dispose()"></a>2).Dispose()</h3><p>继承IDisposable接口，实现Dispose方法；<br>介绍：调用Dispose方法，销毁对象，需要显示调用或者通过using语句，在显示调用或者离开using程序块时被调用。<br>Dispose方法用于清理对象封装的非托管资源，而不是释放对象的内存，对象的内存依然由垃圾回收器控制。<br>Dispose方法调用，不但释放该类的非托管资源，还释放了引用的类的非托管资源。<br>Dispose模式就是一种强制资源清理所要遵守的约定；Dispose模式实现IDisposable接口，从而使得该类型提供一个公有的Dispose方法。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">而Close与Dispose这两种方法的区别在于，调用完了对象的Close方法后，此对象有可能被重新进</span><br><span class="line">行使用；而Dispose方法来说，此对象所占有的资源需要被标记为无用了，也就是此对象被销毁了，</span><br><span class="line">不能再被使用。</span><br></pre></td></tr></table></figure><h3 id="3-析构函数-Finalize"><a href="#3-析构函数-Finalize" class="headerlink" title="3).析构函数/Finalize()"></a>3).析构函数/Finalize()</h3><p>带有析构函数的类，生命周期会变长。内存空间需要两次垃圾回收才会被释放，导致性能下降。</p><p>一个正常情况的类是不会写析构函数的，而一旦一个类写了析构函数，就意味着GC会在不确定的时间调用该类的析构函数，判断该类的资源是否需要释放，然后调用Finalize方法，如果重写了Finalize方法则调用重写的Finalize方法。<br>Finalize方法的作用是保证.NET对象能在垃圾回收时清除非托管资源。<br>在.NET中，Object.Finalize()方法是无法重载的，编译器是根据类的析构函数来自动生成Object.Finalize()方法的<br>Finalize由垃圾回收器调用；dispose由对象调用。<br>Finalize无需担心因为没有调用Finalize而使非托管资源得不到释放，因为GC会在不确定时间调用，当然，你也可以手动调用Finalize方法，而dispose必须手动调用。<br>Finalize虽然无需担心因为没有调用Finalize而使非托管资源得不到释放，但因为由垃圾回收器管理，不能保证立即释放非托管资源；而dispose一调用便释放非托管资源。<br>只有类类型才能重写Finalize，而结构不能；类和结构都能实现IDispose</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">释放模式：是一种微软建议的写法，先手动显示去释放资源，如果忘记了，再让finalize释放资源。</span><br><span class="line">所以如果已经完成了析构函数该干的事情(例如释放非托管资源)，就应当使用SuppressFinalize</span><br><span class="line">方法告诉GC不需要再执行某个对象的析构函数。</span><br></pre></td></tr></table></figure><h2 id="0x3-GC的运作方式"><a href="#0x3-GC的运作方式" class="headerlink" title="0x3.GC的运作方式"></a>0x3.GC的运作方式</h2><p>内存的释放和回收需要伴随着程序的运行，因此系统为GC安排了独立的线程。那么GC的工作大致是，查询内存中对象是否成为垃圾，然后对垃圾进行释放和回收。那么对于GC对于内存回收采取了一定的优先算法进行轮循回收内存资源。</p><p>其次，<strong>对于内存中的垃圾分为两种，一种是需要调用对象的析构函数，另一种是不需要调用的。GC对于前者的回收需要通过两步完成，第一步是调用对象的析构函数，第二步是回收内存，但是要注意这两步不是在GC一次轮循完成，即需要两次轮循；相对于后者，则只是回收内存而已。</strong></p><p>C#中的GC使用了Generation的概念，它将分配的对象分为3代(可用GC.GetGeneration方法返回任意作为参数的对象当前所处的代)。</p><p>最近被分配内存的对象被放置于第0代，因为第0代很小，小到足以放进处理器的二级（L2)缓存，所以它能够提供对对象的快速存取。经过一轮垃圾回收后，仍然保留在第0代中的对象被移进第1代中，再经过一轮垃圾内存回收后，仍然保留在第1代中的对象则被移进第2代中，第2代中包含了生存期较长的对象。 当第0代中没有可以分配的有效内存时，就触发了第0代中的一轮垃圾回收，它将删除那些不再被引用的对象，并将当前正在使用的对象移至第1代。而当第0代垃圾回收后依然不能请求到充足的内存时，就启动第1代垃圾回收。如果对各代都进行了垃圾回收后仍没有可用的内存就会引发一个OutOfMemoryException异常。</p><table><thead><tr><th align="center"></th><th align="center">Close</th><th align="center">Dispose</th><th align="center">析构函数</th></tr></thead><tbody><tr><td align="center"></td><td align="center">关闭对象资源</td><td align="center">销毁对象</td><td align="center">销毁对象</td></tr><tr><td align="center">调用方式</td><td align="center">需要显示调用</td><td align="center">需要显示调用或者通过using语句</td><td align="center">不能被显示调用，会被GC调用</td></tr><tr><td align="center">调用时机</td><td align="center">在显示调用时</td><td align="center">在显示调用或者离开using程序块</td><td align="center">不确定</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;p&gt;记录一下C#中GC的相关知识。不记下来，下次又找不到，就很烦。&lt;/p&gt;
&lt;p&gt;主要针对的是C#中如何判定Garbage和GC的运作方式。&lt;/p&gt;</summary>
    
    
    
    <category term="Work" scheme="https://blog.eganx.cn/categories/Work/"/>
    
    <category term="C#" scheme="https://blog.eganx.cn/categories/Work/C/"/>
    
    
    <category term="C#" scheme="https://blog.eganx.cn/tags/C/"/>
    
    <category term="GC" scheme="https://blog.eganx.cn/tags/GC/"/>
    
  </entry>
  
  <entry>
    <title>Go版本切换</title>
    <link href="https://blog.eganx.cn/2022/01/05/Go_Version_switching/"/>
    <id>https://blog.eganx.cn/2022/01/05/Go_Version_switching/</id>
    <published>2022-01-05T13:06:11.000Z</published>
    <updated>2022-11-15T09:02:25.162Z</updated>
    
    <content type="html"><![CDATA[<p>线上的程序用的是老版本的Go(毕竟比较稳)，自己又想尝试新的版本特性。久而久之，电脑里面SDK的版本就越来越多了，每次切换起来就很麻烦。所以特此记录一下。</p><span id="more"></span><h2 id="0x0-手动管理-目前使用的切换方式"><a href="#0x0-手动管理-目前使用的切换方式" class="headerlink" title="0x0.手动管理(目前使用的切换方式)"></a>0x0.手动管理(目前使用的切换方式)</h2><p>官网下载最新版Archive文件go1.18beta1.darwin-amd64.tar.gz</p><p>解压缩重命名go1.18.beta1,拷贝一份放到默认安装路径<code>/usr/local/go1.18beta1</code></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo cp -R /User/egan/Sdks/go1.18beta1 /usr/local/go1.18beta1</span><br></pre></td></tr></table></figure><p>进入默认安装路径，创建软链</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /usr/local/</span><br><span class="line">sudo ln -s go1.18beta1 go</span><br></pre></td></tr></table></figure><h2 id="0x1-版本切换工具"><a href="#0x1-版本切换工具" class="headerlink" title="0x1.版本切换工具"></a>0x1.版本切换工具</h2><h3 id="1-g"><a href="#1-g" class="headerlink" title="1).g"></a>1).g</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GitHub:https:&#x2F;&#x2F;github.com&#x2F;voidint&#x2F;g</span><br></pre></td></tr></table></figure><h3 id="2-goup"><a href="#2-goup" class="headerlink" title="2).goup"></a>2).goup</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Github:https:&#x2F;&#x2F;github.com&#x2F;owenthereal&#x2F;goup</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;线上的程序用的是老版本的Go(毕竟比较稳)，自己又想尝试新的版本特性。久而久之，电脑里面SDK的版本就越来越多了，每次切换起来就很麻烦。所以特此记录一下。&lt;/p&gt;</summary>
    
    
    
    <category term="Golang" scheme="https://blog.eganx.cn/categories/Golang/"/>
    
    
    <category term="go" scheme="https://blog.eganx.cn/tags/go/"/>
    
    <category term="版本切换" scheme="https://blog.eganx.cn/tags/%E7%89%88%E6%9C%AC%E5%88%87%E6%8D%A2/"/>
    
  </entry>
  
  <entry>
    <title>C#内存泄露</title>
    <link href="https://blog.eganx.cn/2022/01/03/CSharp_OOM/"/>
    <id>https://blog.eganx.cn/2022/01/03/CSharp_OOM/</id>
    <published>2022-01-03T04:31:19.000Z</published>
    <updated>2022-11-20T02:42:25.089Z</updated>
    
    <content type="html"><![CDATA[<p>记录自己干的蠢事，这也是自己第一次在工作中写出来内存泄漏。幸亏程序没有直接上线，以后还是要多测试测试自己的代码。</p><span id="more"></span><h2 id="0x0-问题产生原因"><a href="#0x0-问题产生原因" class="headerlink" title="0x0.问题产生原因"></a>0x0.问题产生原因</h2><p>在<code>button1.Click += Button1_Click</code>中，(+=) 来为事件附加事件处理程序</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Form1</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    InitializeComponent();</span><br><span class="line">    button1.Click += Button1_Click;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Button1_Click</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line"><span class="function"></span> &#123;</span><br><span class="line">     System.Diagnostics.Debug.Print(<span class="string">&quot;x&quot;</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">event</span> EventHandler Click;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">EventHandler</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span>;</span><br></pre></td></tr></table></figure><p>给button1_Click的附加事件处理程序放在了心跳里面；</p><p>此次溢出是因为每次心跳，又进行了一次事件处理程序的附加，造成不断附件事件处理程序。</p><p>直至最后，点击一次，要运行2K+次的事件处理程序。</p><p>而事件处理程序的代码里面会使用创建新的线程，运行一次，创建大量的新线程，线程数直接飙升，内存崩掉。</p><h2 id="0x1-定位内存泄露发生的地方："><a href="#0x1-定位内存泄露发生的地方：" class="headerlink" title="0x1.定位内存泄露发生的地方："></a>0x1.定位内存泄露发生的地方：</h2><p>C#的代码可以使用内存分析工具dotMemory。dotMemory允许你分析各种.NET和.NET Core应用程序的内存使用情况；比如桌面应用程序、Windows服务、ASP.NET Web应用程序、IIS、IIS Express、任意.NET进程等。不过临时用一下可以，有30天的试用期，还是比较好用的。</p><p>溢出版本源码示例:</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">WindowsFormsApp1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">Form1</span> : <span class="title">Form</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Form1</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            InitializeComponent();</span><br><span class="line">            button1.Click += Button1_Click;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Cycle</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            button1.Click += Button1_Click;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Button1_Click</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            i += <span class="number">1</span>;</span><br><span class="line">            System.Diagnostics.Debug.Print(<span class="string">&quot;x:&#123;0&#125;&quot;</span>,i);</span><br><span class="line">            Cycle();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正常版本源码示例：</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">WindowsFormsApp1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">Form1</span> : <span class="title">Form</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Form1</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            InitializeComponent();</span><br><span class="line">            button1.Click += Button1_Click;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Button1_Click</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            i += <span class="number">1</span>;</span><br><span class="line">            System.Diagnostics.Debug.Print(<span class="string">&quot;x:&#123;0&#125;&quot;</span>,i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;记录自己干的蠢事，这也是自己第一次在工作中写出来内存泄漏。幸亏程序没有直接上线，以后还是要多测试测试自己的代码。&lt;/p&gt;</summary>
    
    
    
    <category term="Work" scheme="https://blog.eganx.cn/categories/Work/"/>
    
    <category term="C#" scheme="https://blog.eganx.cn/categories/Work/C/"/>
    
    
    <category term="C#" scheme="https://blog.eganx.cn/tags/C/"/>
    
    <category term="OOM" scheme="https://blog.eganx.cn/tags/OOM/"/>
    
  </entry>
  
  <entry>
    <title>C#串口读写连续性问题</title>
    <link href="https://blog.eganx.cn/2022/01/01/CSharp_Serial_port_readwrite_continuity_problem/"/>
    <id>https://blog.eganx.cn/2022/01/01/CSharp_Serial_port_readwrite_continuity_problem/</id>
    <published>2022-01-01T03:31:19.000Z</published>
    <updated>2022-11-20T02:42:29.078Z</updated>
    
    <content type="html"><![CDATA[<p>在使用串口协议进行自定义协议读写的时候，一般使用Ascii编码。但是串口中读取到的数据并不能保证其完整性。一条指令有可能会被拆分成多条数据发送，读取到的字符串有可能只是其中的一部分。一般一条指令的末尾都会加上\n\r作为结束符。</p><span id="more"></span><h2 id="0x0-创建连接"><a href="#0x0-创建连接" class="headerlink" title="0x0.创建连接"></a>0x0.创建连接</h2><p>串口使用System.IO.Ports.SerialPort来创建连接</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 摘要:</span></span><br><span class="line"><span class="comment">//     使用指定的端口名、波特率、奇偶校验位、数据位和停止位初始化 System.IO.Ports.SerialPort 类的新实例。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 参数:</span></span><br><span class="line"><span class="comment">//   portName:</span></span><br><span class="line"><span class="comment">//     要使用的端口（例如 COM1）。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//   baudRate:</span></span><br><span class="line"><span class="comment">//     波特率。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//   parity:</span></span><br><span class="line"><span class="comment">//     System.IO.Ports.SerialPort.Parity 值之一。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//   dataBits:</span></span><br><span class="line"><span class="comment">//     数据位值。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//   stopBits:</span></span><br><span class="line"><span class="comment">//     System.IO.Ports.SerialPort.StopBits 值之一。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 异常:</span></span><br><span class="line"><span class="comment">//   T:System.IO.IOException:</span></span><br><span class="line"><span class="comment">//     未能找到或打开指定的端口。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SerialPort</span>(<span class="params"><span class="built_in">string</span> portName, <span class="built_in">int</span> baudRate, Parity parity, <span class="built_in">int</span> dataBits, StopBits stopBits</span>)</span>;</span><br></pre></td></tr></table></figure><p>其中Parity和StopBits的枚举分别为：</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 摘要:</span></span><br><span class="line"><span class="comment">// 指定 System.IO.Ports.SerialPort 对象的奇偶校验位。</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> Parity</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 摘要:</span></span><br><span class="line">    <span class="comment">// 不发生奇偶校验检查。</span></span><br><span class="line">    None = <span class="number">0</span>,</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 摘要:</span></span><br><span class="line">    <span class="comment">// 设置奇偶校验位，使位数等于奇数。</span></span><br><span class="line">    Odd = <span class="number">1</span>,</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 摘要:</span></span><br><span class="line">    <span class="comment">// 设置奇偶校验位，使位数等于偶数。</span></span><br><span class="line">    Even = <span class="number">2</span>,</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 摘要:</span></span><br><span class="line">    <span class="comment">// 将奇偶校验位保留为 1。</span></span><br><span class="line">    Mark = <span class="number">3</span>,</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 摘要:</span></span><br><span class="line">    <span class="comment">// 将奇偶校验位保留为 0。</span></span><br><span class="line">    Space = <span class="number">4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 摘要:</span></span><br><span class="line"><span class="comment">// 指定在 System.IO.Ports.SerialPort 对象上使用的停止位的数目。</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> StopBits</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 摘要:</span></span><br><span class="line">    <span class="comment">// 不使用停止位。 System.IO.Ports.SerialPort.StopBits 属性不支持此值。</span></span><br><span class="line">    None = <span class="number">0</span>,</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 摘要:</span></span><br><span class="line">    <span class="comment">// 使用一个停止位。</span></span><br><span class="line">    One = <span class="number">1</span>,</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 摘要:</span></span><br><span class="line">    <span class="comment">// 使用两个停止位。</span></span><br><span class="line">    Two = <span class="number">2</span>,</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 摘要:</span></span><br><span class="line">    <span class="comment">// 使用 1.5 个停止位。</span></span><br><span class="line">    OnePointFive = <span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>连接完成后需要保证端口的开启，可使用IsOpen参数进行判定。</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!Conn.IsOpen)</span><br><span class="line">&#123;</span><br><span class="line">    Conn.Open();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0x1-数据的读写部分"><a href="#0x1-数据的读写部分" class="headerlink" title="0x1.数据的读写部分"></a>0x1.数据的读写部分</h2><p>何时停止读写，可以根据NewLine的值进行判定。NewLine的默认值是”\n”换行符，可以根据自己的需求进行更改。”\r\n”也是比较常用的NewLine。</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 摘要:</span></span><br><span class="line"><span class="comment">//     获取或设置用于解释 System.IO.Ports.SerialPort.ReadLine 和 System.IO.Ports.SerialPort.WriteLine(System.String)</span></span><br><span class="line"><span class="comment">//     方法调用结束的值。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 返回结果:</span></span><br><span class="line"><span class="comment">//     表示行尾的值。 默认值为换行符，System.Environment.NewLine。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 异常:</span></span><br><span class="line"><span class="comment">//   T:System.ArgumentException:</span></span><br><span class="line"><span class="comment">//     属性值为空。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//   T:System.ArgumentNullException:</span></span><br><span class="line"><span class="comment">//     属性值为 null。</span></span><br><span class="line">[<span class="meta">Browsable(false)</span>]</span><br><span class="line">[<span class="meta">DefaultValue(<span class="meta-string">&quot;\n&quot;</span>)</span>]</span><br><span class="line">[<span class="meta">MonitoringDescription(<span class="meta-string">&quot;NewLine&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">string</span> NewLine &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br></pre></td></tr></table></figure><p>如果不想直接设置NewLine，也可以在读取串口数据时，根据自定义字符进行读取划分。</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 摘要:</span></span><br><span class="line"><span class="comment">//     一直读取到输入缓冲区中的指定 value 的字符串。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 参数:</span></span><br><span class="line"><span class="comment">//   value:</span></span><br><span class="line"><span class="comment">//     指示读取操作停止位置的值。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 返回结果:</span></span><br><span class="line"><span class="comment">//     输入缓冲区中直到指定 value 的内容。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 异常:</span></span><br><span class="line"><span class="comment">//   T:System.ArgumentException:</span></span><br><span class="line"><span class="comment">//     value 参数的长度为 0。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//   T:System.ArgumentNullException:</span></span><br><span class="line"><span class="comment">//     value 参数为 null。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//   T:System.InvalidOperationException:</span></span><br><span class="line"><span class="comment">//     指定的端口未打开。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//   T:System.TimeoutException:</span></span><br><span class="line"><span class="comment">//     该操作未在超时时间到期之前完成。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">ReadTo</span>(<span class="params"><span class="built_in">string</span> <span class="keyword">value</span></span>)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> reqStr = Conn.ReadTo(<span class="string">&quot;\r\n&quot;</span>);</span><br></pre></td></tr></table></figure><p>这样读取出来的数据就可以时一条条完整的指令，而不会出现被分隔的指令片段。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在使用串口协议进行自定义协议读写的时候，一般使用Ascii编码。但是串口中读取到的数据并不能保证其完整性。一条指令有可能会被拆分成多条数据发送，读取到的字符串有可能只是其中的一部分。一般一条指令的末尾都会加上\n\r作为结束符。&lt;/p&gt;</summary>
    
    
    
    <category term="Work" scheme="https://blog.eganx.cn/categories/Work/"/>
    
    <category term="C#" scheme="https://blog.eganx.cn/categories/Work/C/"/>
    
    
    <category term="C#" scheme="https://blog.eganx.cn/tags/C/"/>
    
    <category term="Serial" scheme="https://blog.eganx.cn/tags/Serial/"/>
    
  </entry>
  
  <entry>
    <title>华为OD笔试</title>
    <link href="https://blog.eganx.cn/2021/03/09/Huawei_OD_exam/"/>
    <id>https://blog.eganx.cn/2021/03/09/Huawei_OD_exam/</id>
    <published>2021-03-09T03:30:12.000Z</published>
    <updated>2022-11-20T02:40:46.138Z</updated>
    
    <content type="html"><![CDATA[<p>第一次参加华为OD的笔试，作为参加过<del>精英</del>笔试的优秀青年。我还是想记录一下的。说实话题目还行，但是裸考还是有点难度的(个人观点，或许是我菜的过分了)。</p><span id="more"></span><h2 id="0x0-第一题"><a href="#0x0-第一题" class="headerlink" title="0x0.第一题"></a>0x0.第一题</h2><p>用一个数组A，代表程序员的工作能力。公司想通过结对编程的模式来提高员工的工作能力，假设成对后的能力是两个员工的能力之和，求一共有多少种结对方式，使结对后的能力为N。</p><p><strong>提示：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 第一行代表员工个数</span><br><span class="line">2. 第二行代表各个员工的能力值</span><br><span class="line">3. 第三行代表结对后的能力值N</span><br><span class="line">4. 输出为结对的组合方式的值</span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">5</span><br><span class="line">1 2 2 2 3</span><br><span class="line">4</span><br><span class="line">输出：</span><br><span class="line">4</span><br></pre></td></tr></table></figure><h3 id="1-解题思路"><a href="#1-解题思路" class="headerlink" title="1).解题思路"></a>1).解题思路</h3><p>说实话这题放在华为OD的笔试里面，应该是属于送分题，一个输入数组加两层for循环直接解就行，直接附上代码就算了。</p><h3 id="2-代码实现"><a href="#2-代码实现" class="headerlink" title="2).代码实现"></a>2).代码实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  main.cpp</span></span><br><span class="line"><span class="comment">//  Demo</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by Egan.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,N;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">1001</span>];</span><br><span class="line">    <span class="keyword">int</span> count =<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x =<span class="number">0</span>; x &lt; n; x++ )&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> y= x+<span class="number">1</span>; y &lt;n; y++ )&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[x]+arr[y] == N)</span><br><span class="line">                count += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; count &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0x1-错误的里程表"><a href="#0x1-错误的里程表" class="headerlink" title="0x1.错误的里程表"></a>0x1.错误的里程表</h2><p>一个汽车里程表，它以整数形式显示行驶的英里数。然而，里程表有一个缺陷:它从数字3转到数字5，总是跳过数字4。这个缺陷出现在所有的位置(1,10,100，等等)。例如，如果里程表显示为15339，而汽车行驶了1英里，里程表的读数将更改为15350(而不是15340)。</p><p><strong>提示：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 输入为里程表上的数值</span><br><span class="line">2. 输出为实际车子行驶的数值</span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入1：5</span><br><span class="line">输出1：3</span><br><span class="line">输入2：17</span><br><span class="line">输出2：15</span><br><span class="line">输入3：100</span><br><span class="line">输出3：81</span><br></pre></td></tr></table></figure><h3 id="1-解题思路-1"><a href="#1-解题思路-1" class="headerlink" title="1).解题思路"></a>1).解题思路</h3><p>遇到4则直接从3进位到5，所以这是一道典型的进制转化问题，遍历该数字的每一位（如果这一位的数字比4大，就要减去1，因为这个位跳过了一个4），然后再遍历该数字的每一位，将其转化为10进制。</p><h3 id="2-代码实现-1"><a href="#2-代码实现-1" class="headerlink" title="2).代码实现"></a>2).代码实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  main.cpp</span></span><br><span class="line"><span class="comment">//  Demo</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by Egan.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        <span class="keyword">if</span>(n[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> j = n.size;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> num = <span class="number">0</span>; ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> m = j<span class="number">-1</span>; m &gt;= <span class="number">0</span>; m--) &#123;</span><br><span class="line">            <span class="keyword">if</span>((n[m]-<span class="string">&#x27;0&#x27;</span>)&gt;<span class="number">4</span>)&#123;</span><br><span class="line">                num += ((n[m]-<span class="string">&#x27;0&#x27;</span>)<span class="number">-1</span>) * ans;</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                num += (n[m]-<span class="string">&#x27;0&#x27;</span>) * ans;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = ans * <span class="number">9</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="string">&quot;:&quot;</span>&lt;&lt;num&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="0x2-贪吃蛇算法"><a href="#0x2-贪吃蛇算法" class="headerlink" title="0x2.贪吃蛇算法"></a>0x2.贪吃蛇算法</h2><p>题目太长，具体的记不清楚了，只能大致的描述一下。。。。</p><p>输入一个字符矩阵，其中字符E是食物(蛇吃了长度+1的那种)，F是空白，H是蛇的位置(初始只占一个位置)</p><p>移动指令有5种，分别让贪吃蛇移动以及转向：G前进、U往上转、D往下转、L往左转、R往右转（初始方向为左）</p><p>结束条件是碰壁或者碰到自己就算死了。 </p><p>求按输入的指令执行之后的蛇的长度。</p><p><strong>输入输出示例：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">D G G</span><br><span class="line">3</span><br><span class="line">F E F</span><br><span class="line">E E H</span><br><span class="line">F F F</span><br><span class="line">输出：</span><br><span class="line">1</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;第一次参加华为OD的笔试，作为参加过&lt;del&gt;精英&lt;/del&gt;笔试的优秀青年。我还是想记录一下的。说实话题目还行，但是裸考还是有点难度的(个人观点，或许是我菜的过分了)。&lt;/p&gt;</summary>
    
    
    
    <category term="Work" scheme="https://blog.eganx.cn/categories/Work/"/>
    
    
    <category term="C++" scheme="https://blog.eganx.cn/tags/C/"/>
    
    <category term="华为OD" scheme="https://blog.eganx.cn/tags/%E5%8D%8E%E4%B8%BAOD/"/>
    
    <category term="笔试" scheme="https://blog.eganx.cn/tags/%E7%AC%94%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>基础计算器II (Basic calculator II)</title>
    <link href="https://blog.eganx.cn/2021/03/02/Basic_calculator_II/"/>
    <id>https://blog.eganx.cn/2021/03/02/Basic_calculator_II/</id>
    <published>2021-03-02T02:22:11.000Z</published>
    <updated>2022-11-20T02:41:25.456Z</updated>
    
    <content type="html"><![CDATA[<p>栈的经典应用：</p><p>给一个字符串表达式 <code>s</code> ，实现一个基本计算器来计算并返回它的值。(整数除法仅保留整数部分)</p><span id="more"></span><p><strong>提示：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 1 &lt;&#x3D; s.length &lt;&#x3D; 3 * 10^5</span><br><span class="line">2. s 由整数和算符(&#39;+&#39;, &#39;-&#39;, &#39;*&#39;, &#39;&#x2F;&#39;)组成,中间由一些空格隔开</span><br><span class="line">3. s 表示一个有效表达式</span><br><span class="line">4. 表达式中的所有整数都是非负整数,且在范围[0, 231 - 1]内</span><br><span class="line">5. 题目数据保证答案是一个32-bit整数</span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;3+2*2&quot;</span><br><span class="line">输出：7</span><br></pre></td></tr></table></figure><h2 id="0x0-解题思路"><a href="#0x0-解题思路" class="headerlink" title="0x0.解题思路"></a>0x0.解题思路</h2><p>栈的经典应用，此题没有括号，不需要进行括号匹配，相对来说简单一点，可以直接进行暴力求解。</p><ol><li><p>需要考虑运算符的优先级问题。乘除的优先级大于加减，可以先进行乘除运算，用一个栈，保存进行乘除运算后的整数的值。对于加减号后的数字，将其直接压入栈中；对于乘除号后的数字，直接与栈顶元素计算，并替换栈顶元素为计算后的结果。</p></li><li><p>遍历字符串 s，并用变量preSign记录每个数字之前的运算符，对于第一个数字，其之前的运算符视为加号。遍历到运算符或者字符串最后一位时，根据preSign来决定计算方式:</p><ul><li><p>加号：数字直接入栈；</p></li><li><p>减号：num变(-num)入栈；</p></li><li><p>乘除：num ( * or / ) stack.back()，并将栈顶元素替换为运算结果。</p></li></ul></li></ol><h2 id="0x1-复杂度分析"><a href="#0x1-复杂度分析" class="headerlink" title="0x1.复杂度分析"></a>0x1.复杂度分析</h2><ul><li><p>时间复杂度：O(n)，其中n为字符串s的长度。需要遍历字符串s一次，计算表达式的值。</p></li><li><p>空间复杂度：O(n)，其中n为字符串s的长度。空间复杂度主要取决于栈的空间，栈的元素个数不超过n。</p></li></ul><p>需要注意的是</p><ul><li>在运算的时候，判断字符是数字还是运算符的时候，需要使用<code>isdigit()</code>函数，此函数包含在头文件<code>#include &lt;cctype&gt;</code>中。</li><li>运算的时候，如果遇到的数是大数(两位数及以上的)，需要进行处理。大数在字符串中是两个字符，需要在遍历字符串时，使用<code>num = num * 10 + int (s[i] - &#39;0&#39;);</code>对大数进行处理。</li><li>在乘除运算的结果都模拟入栈之后，使用累加函数<code>accumulate(st.begin(), st.end(), 0);</code>对数组进行累加处理，<code>accumulate()</code>函数包含在头文件<code>#include &lt;numeric&gt;</code>中，累加过程中，正负数都可以处理。</li></ul><h2 id="0x2-代码实现"><a href="#0x2-代码实现" class="headerlink" title="0x2.代码实现"></a>0x2.代码实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  main.cpp</span></span><br><span class="line"><span class="comment">//  Demo</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by Egan.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calculate</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; st; <span class="comment">//digits</span></span><br><span class="line">        <span class="keyword">char</span> ps = <span class="string">&#x27;+&#x27;</span>; <span class="comment">//presign</span></span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isdigit</span>(s[i]))&#123; <span class="comment">//#include &lt;cctype&gt;</span></span><br><span class="line">                num = num * <span class="number">10</span> + <span class="keyword">int</span> (s[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">isdigit</span>(s[i]) &amp;&amp; s[i] != <span class="string">&#x27; &#x27;</span> || i == s.length()<span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="keyword">switch</span>(ps)&#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span> :</span><br><span class="line">                        st.push_back(num);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span> :</span><br><span class="line">                        st.push_back(-num);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span> :</span><br><span class="line">                        st.back() *= num;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span> :</span><br><span class="line">                        st.back() /= num;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ps = s[i];</span><br><span class="line">                num = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> accumulate(st.begin(), st.end(), <span class="number">0</span>); <span class="comment">//#include&lt;numeric&gt;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;栈的经典应用：&lt;/p&gt;
&lt;p&gt;给一个字符串表达式 &lt;code&gt;s&lt;/code&gt; ，实现一个基本计算器来计算并返回它的值。(整数除法仅保留整数部分)&lt;/p&gt;</summary>
    
    
    
    <category term="Leetcode" scheme="https://blog.eganx.cn/categories/Leetcode/"/>
    
    
    <category term="C++" scheme="https://blog.eganx.cn/tags/C/"/>
    
    <category term="栈" scheme="https://blog.eganx.cn/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>逆波兰表示法(Reverse Polish notation)</title>
    <link href="https://blog.eganx.cn/2021/03/01/Reverse%20Polish%20notation/"/>
    <id>https://blog.eganx.cn/2021/03/01/Reverse%20Polish%20notation/</id>
    <published>2021-03-01T08:12:14.000Z</published>
    <updated>2022-11-20T02:41:34.945Z</updated>
    
    <content type="html"><![CDATA[<p>根据逆波兰表示法，求表达式的值。</p><p>有效的运算符包括 <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code> 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。</p><span id="more"></span><h2 id="0x0-解题思路"><a href="#0x0-解题思路" class="headerlink" title="0x0.解题思路"></a>0x0.解题思路</h2><p>逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。</p><p>逆波兰表达式主要有以下两个优点：</p><ul><li><p>去掉括号后表达式无歧义，<code>( 1 + 2 ) * ( 3 + 4 )</code>即便写成 <code>1 2 + 3 4 + * </code>也可以依据次序计算出正确结果。</p></li><li><p>适合用栈操作运算</p></li></ul><p>逆波兰表达式的求解是栈的经典应用。所以此题采用栈来解决，遇到数字则入栈，遇到运算符则取出<strong>栈顶两个数字</strong>进行运算，<strong>并将结果压入栈中</strong>。</p><p>需要注意的是</p><ul><li><p>在运算的时候，需要后取出的数字在前，先取出的数字在后，即num2在前。</p></li><li><p><code>stoi</code>表示<code>string to int</code>，即字符串转整数</p></li></ul><h2 id="0x1-代码实现"><a href="#0x1-代码实现" class="headerlink" title="0x1.代码实现"></a>0x1.代码实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  main.cpp</span></span><br><span class="line"><span class="comment">//  Demo</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by Egan.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">evalRPN</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; tokens)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;tokens.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(tokens[i] == <span class="string">&quot;+&quot;</span>||tokens[i] == <span class="string">&quot;-&quot;</span>||tokens[i] == <span class="string">&quot;*&quot;</span>||tokens[i] == <span class="string">&quot;/&quot;</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> num1 = s.top();</span><br><span class="line">                s.pop();</span><br><span class="line">                <span class="keyword">int</span> num2 = s.top();</span><br><span class="line">                s.pop();</span><br><span class="line">                <span class="keyword">if</span>(tokens[i] == <span class="string">&quot;+&quot;</span>) s.push(num2 + num1);</span><br><span class="line">                <span class="keyword">if</span>(tokens[i] == <span class="string">&quot;-&quot;</span>) s.push(num2 - num1);</span><br><span class="line">                <span class="keyword">if</span>(tokens[i] == <span class="string">&quot;*&quot;</span>) s.push(num2 * num1);</span><br><span class="line">                <span class="keyword">if</span>(tokens[i] == <span class="string">&quot;/&quot;</span>) s.push(num2 / num1);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                s.push(stoi(tokens[i]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> result = s.top();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;根据逆波兰表示法，求表达式的值。&lt;/p&gt;
&lt;p&gt;有效的运算符包括 &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt; 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。&lt;/p&gt;</summary>
    
    
    
    <category term="Leetcode" scheme="https://blog.eganx.cn/categories/Leetcode/"/>
    
    
    <category term="C++" scheme="https://blog.eganx.cn/tags/C/"/>
    
    <category term="栈" scheme="https://blog.eganx.cn/tags/%E6%A0%88/"/>
    
  </entry>
  
</feed>
