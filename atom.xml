<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Egan&#39;s Blog</title>
  
  <subtitle>一个人的小破站</subtitle>
  <link href="https://eganblog.com/atom.xml" rel="self"/>
  
  <link href="https://eganblog.com/"/>
  <updated>2022-02-10T13:36:57.959Z</updated>
  <id>https://eganblog.com/</id>
  
  <author>
    <name>Egan Dong</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C# GC机制</title>
    <link href="https://eganblog.com/2022/02/08/CSharp%20GC%E6%9C%BA%E5%88%B6/"/>
    <id>https://eganblog.com/2022/02/08/CSharp%20GC%E6%9C%BA%E5%88%B6/</id>
    <published>2022-02-08T13:31:19.000Z</published>
    <updated>2022-02-10T13:36:57.959Z</updated>
    
    <content type="html"><![CDATA[<h3 id="C-GC机制-Garbage-Collector"><a href="#C-GC机制-Garbage-Collector" class="headerlink" title="C# GC机制(Garbage Collector)"></a>C# GC机制(Garbage Collector)</h3><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>记录一下C#中GC的相关知识。不记下来，下次又找不到，就很烦。</p><h4 id="1、资源概念"><a href="#1、资源概念" class="headerlink" title="1、资源概念"></a>1、资源概念</h4><p>所谓的资源其实就是程序中可以利用的数据。比如字符串、图片和任何的二进制数据。</p><p>托管资源，非托管资源：托管资源是由CLR全权负责的资源，CLR不负责的资源位非托管资源。<br><strong>对于托管资源通过GC自动清理回收。对于非托管的资源，一般就是Stream，数据库的连接，网络连接，GDI+的相关对象，还有Com对象等等这些操作系统资源，需要我们手动去释放，再由GC回收。</strong>  </p><h4 id="2、Garbage的判定"><a href="#2、Garbage的判定" class="headerlink" title="2、Garbage的判定"></a>2、Garbage的判定</h4><p>.Net类型分为两大类，<strong>一个就是值类型，另一个就是引用类型。前者是在堆栈中分配内存，它们有自身的生命周期，所以不用对它们进行管理，会自动分配和释放。后者是在堆中分配内存的。所以它的分配和释放就需要像回收机制来管理。</strong></p><p>GC的全称为“Garbage Collector”,顾名思义就是垃圾回收器，那么只有被称为垃圾的对象才能被GC回收。也就是说， 一个引用类型对象所占用的内存需要被GC回收，需要先成为垃圾。 <strong>.Net判定一个引用类型对象是垃圾，只需要判定此对象或者其包含的子对象没有任何引用是有效的，那么系统就认为它是垃圾。</strong></p><h4 id="3、非托管资源的释放方式"><a href="#3、非托管资源的释放方式" class="headerlink" title="3、非托管资源的释放方式"></a>3、非托管资源的释放方式</h4><h5 id="3-1-Close"><a href="#3-1-Close" class="headerlink" title="3.1 Close()"></a>3.1 Close()</h5><p>关闭对象资源，在显示调用时被调用。</p><h5 id="3-2-Dispose"><a href="#3-2-Dispose" class="headerlink" title="3.2 Dispose()"></a>3.2 Dispose()</h5><p>继承IDisposable接口，实现Dispose方法；<br>介绍：调用Dispose方法，销毁对象，需要显示调用或者通过using语句，在显示调用或者离开using程序块时被调用。<br>Dispose方法用于清理对象封装的非托管资源，而不是释放对象的内存，对象的内存依然由垃圾回收器控制。<br>Dispose方法调用，不但释放该类的非托管资源，还释放了引用的类的非托管资源。<br>Dispose模式就是一种强制资源清理所要遵守的约定；Dispose模式实现IDisposable接口，从而使得该类型提供一个公有的Dispose方法。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">而Close与Dispose这两种方法的区别在于，调用完了对象的Close方法后，此对象有可能被重新进</span><br><span class="line">行使用；而Dispose方法来说，此对象所占有的资源需要被标记为无用了，也就是此对象被销毁了，</span><br><span class="line">不能再被使用。</span><br></pre></td></tr></table></figure><h5 id="3-3-析构函数-Finalize"><a href="#3-3-析构函数-Finalize" class="headerlink" title="3.3 析构函数/Finalize()"></a>3.3 析构函数/Finalize()</h5><p>带有析构函数的类，生命周期会变长。内存空间需要两次垃圾回收才会被释放，导致性能下降。</p><p>一个正常情况的类是不会写析构函数的，而一旦一个类写了析构函数，就意味着GC会在不确定的时间调用该类的析构函数，判断该类的资源是否需要释放，然后调用Finalize方法，如果重写了Finalize方法则调用重写的Finalize方法。<br>Finalize方法的作用是保证.NET对象能在垃圾回收时清除非托管资源。<br>在.NET中，Object.Finalize()方法是无法重载的，编译器是根据类的析构函数来自动生成Object.Finalize()方法的<br>Finalize由垃圾回收器调用；dispose由对象调用。<br>Finalize无需担心因为没有调用Finalize而使非托管资源得不到释放，因为GC会在不确定时间调用，当然，你也可以手动调用Finalize方法，而dispose必须手动调用。<br>Finalize虽然无需担心因为没有调用Finalize而使非托管资源得不到释放，但因为由垃圾回收器管理，不能保证立即释放非托管资源；而dispose一调用便释放非托管资源。<br>只有类类型才能重写Finalize，而结构不能；类和结构都能实现IDispose</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">释放模式：是一种微软建议的写法，先手动显示去释放资源，如果忘记了，再让finalize释放资源。</span><br><span class="line">所以如果已经完成了析构函数该干的事情(例如释放非托管资源)，就应当使用SuppressFinalize</span><br><span class="line">方法告诉GC不需要再执行某个对象的析构函数。</span><br></pre></td></tr></table></figure><h4 id="4、GC的运作方式"><a href="#4、GC的运作方式" class="headerlink" title="4、GC的运作方式"></a>4、GC的运作方式</h4><p>内存的释放和回收需要伴随着程序的运行，因此系统为GC安排了独立的线程。那么GC的工作大致是，查询内存中对象是否成为垃圾，然后对垃圾进行释放和回收。那么对于GC对于内存回收采取了一定的优先算法进行轮循回收内存资源。</p><p>其次，<strong>对于内存中的垃圾分为两种，一种是需要调用对象的析构函数，另一种是不需要调用的。GC对于前者的回收需要通过两步完成，第一步是调用对象的析构函数，第二步是回收内存，但是要注意这两步不是在GC一次轮循完成，即需要两次轮循；相对于后者，则只是回收内存而已。</strong></p><p>C#中的GC使用了Generation的概念，它将分配的对象分为3代(可用GC.GetGeneration方法返回任意作为参数的对象当前所处的代)。</p><p>最近被分配内存的对象被放置于第0代，因为第0代很小，小到足以放进处理器的二级（L2)缓存，所以它能够提供对对象的快速存取。经过一轮垃圾回收后，仍然保留在第0代中的对象被移进第1代中，再经过一轮垃圾内存回收后，仍然保留在第1代中的对象则被移进第2代中，第2代中包含了生存期较长的对象。 当第0代中没有可以分配的有效内存时，就触发了第0代中的一轮垃圾回收，它将删除那些不再被引用的对象，并将当前正在使用的对象移至第1代。而当第0代垃圾回收后依然不能请求到充足的内存时，就启动第1代垃圾回收。如果对各代都进行了垃圾回收后仍没有可用的内存就会引发一个OutOfMemoryException异常。</p><table><thead><tr><th align="center"></th><th align="center">Close</th><th align="center">Dispose</th><th align="center">析构函数</th></tr></thead><tbody><tr><td align="center"></td><td align="center">关闭对象资源</td><td align="center">销毁对象</td><td align="center">销毁对象</td></tr><tr><td align="center">调用方式</td><td align="center">需要显示调用</td><td align="center">需要显示调用或者通过using语句</td><td align="center">不能被显示调用，会被GC调用</td></tr><tr><td align="center">调用时机</td><td align="center">在显示调用时</td><td align="center">在显示调用或者离开using程序块</td><td align="center">不确定</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;C-GC机制-Garbage-Collector&quot;&gt;&lt;a href=&quot;#C-GC机制-Garbage-Collector&quot; class=&quot;headerlink&quot; title=&quot;C# GC机制(Garbage Collector)&quot;&gt;&lt;/a&gt;C# GC机制(Garb</summary>
      
    
    
    
    <category term="工作" scheme="https://eganblog.com/categories/%E5%B7%A5%E4%BD%9C/"/>
    
    
    <category term="C#" scheme="https://eganblog.com/tags/C/"/>
    
    <category term="GC" scheme="https://eganblog.com/tags/GC/"/>
    
  </entry>
  
  <entry>
    <title>Go版本切换</title>
    <link href="https://eganblog.com/2022/01/05/Go%E7%89%88%E6%9C%AC%E5%88%87%E6%8D%A2/"/>
    <id>https://eganblog.com/2022/01/05/Go%E7%89%88%E6%9C%AC%E5%88%87%E6%8D%A2/</id>
    <published>2022-01-05T13:06:11.000Z</published>
    <updated>2022-01-21T09:25:38.625Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Go版本切换"><a href="#Go版本切换" class="headerlink" title="Go版本切换"></a>Go版本切换</h2><h3 id="手动管理-目前使用的切换方式"><a href="#手动管理-目前使用的切换方式" class="headerlink" title="手动管理(目前使用的切换方式)"></a>手动管理(目前使用的切换方式)</h3><p>官网下载最新版Archive文件go1.18beta1.darwin-amd64.tar.gz</p><p>解压缩重命名go1.18.beta1,拷贝一份放到默认安装路径<code>/usr/local/go1.18beta1</code></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo cp -R /User/egan/Sdks/go1.18beta1 /usr/local/go1.18beta1</span><br></pre></td></tr></table></figure><p>进入默认安装路径，创建软链</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /usr/local/</span><br><span class="line">sudo ln -s go1.18beta1 go</span><br></pre></td></tr></table></figure><h3 id="版本切换工具"><a href="#版本切换工具" class="headerlink" title="版本切换工具"></a>版本切换工具</h3><h4 id="1、g"><a href="#1、g" class="headerlink" title="1、g"></a>1、g</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GitHub:https:&#x2F;&#x2F;github.com&#x2F;voidint&#x2F;g</span><br></pre></td></tr></table></figure><h4 id="2、goup"><a href="#2、goup" class="headerlink" title="2、goup"></a>2、goup</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Github:https:&#x2F;&#x2F;github.com&#x2F;owenthereal&#x2F;goup</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Go版本切换&quot;&gt;&lt;a href=&quot;#Go版本切换&quot; class=&quot;headerlink&quot; title=&quot;Go版本切换&quot;&gt;&lt;/a&gt;Go版本切换&lt;/h2&gt;&lt;h3 id=&quot;手动管理-目前使用的切换方式&quot;&gt;&lt;a href=&quot;#手动管理-目前使用的切换方式&quot; class=&quot;</summary>
      
    
    
    
    <category term="工作" scheme="https://eganblog.com/categories/%E5%B7%A5%E4%BD%9C/"/>
    
    
    <category term="go" scheme="https://eganblog.com/tags/go/"/>
    
    <category term="版本切换" scheme="https://eganblog.com/tags/%E7%89%88%E6%9C%AC%E5%88%87%E6%8D%A2/"/>
    
  </entry>
  
  <entry>
    <title>C#内存泄露</title>
    <link href="https://eganblog.com/2022/01/03/CSharp%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA/"/>
    <id>https://eganblog.com/2022/01/03/CSharp%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA/</id>
    <published>2022-01-03T04:31:19.000Z</published>
    <updated>2022-01-21T09:25:11.138Z</updated>
    
    <content type="html"><![CDATA[<h2 id="记录一次内存泄露的发生"><a href="#记录一次内存泄露的发生" class="headerlink" title="记录一次内存泄露的发生"></a>记录一次内存泄露的发生</h2><h3 id="问题产生原因"><a href="#问题产生原因" class="headerlink" title="问题产生原因"></a>问题产生原因</h3><p>在<code>button1.Click += Button1_Click</code>中，(+=) 来为事件附加事件处理程序</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Form1</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    InitializeComponent();</span><br><span class="line">    button1.Click += Button1_Click;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Button1_Click</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line"><span class="function"></span> &#123;</span><br><span class="line">     System.Diagnostics.Debug.Print(<span class="string">&quot;x&quot;</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">event</span> EventHandler Click;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">EventHandler</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span>;</span><br></pre></td></tr></table></figure><p>给button1_Click的附加事件处理程序放在了心跳里面；</p><p>此次溢出是因为每次心跳，又进行了一次事件处理程序的附加，造成不断附件事件处理程序。</p><p>直至最后，点击一次，要运行2K+次的事件处理程序。</p><p>而事件处理程序的代码里面会使用创建新的线程，运行一次，创建大量的新线程，线程数直接飙升，内存崩掉。</p><h3 id="定位内存泄露发生的地方："><a href="#定位内存泄露发生的地方：" class="headerlink" title="定位内存泄露发生的地方："></a>定位内存泄露发生的地方：</h3><p>C#的代码可以使用内存分析工具dotMemory。dotMemory允许你分析各种.NET和.NET Core应用程序的内存使用情况；比如桌面应用程序、Windows服务、ASP.NET Web应用程序、IIS、IIS Express、任意.NET进程等。不过临时用一下可以，有30天的试用期，还是比较好用的。</p><p>溢出版本源码示例:</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">WindowsFormsApp1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">Form1</span> : <span class="title">Form</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Form1</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            InitializeComponent();</span><br><span class="line">            button1.Click += Button1_Click;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Cycle</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            button1.Click += Button1_Click;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Button1_Click</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            i += <span class="number">1</span>;</span><br><span class="line">            System.Diagnostics.Debug.Print(<span class="string">&quot;x:&#123;0&#125;&quot;</span>,i);</span><br><span class="line">            Cycle();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正常版本源码示例：</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">WindowsFormsApp1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">Form1</span> : <span class="title">Form</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Form1</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            InitializeComponent();</span><br><span class="line">            button1.Click += Button1_Click;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Button1_Click</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            i += <span class="number">1</span>;</span><br><span class="line">            System.Diagnostics.Debug.Print(<span class="string">&quot;x:&#123;0&#125;&quot;</span>,i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;记录一次内存泄露的发生&quot;&gt;&lt;a href=&quot;#记录一次内存泄露的发生&quot; class=&quot;headerlink&quot; title=&quot;记录一次内存泄露的发生&quot;&gt;&lt;/a&gt;记录一次内存泄露的发生&lt;/h2&gt;&lt;h3 id=&quot;问题产生原因&quot;&gt;&lt;a href=&quot;#问题产生原因&quot; cla</summary>
      
    
    
    
    <category term="工作" scheme="https://eganblog.com/categories/%E5%B7%A5%E4%BD%9C/"/>
    
    
    <category term="C#" scheme="https://eganblog.com/tags/C/"/>
    
    <category term="OOM" scheme="https://eganblog.com/tags/OOM/"/>
    
  </entry>
  
  <entry>
    <title>C#串口读写连续性问题</title>
    <link href="https://eganblog.com/2022/01/01/CSharp%E4%B8%B2%E5%8F%A3%E8%AF%BB%E5%86%99%E8%BF%9E%E7%BB%AD%E6%80%A7%E9%97%AE%E9%A2%98/"/>
    <id>https://eganblog.com/2022/01/01/CSharp%E4%B8%B2%E5%8F%A3%E8%AF%BB%E5%86%99%E8%BF%9E%E7%BB%AD%E6%80%A7%E9%97%AE%E9%A2%98/</id>
    <published>2022-01-01T03:31:19.000Z</published>
    <updated>2022-01-21T09:25:09.421Z</updated>
    
    <content type="html"><![CDATA[<h2 id="C-串口读写连续性问题"><a href="#C-串口读写连续性问题" class="headerlink" title="C#串口读写连续性问题"></a>C#串口读写连续性问题</h2><p>在使用串口协议进行自定义协议读写的时候，一般使用Ascii编码。但是串口中读取到的数据并不能保证其完整性。一条指令有可能会被拆分成多条数据发送，读取到的字符串有可能只是其中的一部分。一般一条指令的末尾都会加上\n\r作为结束符。</p><h3 id="创建连接"><a href="#创建连接" class="headerlink" title="创建连接"></a>创建连接</h3><p>串口使用System.IO.Ports.SerialPort来创建连接</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 摘要:</span></span><br><span class="line"><span class="comment">//     使用指定的端口名、波特率、奇偶校验位、数据位和停止位初始化 System.IO.Ports.SerialPort 类的新实例。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 参数:</span></span><br><span class="line"><span class="comment">//   portName:</span></span><br><span class="line"><span class="comment">//     要使用的端口（例如 COM1）。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//   baudRate:</span></span><br><span class="line"><span class="comment">//     波特率。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//   parity:</span></span><br><span class="line"><span class="comment">//     System.IO.Ports.SerialPort.Parity 值之一。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//   dataBits:</span></span><br><span class="line"><span class="comment">//     数据位值。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//   stopBits:</span></span><br><span class="line"><span class="comment">//     System.IO.Ports.SerialPort.StopBits 值之一。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 异常:</span></span><br><span class="line"><span class="comment">//   T:System.IO.IOException:</span></span><br><span class="line"><span class="comment">//     未能找到或打开指定的端口。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SerialPort</span>(<span class="params"><span class="built_in">string</span> portName, <span class="built_in">int</span> baudRate, Parity parity, <span class="built_in">int</span> dataBits, StopBits stopBits</span>)</span>;</span><br></pre></td></tr></table></figure><p>其中Parity和StopBits的枚举分别为：</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 摘要:</span></span><br><span class="line"><span class="comment">// 指定 System.IO.Ports.SerialPort 对象的奇偶校验位。</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> Parity</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 摘要:</span></span><br><span class="line">    <span class="comment">// 不发生奇偶校验检查。</span></span><br><span class="line">    None = <span class="number">0</span>,</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 摘要:</span></span><br><span class="line">    <span class="comment">// 设置奇偶校验位，使位数等于奇数。</span></span><br><span class="line">    Odd = <span class="number">1</span>,</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 摘要:</span></span><br><span class="line">    <span class="comment">// 设置奇偶校验位，使位数等于偶数。</span></span><br><span class="line">    Even = <span class="number">2</span>,</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 摘要:</span></span><br><span class="line">    <span class="comment">// 将奇偶校验位保留为 1。</span></span><br><span class="line">    Mark = <span class="number">3</span>,</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 摘要:</span></span><br><span class="line">    <span class="comment">// 将奇偶校验位保留为 0。</span></span><br><span class="line">    Space = <span class="number">4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 摘要:</span></span><br><span class="line"><span class="comment">// 指定在 System.IO.Ports.SerialPort 对象上使用的停止位的数目。</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> StopBits</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 摘要:</span></span><br><span class="line">    <span class="comment">// 不使用停止位。 System.IO.Ports.SerialPort.StopBits 属性不支持此值。</span></span><br><span class="line">    None = <span class="number">0</span>,</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 摘要:</span></span><br><span class="line">    <span class="comment">// 使用一个停止位。</span></span><br><span class="line">    One = <span class="number">1</span>,</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 摘要:</span></span><br><span class="line">    <span class="comment">// 使用两个停止位。</span></span><br><span class="line">    Two = <span class="number">2</span>,</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 摘要:</span></span><br><span class="line">    <span class="comment">// 使用 1.5 个停止位。</span></span><br><span class="line">    OnePointFive = <span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>连接完成后需要保证端口的开启，可使用IsOpen参数进行判定。</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!Conn.IsOpen)</span><br><span class="line">&#123;</span><br><span class="line">    Conn.Open();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数据的读写部分"><a href="#数据的读写部分" class="headerlink" title="数据的读写部分"></a>数据的读写部分</h3><p>何时停止读写，可以根据NewLine的值进行判定。NewLine的默认值是”\n”换行符，可以根据自己的需求进行更改。”\r\n”也是比较常用的NewLine。</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 摘要:</span></span><br><span class="line"><span class="comment">//     获取或设置用于解释 System.IO.Ports.SerialPort.ReadLine 和 System.IO.Ports.SerialPort.WriteLine(System.String)</span></span><br><span class="line"><span class="comment">//     方法调用结束的值。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 返回结果:</span></span><br><span class="line"><span class="comment">//     表示行尾的值。 默认值为换行符，System.Environment.NewLine。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 异常:</span></span><br><span class="line"><span class="comment">//   T:System.ArgumentException:</span></span><br><span class="line"><span class="comment">//     属性值为空。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//   T:System.ArgumentNullException:</span></span><br><span class="line"><span class="comment">//     属性值为 null。</span></span><br><span class="line">[<span class="meta">Browsable(false)</span>]</span><br><span class="line">[<span class="meta">DefaultValue(<span class="meta-string">&quot;\n&quot;</span>)</span>]</span><br><span class="line">[<span class="meta">MonitoringDescription(<span class="meta-string">&quot;NewLine&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">string</span> NewLine &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br></pre></td></tr></table></figure><p>如果不想直接设置NewLine，也可以在读取串口数据时，根据自定义字符进行读取划分。</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 摘要:</span></span><br><span class="line"><span class="comment">//     一直读取到输入缓冲区中的指定 value 的字符串。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 参数:</span></span><br><span class="line"><span class="comment">//   value:</span></span><br><span class="line"><span class="comment">//     指示读取操作停止位置的值。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 返回结果:</span></span><br><span class="line"><span class="comment">//     输入缓冲区中直到指定 value 的内容。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 异常:</span></span><br><span class="line"><span class="comment">//   T:System.ArgumentException:</span></span><br><span class="line"><span class="comment">//     value 参数的长度为 0。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//   T:System.ArgumentNullException:</span></span><br><span class="line"><span class="comment">//     value 参数为 null。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//   T:System.InvalidOperationException:</span></span><br><span class="line"><span class="comment">//     指定的端口未打开。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//   T:System.TimeoutException:</span></span><br><span class="line"><span class="comment">//     该操作未在超时时间到期之前完成。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">ReadTo</span>(<span class="params"><span class="built_in">string</span> <span class="keyword">value</span></span>)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> reqStr = Conn.ReadTo(<span class="string">&quot;\r\n&quot;</span>);</span><br></pre></td></tr></table></figure><p>这样读取出来的数据就可以时一条条完整的指令，而不会出现被分隔的指令片段。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;C-串口读写连续性问题&quot;&gt;&lt;a href=&quot;#C-串口读写连续性问题&quot; class=&quot;headerlink&quot; title=&quot;C#串口读写连续性问题&quot;&gt;&lt;/a&gt;C#串口读写连续性问题&lt;/h2&gt;&lt;p&gt;在使用串口协议进行自定义协议读写的时候，一般使用Ascii编码。但是</summary>
      
    
    
    
    <category term="工作" scheme="https://eganblog.com/categories/%E5%B7%A5%E4%BD%9C/"/>
    
    
    <category term="C#" scheme="https://eganblog.com/tags/C/"/>
    
    <category term="Serial" scheme="https://eganblog.com/tags/Serial/"/>
    
  </entry>
  
  <entry>
    <title>华为OD笔试</title>
    <link href="https://eganblog.com/2021/03/09/%E5%8D%8E%E4%B8%BAOD%E7%AC%94%E8%AF%95/"/>
    <id>https://eganblog.com/2021/03/09/%E5%8D%8E%E4%B8%BAOD%E7%AC%94%E8%AF%95/</id>
    <published>2021-03-09T03:30:12.000Z</published>
    <updated>2022-01-20T11:36:38.632Z</updated>
    
    <content type="html"><![CDATA[<h2 id="华为OD岗机试"><a href="#华为OD岗机试" class="headerlink" title="华为OD岗机试"></a>华为OD岗机试</h2><h3 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h3><p>用一个数组A，代表程序员的工作能力。公司想通过结对编程的模式来提高员工的工作能力，假设成对后的能力是两个员工的能力之和，求一共有多少种结对方式，使结对后的能力为N。</p><p><strong>提示：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 第一行代表员工个数</span><br><span class="line">2. 第二行代表各个员工的能力值</span><br><span class="line">3. 第三行代表结对后的能力值N</span><br><span class="line">4. 输出为结对的组合方式的值</span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">5</span><br><span class="line">1 2 2 2 3</span><br><span class="line">4</span><br><span class="line">输出：</span><br><span class="line">4</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>说实话这题放在华为OD的笔试里面，应该是属于送分题，一个输入数组加两层for循环直接解就行，直接附上代码就算了。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  main.cpp</span></span><br><span class="line"><span class="comment">//  Demo</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by Egan.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,N;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">1001</span>];</span><br><span class="line">    <span class="keyword">int</span> count =<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x =<span class="number">0</span>; x &lt; n; x++ )&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> y= x+<span class="number">1</span>; y &lt;n; y++ )&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[x]+arr[y] == N)</span><br><span class="line">                count += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; count &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第二题-错误的里程表"><a href="#第二题-错误的里程表" class="headerlink" title="第二题 错误的里程表"></a>第二题 错误的里程表</h3><p>一个汽车里程表，它以整数形式显示行驶的英里数。然而，里程表有一个缺陷:它从数字3转到数字5，总是跳过数字4。这个缺陷出现在所有的位置(1,10,100，等等)。例如，如果里程表显示为15339，而汽车行驶了1英里，里程表的读数将更改为15350(而不是15340)。</p><p><strong>提示：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 输入为里程表上的数值</span><br><span class="line">2. 输出为实际车子行驶的数值</span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入1：5</span><br><span class="line">输出1：3</span><br><span class="line">输入2：17</span><br><span class="line">输出2：15</span><br><span class="line">输入3：100</span><br><span class="line">输出3：81</span><br></pre></td></tr></table></figure><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>遇到4则直接从3进位到5，所以这是一道典型的进制转化问题，遍历该数字的每一位（如果这一位的数字比4大，就要减去1，因为这个位跳过了一个4），然后再遍历该数字的每一位，将其转化为10进制。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  main.cpp</span></span><br><span class="line"><span class="comment">//  Demo</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by Egan.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        <span class="keyword">if</span>(n[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> j = n.size;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> num = <span class="number">0</span>; ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> m = j<span class="number">-1</span>; m &gt;= <span class="number">0</span>; m--) &#123;</span><br><span class="line">            <span class="keyword">if</span>((n[m]-<span class="string">&#x27;0&#x27;</span>)&gt;<span class="number">4</span>)&#123;</span><br><span class="line">                num += ((n[m]-<span class="string">&#x27;0&#x27;</span>)<span class="number">-1</span>) * ans;</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                num += (n[m]-<span class="string">&#x27;0&#x27;</span>) * ans;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = ans * <span class="number">9</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="string">&quot;:&quot;</span>&lt;&lt;num&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="第三题-贪吃蛇算法"><a href="#第三题-贪吃蛇算法" class="headerlink" title="第三题 贪吃蛇算法"></a>第三题 贪吃蛇算法</h3><p>题目太长，具体的记不清楚了，只能大致的描述一下。。。。</p><p>输入一个字符矩阵，其中字符E是食物(蛇吃了长度+1的那种)，F是空白，H是蛇的位置(初始只占一个位置)</p><p>移动指令有5种，分别让贪吃蛇移动以及转向：G前进、U往上转、D往下转、L往左转、R往右转（初始方向为左）</p><p>结束条件是碰壁或者碰到自己就算死了。 </p><p>求按输入的指令执行之后的蛇的长度。</p><p><strong>输入输出示例：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">D G G</span><br><span class="line">3</span><br><span class="line">F E F</span><br><span class="line">E E H</span><br><span class="line">F F F</span><br><span class="line">输出：</span><br><span class="line">1</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;华为OD岗机试&quot;&gt;&lt;a href=&quot;#华为OD岗机试&quot; class=&quot;headerlink&quot; title=&quot;华为OD岗机试&quot;&gt;&lt;/a&gt;华为OD岗机试&lt;/h2&gt;&lt;h3 id=&quot;第一题&quot;&gt;&lt;a href=&quot;#第一题&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    <category term="日常" scheme="https://eganblog.com/categories/%E6%97%A5%E5%B8%B8/"/>
    
    <category term="工作" scheme="https://eganblog.com/categories/%E6%97%A5%E5%B8%B8/%E5%B7%A5%E4%BD%9C/"/>
    
    
    <category term="C++" scheme="https://eganblog.com/tags/C/"/>
    
    <category term="华为OD" scheme="https://eganblog.com/tags/%E5%8D%8E%E4%B8%BAOD/"/>
    
    <category term="笔试" scheme="https://eganblog.com/tags/%E7%AC%94%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>基础计算器II (Basic calculator II)</title>
    <link href="https://eganblog.com/2021/03/02/Basic%20calculator%20II/"/>
    <id>https://eganblog.com/2021/03/02/Basic%20calculator%20II/</id>
    <published>2021-03-02T02:22:11.000Z</published>
    <updated>2022-01-20T11:36:46.499Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基础计算器II-Basic-calculator-II"><a href="#基础计算器II-Basic-calculator-II" class="headerlink" title="基础计算器II (Basic calculator II)"></a>基础计算器II (Basic calculator II)</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给一个字符串表达式 <code>s</code> ，实现一个基本计算器来计算并返回它的值。(整数除法仅保留整数部分)</p><p><strong>提示：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 1 &lt;&#x3D; s.length &lt;&#x3D; 3 * 10^5</span><br><span class="line">2. s 由整数和算符(&#39;+&#39;, &#39;-&#39;, &#39;*&#39;, &#39;&#x2F;&#39;)组成,中间由一些空格隔开</span><br><span class="line">3. s 表示一个有效表达式</span><br><span class="line">4. 表达式中的所有整数都是非负整数,且在范围[0, 231 - 1]内</span><br><span class="line">5. 题目数据保证答案是一个32-bit整数</span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;3+2*2&quot;</span><br><span class="line">输出：7</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>栈的经典应用，此题没有括号，不需要进行括号匹配，相对来说简单一点，可以直接进行暴力求解。</p><ol><li><p>需要考虑运算符的优先级问题。乘除的优先级大于加减，可以先进行乘除运算，用一个栈，保存进行乘除运算后的整数的值。对于加减号后的数字，将其直接压入栈中；对于乘除号后的数字，直接与栈顶元素计算，并替换栈顶元素为计算后的结果。</p></li><li><p>遍历字符串 s，并用变量preSign记录每个数字之前的运算符，对于第一个数字，其之前的运算符视为加号。遍历到运算符或者字符串最后一位时，根据preSign来决定计算方式:</p><ul><li><p>加号：数字直接入栈；</p></li><li><p>减号：num变(-num)入栈；</p></li><li><p>乘除：num ( * or / ) stack.back()，并将栈顶元素替换为运算结果。</p></li></ul></li></ol><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><p>时间复杂度：O(n)，其中n为字符串s的长度。需要遍历字符串s一次，计算表达式的值。</p></li><li><p>空间复杂度：O(n)，其中n为字符串s的长度。空间复杂度主要取决于栈的空间，栈的元素个数不超过n。</p></li></ul><p>需要注意的是</p><ul><li>在运算的时候，判断字符是数字还是运算符的时候，需要使用<code>isdigit()</code>函数，此函数包含在头文件<code>#include &lt;cctype&gt;</code>中。</li><li>运算的时候，如果遇到的数是大数(两位数及以上的)，需要进行处理。大数在字符串中是两个字符，需要在遍历字符串时，使用<code>num = num * 10 + int (s[i] - &#39;0&#39;);</code>对大数进行处理。</li><li>在乘除运算的结果都模拟入栈之后，使用累加函数<code>accumulate(st.begin(), st.end(), 0);</code>对数组进行累加处理，<code>accumulate()</code>函数包含在头文件<code>#include &lt;numeric&gt;</code>中，累加过程中，正负数都可以处理。</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  main.cpp</span></span><br><span class="line"><span class="comment">//  Demo</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by Egan.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calculate</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; st; <span class="comment">//digits</span></span><br><span class="line">        <span class="keyword">char</span> ps = <span class="string">&#x27;+&#x27;</span>; <span class="comment">//presign</span></span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isdigit</span>(s[i]))&#123; <span class="comment">//#include &lt;cctype&gt;</span></span><br><span class="line">                num = num * <span class="number">10</span> + <span class="keyword">int</span> (s[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">isdigit</span>(s[i]) &amp;&amp; s[i] != <span class="string">&#x27; &#x27;</span> || i == s.length()<span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="keyword">switch</span>(ps)&#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span> :</span><br><span class="line">                        st.push_back(num);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span> :</span><br><span class="line">                        st.push_back(-num);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span> :</span><br><span class="line">                        st.back() *= num;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span> :</span><br><span class="line">                        st.back() /= num;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ps = s[i];</span><br><span class="line">                num = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> accumulate(st.begin(), st.end(), <span class="number">0</span>); <span class="comment">//#include&lt;numeric&gt;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;基础计算器II-Basic-calculator-II&quot;&gt;&lt;a href=&quot;#基础计算器II-Basic-calculator-II&quot; class=&quot;headerlink&quot; title=&quot;基础计算器II (Basic calculator II)&quot;&gt;&lt;/a&gt;基础计</summary>
      
    
    
    
    <category term="算法" scheme="https://eganblog.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="Leetcode" scheme="https://eganblog.com/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
    
    <category term="日常" scheme="https://eganblog.com/tags/%E6%97%A5%E5%B8%B8/"/>
    
    <category term="C++" scheme="https://eganblog.com/tags/C/"/>
    
    <category term="Leetcode" scheme="https://eganblog.com/tags/Leetcode/"/>
    
    <category term="栈" scheme="https://eganblog.com/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>逆波兰表示法(Reverse Polish notation)</title>
    <link href="https://eganblog.com/2021/03/01/Reverse%20Polish%20notation/"/>
    <id>https://eganblog.com/2021/03/01/Reverse%20Polish%20notation/</id>
    <published>2021-03-01T08:12:14.000Z</published>
    <updated>2022-01-20T11:36:29.903Z</updated>
    
    <content type="html"><![CDATA[<h2 id="逆波兰表示法-Reverse-Polish-notation"><a href="#逆波兰表示法-Reverse-Polish-notation" class="headerlink" title="逆波兰表示法(Reverse Polish notation)"></a>逆波兰表示法(Reverse Polish notation)</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>根据逆波兰表示法，求表达式的值。</p><p>有效的运算符包括 <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code> 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。</p><p>逆波兰表达式主要有以下两个优点：</p><ul><li>去掉括号后表达式无歧义，<code>( 1 + 2 ) * ( 3 + 4 )</code>即便写成 <code>1 2 + 3 4 + * </code>也可以依据次序计算出正确结果。</li><li>适合用栈操作运算</li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>逆波兰表达式的求解是栈的经典应用。所以此题采用栈来解决，遇到数字则入栈，遇到运算符则取出<strong>栈顶两个数字</strong>进行运算，<strong>并将结果压入栈中</strong>。</p><p>需要注意的是</p><ul><li><p>在运算的时候，需要后取出的数字在前，先取出的数字在后，即num2在前。</p></li><li><p><code>stoi</code>表示<code>string to int</code>，即字符串转整数</p></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  main.cpp</span></span><br><span class="line"><span class="comment">//  Demo</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by Egan.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">evalRPN</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; tokens)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;tokens.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(tokens[i] == <span class="string">&quot;+&quot;</span>||tokens[i] == <span class="string">&quot;-&quot;</span>||tokens[i] == <span class="string">&quot;*&quot;</span>||tokens[i] == <span class="string">&quot;/&quot;</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> num1 = s.top();</span><br><span class="line">                s.pop();</span><br><span class="line">                <span class="keyword">int</span> num2 = s.top();</span><br><span class="line">                s.pop();</span><br><span class="line">                <span class="keyword">if</span>(tokens[i] == <span class="string">&quot;+&quot;</span>) s.push(num2 + num1);</span><br><span class="line">                <span class="keyword">if</span>(tokens[i] == <span class="string">&quot;-&quot;</span>) s.push(num2 - num1);</span><br><span class="line">                <span class="keyword">if</span>(tokens[i] == <span class="string">&quot;*&quot;</span>) s.push(num2 * num1);</span><br><span class="line">                <span class="keyword">if</span>(tokens[i] == <span class="string">&quot;/&quot;</span>) s.push(num2 / num1);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                s.push(stoi(tokens[i]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> result = s.top();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;逆波兰表示法-Reverse-Polish-notation&quot;&gt;&lt;a href=&quot;#逆波兰表示法-Reverse-Polish-notation&quot; class=&quot;headerlink&quot; title=&quot;逆波兰表示法(Reverse Polish notation)&quot;</summary>
      
    
    
    
    <category term="算法" scheme="https://eganblog.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="Leetcode" scheme="https://eganblog.com/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
    
    <category term="日常" scheme="https://eganblog.com/tags/%E6%97%A5%E5%B8%B8/"/>
    
    <category term="C++" scheme="https://eganblog.com/tags/C/"/>
    
    <category term="Leetcode" scheme="https://eganblog.com/tags/Leetcode/"/>
    
    <category term="栈" scheme="https://eganblog.com/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>Ming&#39;s random numbers</title>
    <link href="https://eganblog.com/2021/02/22/Ming&#39;s%20random%20numbers/"/>
    <id>https://eganblog.com/2021/02/22/Ming&#39;s%20random%20numbers/</id>
    <published>2021-02-22T05:46:57.000Z</published>
    <updated>2022-01-20T11:36:25.742Z</updated>
    
    <content type="html"><![CDATA[<h2 id="明明的随机数"><a href="#明明的随机数" class="headerlink" title="明明的随机数"></a>明明的随机数</h2><p>明明想在学校中请一些同学一起做一项问卷调查，为了实验的客观性，他先用计算机生成了N个1到1000之间的随机整数（N≤1000），对于其中重复的数字，只保留一个，把其余相同的数去掉，不同的数对应着不同的学生的学号。然后再把这些数从小到大排序，按照排好的顺序去找同学做调查。请你协助明明完成“去重”与“排序”的工作(同一个测试用例里可能会有多组数据(用于不同的调查)，希望大家能正确处理)</p><p>这是华为的一道面试题。在原文中已经明确点出了所需的一些函数，分别是排序和去重。C++有现成的排序函数<code>sort()</code>，以及去重函数<code>unique()</code>。其中<code>unique()</code>,<code>sort()</code>都是属于头文件<code>#include &lt;algorithm&gt;</code></p><p><code>auto end_un = unique(vec.begin(),vec.end());</code></p><p>这里的<code>unique()</code>返回的值是<font color="#dd0000">最后一个不重复数字的下标。</font></p><p>sort函数有三个参数：</p><ul><li><p>第一个是要排序的数组的起始地址</p></li><li><p>第二个是结束的地址（最后一位要排序的地址)</p></li><li><p>第三个参数是排序的方法，可以是升序也可是降序。如果不写第三个参数，则默认的排序方法是升序排列</p></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//升序</span></span><br><span class="line">sort( a, b, less&lt;<span class="keyword">int</span>&gt;() );</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//降序</span></span><br><span class="line">sort( a, b, greater&lt;<span class="keyword">int</span>&gt;() );</span><br></pre></td></tr></table></figure><p>如果先<code>去重</code>再<code>排序</code>，那么<code>去重</code>就有可能不会发挥作用。因为<code>去重</code>再<code>排序</code>排序时会把重复的数字又放在了一起，所以要先<code>排序</code>再<code>去重</code>。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  main.cpp</span></span><br><span class="line"><span class="comment">//  Demo</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by Egan.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">int</span> n= <span class="number">0</span>,num = <span class="number">0</span>;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//input</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; num;</span><br><span class="line">            vec.push_back(num);</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//sort</span></span><br><span class="line">        sort(vec.begin(), vec.end());</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//unique</span></span><br><span class="line">        <span class="keyword">auto</span> end_un = unique(vec.begin(),vec.end());</span><br><span class="line">        vec.erase(end_un, vec.end());</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> m = vec.begin(); m != vec.end(); m ++) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; *m &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;明明的随机数&quot;&gt;&lt;a href=&quot;#明明的随机数&quot; class=&quot;headerlink&quot; title=&quot;明明的随机数&quot;&gt;&lt;/a&gt;明明的随机数&lt;/h2&gt;&lt;p&gt;明明想在学校中请一些同学一起做一项问卷调查，为了实验的客观性，他先用计算机生成了N个1到1000之间的随机整</summary>
      
    
    
    
    <category term="算法" scheme="https://eganblog.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="Leetcode" scheme="https://eganblog.com/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
    
    <category term="日常" scheme="https://eganblog.com/tags/%E6%97%A5%E5%B8%B8/"/>
    
    <category term="C++" scheme="https://eganblog.com/tags/C/"/>
    
    <category term="Leetcode" scheme="https://eganblog.com/tags/Leetcode/"/>
    
    <category term="sort" scheme="https://eganblog.com/tags/sort/"/>
    
    <category term="unique" scheme="https://eganblog.com/tags/unique/"/>
    
  </entry>
  
  <entry>
    <title>毕业半年的自己</title>
    <link href="https://eganblog.com/2020/12/22/Six_months_after_graduation/"/>
    <id>https://eganblog.com/2020/12/22/Six_months_after_graduation/</id>
    <published>2020-12-22T05:46:57.000Z</published>
    <updated>2022-01-20T11:36:33.880Z</updated>
    
    <content type="html"><![CDATA[<h2 id="半年之后"><a href="#半年之后" class="headerlink" title="半年之后"></a>半年之后</h2><p>&emsp;我们这届的毕业生，大学只上了三年半，最后半年的时光都是在家里渡过。拿毕业证学位证、拍毕业照以及收拾行李，加起来不过两天时间。一切都是匆匆忙忙，匆忙到连一顿散伙饭都没法进行。<br><br>&emsp;还差几日，自己也就毕业半年了，也算是有了半年的<del>工作经验</del>(划水经验)，学软件的我，毕业之后进了一家偏自动化的公司，工业4.0时代嘛，天天代码倒是不多，感觉还不错。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;半年之后&quot;&gt;&lt;a href=&quot;#半年之后&quot; class=&quot;headerlink&quot; title=&quot;半年之后&quot;&gt;&lt;/a&gt;半年之后&lt;/h2&gt;&lt;p&gt;&amp;emsp;我们这届的毕业生，大学只上了三年半，最后半年的时光都是在家里渡过。拿毕业证学位证、拍毕业照以及收拾行李，加起来不</summary>
      
    
    
    
    <category term="日常" scheme="https://eganblog.com/categories/%E6%97%A5%E5%B8%B8/"/>
    
    <category term="工作" scheme="https://eganblog.com/categories/%E6%97%A5%E5%B8%B8/%E5%B7%A5%E4%BD%9C/"/>
    
    
    <category term="日常" scheme="https://eganblog.com/tags/%E6%97%A5%E5%B8%B8/"/>
    
    <category term="杂记" scheme="https://eganblog.com/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Test</title>
    <link href="https://eganblog.com/2020/10/22/firstPage/"/>
    <id>https://eganblog.com/2020/10/22/firstPage/</id>
    <published>2020-10-22T03:10:47.000Z</published>
    <updated>2022-01-20T11:36:20.632Z</updated>
    
    <content type="html"><![CDATA[<p><strong>测试文档</strong></p><pre><code>从这一篇测试文档开始，希望自己能够收起懒惰，重拾激情</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;测试文档&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;从这一篇测试文档开始，希望自己能够收起懒惰，重拾激情
&lt;/code&gt;&lt;/pre&gt;
</summary>
      
    
    
    
    
    <category term="Test" scheme="https://eganblog.com/tags/Test/"/>
    
  </entry>
  
</feed>
