<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Egan&#39;s Blog</title>
  
  <subtitle>The winter is coming</subtitle>
  <link href="https://blog.eganx.cn/atom.xml" rel="self"/>
  
  <link href="https://blog.eganx.cn/"/>
  <updated>2023-03-07T08:49:52.961Z</updated>
  <id>https://blog.eganx.cn/</id>
  
  <author>
    <name>Egan Dong</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2023第一篇面经</title>
    <link href="https://blog.eganx.cn/2023/02/26/2023_Interviews_No.1/"/>
    <id>https://blog.eganx.cn/2023/02/26/2023_Interviews_No.1/</id>
    <published>2023-02-26T07:40:11.000Z</published>
    <updated>2023-03-07T08:49:52.961Z</updated>
    
    <content type="html"><![CDATA[<p>2023开年第一篇面经。部分答案由ChatGPT补充</p><span id="more"></span><h3 id="0x0-谈谈go的内存对齐"><a href="#0x0-谈谈go的内存对齐" class="headerlink" title="0x0.谈谈go的内存对齐"></a>0x0.谈谈go的内存对齐</h3><p>在 Go 语言中，内存对齐是指结构体成员（字段）在内存中的对齐方式。具体来说，它决定了一个结构体成员在内存中的起始地址，以及在内存中占用的字节数。</p><p>Go 语言会自动为结构体成员进行内存对齐，并根据需要在结构体成员之间填充空闲字节，以确保结构体成员在内存中的地址和长度都符合硬件要求。这种自动化的内存对齐机制可以提高内存读写效率，减少 CPU 访问内存时的等待时间。</p><p>在 Go 语言中，一个结构体成员的对齐方式取决于其类型和大小。具体来说，一个结构体成员的对齐方式必须满足以下条件：</p><ol><li> 结构体成员的首地址必须是其大小（即占用的字节数）的倍数。</li><li> 结构体成员的大小必须是 2 的整数次幂（即 1、2、4、8 等）。</li></ol><p>如果结构体成员的大小不是 2 的整数次幂，则需要填充额外的空间以满足对齐的要求。例如，在一个结构体中定义了一个 int8 类型的成员和一个 int32 类型的成员，那么在 int8 成员后面就需要填充 3 个字节的空闲空间，才能让 int32 成员的地址满足对齐的要求。</p><pre><code>需要注意的是，在 Go 语言中，结构体成员之间的空闲字节是不能被使用的，因此它们只是为了填充内存而存在。如果想要更精细地控制结构体成员的内存布局，可以使用 `unsafe` 包中的相关函数来手动调整内存对齐方式，但需要注意安全性问题。</code></pre><p>在 Go 语言中，各个类型在内存对齐中所占大小如下：</p><ol><li><p>bool：1 字节。</p></li><li><p>int8、uint8（即 byte）、int16、uint16：2 字节。</p></li><li><p>int32、uint32、float32：4 字节。</p></li><li><p>int64、uint64、float64、complex64：8 字节。</p></li><li><p>complex128：16 字节。</p></li><li><p>string、slice、指针、map、channel 等引用类型：8 字节（在 64 位架构中）或 4 字节（在 32 位架构中），其中包含的是一个指向底层数据结构的指针。</p></li><li><p>struct 类型的大小取决于其成员变量的大小和排列方式，由编译器自动进行内存对齐。</p></li></ol><p><font color = LigBlue>这里给出的是一个基本的规则，实际上不同的编译器和操作系统可能会有不同的对齐方式和字节数。</font></p><p>Go语言的unsafe包提供了一些底层操作，包括调整内存对齐。可以使用unsafe包中的Alignof和Offsetof函数来获取结构体中字段的对齐方式和偏移量，然后使用uintptr类型的指针进行指针运算和内存地址计算。使用unsafe.Pointer类型的指针可以将任何类型的指针转换为通用指针类型，从而进行底层操作。但是需要注意，在使用unsafe包时要特别小心，因为它可能会导致程序不安全或不可移植。</p><h3 id="0x1-谈谈TCP和UDP的区别"><a href="#0x1-谈谈TCP和UDP的区别" class="headerlink" title="0x1. 谈谈TCP和UDP的区别"></a>0x1. 谈谈TCP和UDP的区别</h3><p>TCP（Transmission Control Protocol）和UDP（User Datagram Protocol）是两种网络协议，用于在计算机上运行的应用程序之间传输数据。它们有以下几个主要区别：</p><ol><li>连接：TCP是面向连接的协议，而UDP是无连接的协议。TCP通过三次握手建立连接，然后在发送和接收数据之前进行验证和确认。而UDP直接发送数据，没有连接的建立和维护过程。</li><li>可靠性：TCP提供可靠的数据传输，确保数据按照发送顺序到达目标地址，并且不会丢失或重复。它通过重传丢失的数据包、流量控制和拥塞控制等机制来保证数据传输的可靠性。而UDP不提供可靠性保证，数据包可能会丢失、重复、乱序等，需要应用层自己处理。</li><li>效率：由于TCP提供了可靠的数据传输和额外的控制协议，因此它通常比UDP慢一些，但比较稳定。而UDP没有这些额外的控制协议，因此速度比TCP快，但不够稳定。</li><li> 适用场景：TCP适用于需要可靠数据传输且需要顺序传输的应用程序，如文件传输、电子邮件、网页浏览等；而UDP适用于实时性要求高、对数据完整性和顺序性要求不高的应用程序，如音频、视频、游戏等。</li></ol><p>补充：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TCP的三次握手是指在建立TCP连接时，客户端和服务器之间需要进行三次交互来确认双方的通信状态。具体过程如下：</span><br><span class="line">1.  客户端向服务器发送SYN（同步）报文，表示客户端请求建立连接，并给这个数据包分配一个随机的初始序列号（ISN）。</span><br><span class="line">2.  服务器收到客户端的SYN报文后，回复一个SYN+ACK（同步&#x2F;确认）报文，表示接收到了客户端的连接请求，并确认自己也希望建立连接。同时，在这个SYN+ACK报文中也会分配一个随机的初始序列号。</span><br><span class="line">3.  客户端再次回复一个ACK（确认）报文，表示已经收到了服务器的确认，可以开始传输数据了。此时，TCP连接就建立完成了。</span><br><span class="line"></span><br><span class="line">在这个过程中，第一次握手是客户端向服务器发起连接请求，第二次握手是服务器接收客户端的请求并回复确认，第三次握手是客户端回复服务器的确认。这样，双方都确认了自己和对方的状态，保证了数据传输的可靠性。</span><br></pre></td></tr></table></figure><h3 id="0x2-谈一下golang死锁"><a href="#0x2-谈一下golang死锁" class="headerlink" title="0x2. 谈一下golang死锁"></a>0x2. 谈一下golang死锁</h3><p>在golang中，死锁指的是一种场景，即所有goroutine都被互相等待，导致程序无法继续执行。这种情况通常出现在使用channel进行通信时，并且没有正确地管理好goroutine之间的通信流程。</p><p>一个常见的例子是两个goroutine相互等待对方释放锁的情况，如下面的代码：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        &lt;-ch <span class="comment">// 1. 等待从通道中读取数据</span></span><br><span class="line">        ch &lt;- <span class="number">1</span> <span class="comment">// 3. 向通道中写入数据</span></span><br><span class="line">    &#125;()</span><br><span class="line">    ch &lt;- <span class="number">1</span> <span class="comment">// 2. 向通道中写入数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这段代码中，第一个goroutine等待从通道中读取数据（步骤1），但是在这之前它必须等待第二个goroutine向通道中写入数据（步骤2）。而第二个goroutine同样需要等待第一个goroutine从通道中读取数据后才能向通道中写入数据（步骤3）。因此，在这种情况下，两个goroutine将会陷入无限期的等待，导致程序无法继续执行，最终出现死锁。</p><pre><code>为了避免死锁的发生，需要合理地设计和管理goroutine之间的通信流程，确保每个goroutine在正确的时间点上释放锁并等待其它goroutine的响应。此外，可以使用go语言内置的工具来帮助检测和解决死锁问题，例如`go vet`、`go tool vet`等。</code></pre><h3 id="0x3-Go的并发机制"><a href="#0x3-Go的并发机制" class="headerlink" title="0x3. Go的并发机制"></a>0x3. Go的并发机制</h3><p>Go语言的并发机制是一种基于Goroutine和Channel的轻量级协程模型，具有高效、简洁、安全等特点，可用于实现高并发、分布式、异步和并行计算等场景。下面详细介绍Go语言的并发机制。</p><ol><li> Goroutine<br>Goroutine是一种轻量级的用户态线程，由Go运行时系统调度，在单个操作系统线程上并发执行多个任务。Goroutine的创建非常简单，只需使用关键字go后跟需要执行的函数即可：</li></ol><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Hello, Goroutine!&quot;</span>)</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，使用go关键字启动一个新的Goroutine，执行匿名函数并输出”Hello, Goroutine!”。与传统的线程相比，Goroutine更加轻量级、灵活、高效，因为它们可以在需要时自动伸缩，并且可以通过通信来共享数据和协调行为，无需显式的锁或条件变量等同步机制。</p><ol start="2"><li><p>Channel</p><p>Channel是Goroutine之间进行通信的一种方式，它类似于UNIX中的管道，可以将数据从一个Goroutine发送到另一个Goroutine。Channel有以下几个特点：</p></li></ol><ul><li>  Channel是类型化的，必须指定传输数据的类型；</li><li>  Channel是同步的，发送和接收操作都会阻塞，直到对应的另一个Goroutine完成了配对操作；</li><li>  Channel是并发安全的，多个Goroutine同时操作同一个Channel时不会出现竞态条件或死锁等问题。</li></ul><p>可以通过make函数创建Channel示例：<br><code>ch := make(chan int)  // 创建一个int类型的Channel</code></p><p>通过&lt;-符号进行发送和接收操作：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch &lt;- <span class="number">1</span>     <span class="comment">// 向Channel中发送数据</span></span><br><span class="line">value := &lt;-ch   <span class="comment">// 从Channel中接收数据</span></span><br></pre></td></tr></table></figure><p>同时，可以使用range关键字遍历Channel中的所有数据，或者使用select结构体实现多路复用等操作。</p><ol start="3"><li> 共享内存</li></ol><p>除了使用Channel进行通信外，Go语言也支持传统的共享内存并发模型，例如使用sync包中提供的锁（Mutex）和条件变量（Cond）等机制。这些机制可以在多个Goroutine之间共享访问同一份数据，并进行同步和互斥等操作。</p><ol start="4"><li> 原子操作</li></ol><p>为了避免竞态条件等问题，Go语言还提供了原子操作（atomic）机制，用于保证对共享资源的并发访问的原子性和一致性。原子操作包括原子增减、原子比较交换、原子读写等操作，可以有效地解决多个Goroutine同时对同一份数据进行操作的问题。</p><p>总体来说，Go语言的并发机制具有高效、简洁、安全等优点，使得它成为了开发高并发、分布式、异步和并行计算等应用程序的理想语言和工具。</p><h3 id="0x4-MVC-和-MVVM的异同"><a href="#0x4-MVC-和-MVVM的异同" class="headerlink" title="0x4. MVC 和 MVVM的异同"></a>0x4. MVC 和 MVVM的异同</h3><p>MVC (Model-View-Controller) 和 MVVM (Model-View-ViewModel) 是两种常见的应用程序设计模式，其目的都是在应用程序中清晰地分离数据、用户界面和业务逻辑。虽然这两种模式都有类似的架构，但它们之间存在一些重要的区别。</p><p><strong>MVC 模式：</strong><br>MVC 模式是一种传统的模式，最早用于桌面应用程序的设计。在 MVC 中，软件应用程序被划分为三个部分：模型（Model）、视图（View）和控制器（Controller）。</p><ul><li>  Model是应用程序中的数据和状态的主要表示。它与数据库或其他持久性存储解耦，并提供了一个简单的接口来获取和设置数据。</li><li>  View是用户界面的呈现，它负责显示 Model 对象的当前状态。</li><li>  Controller 接收用户输入并根据需要更新 Model 和 View。 它充当 View 和 Model 之间的协调者，并包含适当的逻辑和算法来更新它们。</li></ul><p>MVC 模式的优点是强制实现代码的分离和组织方式，使得代码更加清晰和易于维护。但是，MVC 模式可能会导致控制器变得过于复杂，因为它承担了太多的责任。</p><p><strong>MVVM 模式：</strong><br>MVVM 模式是一种比较新的模式，最初用于 Windows Presentation Foundation (WPF) 的设计。在 MVVM 中，应用程序也被划分为三个部分：模型（Model）、视图（View）和视图模型（ViewModel）。</p><ul><li>  Model 与 MVC 模式相同，表示应用程序中的数据和状态。</li><li>  View 是用户界面的呈现，它负责显示视图模型（ViewModel）所公开的属性和命令。</li><li>  ViewModel 是 View 和 Model 之间的连接器，它充当模型和视图之间的协调者。ViewModel 将 Model 对象转换为 View 可以直接使用的格式，并将数据绑定到 View 上。</li></ul><p>MVVM 模式的优点是更好的可扩展性和可维护性，因为 ViewModel 在处理显示逻辑时不会像控制器那样过于复杂，而且数据绑定功能可以减少代码的重复和冗余。然而，MVVM 模式需要更多的学习和实践，特别是在处理大量异步操作和复杂 UI 逻辑时。</p><h3 id="0x5-进程、线程、协程的区别"><a href="#0x5-进程、线程、协程的区别" class="headerlink" title="0x5. 进程、线程、协程的区别"></a>0x5. 进程、线程、协程的区别</h3><p>进程、线程和协程的区别主要表现在以下几个方面：</p><ol><li><p>调度方式：进程和线程都由操作系统进行调度，而协程的调度是由程序员手动控制。</p></li><li><p>系统开销：每个进程都有独立的内存空间和系统资源，所以创建和撤销进程的代价比较大。线程共享相同的内存空间和资源，所以创建和撤销线程的代价比进程要小一些。而协程则更加轻量级，创建和撤销协程的代价最小。</p></li><li><p>内存空间：每个进程都有自己独立的内存空间，不同进程之间的内存无法共享。线程共享相同的内存空间，但是需要考虑线程安全问题。协程也共享相同的内存空间，但是可以通过控制协程的执行顺序来避免线程安全问题。</p></li><li><p>执行速度：由于每个进程都有独立的内存空间和资源，因此进程之间的通信和同步比较慢。线程共享相同的内存空间和资源，因此线程之间的通信和同步比进程快一些。协程更快速和高效，因为它们不需要像线程那样切换上下文。</p></li></ol><h3 id="0x6-Go的GC机制"><a href="#0x6-Go的GC机制" class="headerlink" title="0x6. Go的GC机制"></a>0x6. Go的GC机制</h3><p>三色标记法、混合读写屏障。<a href="https://blog.eganx.cn/2022/11/16/Go_GC/">之前的笔记📒balabalabala</a></p><h3 id="0x7-如何连通两个互不相连的局域网"><a href="#0x7-如何连通两个互不相连的局域网" class="headerlink" title="0x7. 如何连通两个互不相连的局域网"></a>0x7. 如何连通两个互不相连的局域网</h3><p>两个互不相连的局域网要进行通信，可以通过以下几种方式实现：</p><ol><li>VPN（Virtual Private Network）：通过在公共网络上建立虚拟专用网络来连接两个局域网。VPN 可以使用安全的加密协议来保护通信数据的安全性。</li><li>隧道（Tunneling）：通过在公共网络上建立一个隧道来连接两个局域网。隧道可以使用加密协议来保护通信数据的机密性和完整性。</li><li>NAT（Network Address Translation）转换：使用 NAT 转换器将两个局域网中的 IP 地址转换为公网 IP 地址，从而使它们可以相互访问。</li><li>代理服务器（Proxy Server）：在两个局域网之间放置一个代理服务器，通过代理服务器进行通信。</li><li>公共云服务（Public Cloud Service）：将两个局域网连接到同一个公共云服务中，并使用该服务提供的网络功能进行通信。</li></ol><p>总的来说，连接两个互不相连的局域网需要考虑数据安全性、通信速度、成本等因素，选择合适的方法进行连接。</p><h3 id="0x7-开放式讨论"><a href="#0x7-开放式讨论" class="headerlink" title="0x7. 开放式讨论"></a>0x7. 开放式讨论</h3><ul><li><input disabled="" type="checkbox"> C#和Go的区别  开放式  随便说</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;2023开年第一篇面经。部分答案由ChatGPT补充&lt;/p&gt;</summary>
    
    
    
    <category term="Work" scheme="https://blog.eganx.cn/categories/Work/"/>
    
    
    <category term="Go" scheme="https://blog.eganx.cn/tags/Go/"/>
    
    <category term="面试" scheme="https://blog.eganx.cn/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>1. 两数之和</title>
    <link href="https://blog.eganx.cn/2023/02/04/1.%20Two_sum/"/>
    <id>https://blog.eganx.cn/2023/02/04/1.%20Two_sum/</id>
    <published>2023-02-04T14:22:11.000Z</published>
    <updated>2023-03-07T07:44:17.211Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x0-题目描述"><a href="#0x0-题目描述" class="headerlink" title="0x0. 题目描述"></a>0x0. 题目描述</h3><p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。<br>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。<br>你可以按任意顺序返回答案。</p><span id="more"></span><p>链接： <a href="https://leetcode.cn/problems/two-sum">https://leetcode.cn/problems/two-sum</a></p><h3 id="0x1-示例"><a href="#0x1-示例" class="headerlink" title="0x1. 示例"></a>0x1. 示例</h3><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [2,7,11,15], target &#x3D; 9</span><br><span class="line">输出：[0,1]</span><br><span class="line">解释：因为 nums[0] + nums[1] &#x3D;&#x3D; 9 ，返回 [0, 1] 。</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [3,2,4], target &#x3D; 6</span><br><span class="line">输出：[1,2]</span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [3,3], target &#x3D; 6</span><br><span class="line">输出：[0,1]</span><br></pre></td></tr></table></figure><h3 id="0x2-提示："><a href="#0x2-提示：" class="headerlink" title="0x2. 提示："></a>0x2. 提示：</h3><ul><li><code>2 &lt;= nums.length &lt;= 104</code></li><li><code>-109 &lt;= nums[i] &lt;= 109</code></li><li><code>-109 &lt;= target &lt;= 109</code></li><li>只会存在一个有效答案</li></ul><h3 id="0x3-解题思路："><a href="#0x3-解题思路：" class="headerlink" title="0x3. 解题思路："></a>0x3. 解题思路：</h3><ol><li> 创建一个哈希表 <code>map</code>，用于存储数组中每个数对应的索引。</li><li> 遍历数组 <code>nums</code>，检查当前数字 <code>num</code> 的补数 <code>complement</code> 是否在哈希表中出现过（即是否满足 <code>complement = target - num</code>），如果是，则说明已经找到了答案，返回两个数的索引；否则，将当前数字和它的索引加入哈希表中。</li><li> 如果遍历完整个数组都没有找到符合条件的数对，则说明不存在这样的两个数，返回空数组或者抛出异常。</li></ol><h3 id="0x4-Go-语言实现的代码示例："><a href="#0x4-Go-语言实现的代码示例：" class="headerlink" title="0x4. Go 语言实现的代码示例："></a>0x4. Go 语言实现的代码示例：</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">twoSum</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>) <span class="comment">// 创建哈希表</span></span><br><span class="line">    <span class="keyword">for</span> i, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        complement := target - num</span><br><span class="line">        <span class="keyword">if</span> j, ok := m[complement]; ok &#123; <span class="comment">// 如果哈希表中已经存在 complement，则说明找到了答案</span></span><br><span class="line">            <span class="keyword">return</span> []<span class="keyword">int</span>&#123;j, i&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        m[num] = i <span class="comment">// 将当前数字和它的索引加入哈希表中</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span> <span class="comment">// 如果遍历完整个数组都没有找到符合条件的数对，则返回空数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度为 O(n)，空间复杂度为 O(n)。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;0x0-题目描述&quot;&gt;&lt;a href=&quot;#0x0-题目描述&quot; class=&quot;headerlink&quot; title=&quot;0x0. 题目描述&quot;&gt;&lt;/a&gt;0x0. 题目描述&lt;/h3&gt;&lt;p&gt;给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。&lt;br&gt;你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。&lt;br&gt;你可以按任意顺序返回答案。&lt;/p&gt;</summary>
    
    
    
    <category term="Leetcode" scheme="https://blog.eganx.cn/categories/Leetcode/"/>
    
    
    <category term="Go" scheme="https://blog.eganx.cn/tags/Go/"/>
    
    <category term="Leetcode" scheme="https://blog.eganx.cn/tags/Leetcode/"/>
    
    <category term="hashmap" scheme="https://blog.eganx.cn/tags/hashmap/"/>
    
  </entry>
  
  <entry>
    <title>202.快乐数</title>
    <link href="https://blog.eganx.cn/2023/02/04/202.%20Happy_number/"/>
    <id>https://blog.eganx.cn/2023/02/04/202.%20Happy_number/</id>
    <published>2023-02-04T14:22:11.000Z</published>
    <updated>2023-03-07T07:44:23.332Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x0-题目描述"><a href="#0x0-题目描述" class="headerlink" title="0x0. 题目描述"></a>0x0. 题目描述</h3><p>编写一个算法来判断一个数 n 是不是快乐数。<br>「快乐数」 定义为：</p><ul><li>对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。</li><li>然后重复这个过程直到这个数变为 1，也可能是 <strong>无限循环</strong> 但始终变不到 1。</li><li>如果这个过程 <strong>结果为 1</strong>，那么这个数就是快乐数。<br>如果 n 是 快乐数 就返回 true ；不是，则返回 false 。</li></ul><span id="more"></span><p>链接： <a href="https://leetcode.cn/problems/happy-number">https://leetcode.cn/problems/happy-number</a></p><h3 id="0x1-示例"><a href="#0x1-示例" class="headerlink" title="0x1. 示例"></a>0x1. 示例</h3><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 19</span><br><span class="line">输出：true</span><br><span class="line">解释：</span><br><span class="line">12 + 92 &#x3D; 82</span><br><span class="line">82 + 22 &#x3D; 68</span><br><span class="line">62 + 82 &#x3D; 100</span><br><span class="line">12 + 02 + 02 &#x3D; 1</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 2</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><h3 id="0x2-提示"><a href="#0x2-提示" class="headerlink" title="0x2. 提示"></a>0x2. 提示</h3><ul><li>1 &lt;= n &lt;= 231 - 1</li></ul><h3 id="0x3-解题思路："><a href="#0x3-解题思路：" class="headerlink" title="0x3. 解题思路："></a>0x3. 解题思路：</h3><ol><li> 定义一个哈希集合 <code>seen</code>，用于记录每次计算的结果。</li><li> 从输入数字 n 开始，计算其每个数位的平方和，并将结果存入变量 <code>sum</code> 中。例如，对于数字 n=19，计算过程为：1² + 9² = 82。</li><li> 检查 <code>sum</code> 是否等于 1。如果是，则说明 n 是快乐数，返回 true；如果不是，则检查 <code>sum</code> 是否在 <code>seen</code> 集合中出现过。如果是，则说明已经进入了循环，n 不是快乐数，返回 false。如果不是，则将 <code>sum</code> 加入集合 <code>seen</code> 中，并更新 n 的值为 <code>sum</code>，继续进行下一轮计算。</li><li> 重复步骤 2-3 直到找到答案或者进入循环。</li></ol><h3 id="0x4-Go-语言实现的代码示例："><a href="#0x4-Go-语言实现的代码示例：" class="headerlink" title="0x4. Go 语言实现的代码示例："></a>0x4. Go 语言实现的代码示例：</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isHappy</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    seen := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">bool</span>) <span class="comment">// 创建哈希集合</span></span><br><span class="line">    <span class="keyword">for</span> n != <span class="number">1</span> &amp;&amp; !seen[n] &#123;   <span class="comment">// 判断是否已经找到答案或者进入循环</span></span><br><span class="line">        seen[n] = <span class="literal">true</span>         <span class="comment">// 将当前数加入哈希集合</span></span><br><span class="line">        sum := <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> n &gt; <span class="number">0</span> &#123;            <span class="comment">// 计算每个数位的平方和</span></span><br><span class="line">            digit := n % <span class="number">10</span></span><br><span class="line">            sum += digit * digit</span><br><span class="line">            n /= <span class="number">10</span></span><br><span class="line">        &#125;</span><br><span class="line">        n = sum                <span class="comment">// 更新 n 的值为平方和</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n == <span class="number">1</span>             <span class="comment">// 如果最终得到 1，则说明是快乐数；否则不是</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度为 O(log n)，空间复杂度为 O(log n)。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;0x0-题目描述&quot;&gt;&lt;a href=&quot;#0x0-题目描述&quot; class=&quot;headerlink&quot; title=&quot;0x0. 题目描述&quot;&gt;&lt;/a&gt;0x0. 题目描述&lt;/h3&gt;&lt;p&gt;编写一个算法来判断一个数 n 是不是快乐数。&lt;br&gt;「快乐数」 定义为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。&lt;/li&gt;
&lt;li&gt;然后重复这个过程直到这个数变为 1，也可能是 &lt;strong&gt;无限循环&lt;/strong&gt; 但始终变不到 1。&lt;/li&gt;
&lt;li&gt;如果这个过程 &lt;strong&gt;结果为 1&lt;/strong&gt;，那么这个数就是快乐数。&lt;br&gt;如果 n 是 快乐数 就返回 true ；不是，则返回 false 。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Leetcode" scheme="https://blog.eganx.cn/categories/Leetcode/"/>
    
    
    <category term="Go" scheme="https://blog.eganx.cn/tags/Go/"/>
    
    <category term="Leetcode" scheme="https://blog.eganx.cn/tags/Leetcode/"/>
    
    <category term="hashmap" scheme="https://blog.eganx.cn/tags/hashmap/"/>
    
  </entry>
  
  <entry>
    <title>383. 赎金信</title>
    <link href="https://blog.eganx.cn/2023/02/04/383.%20ransom_note/"/>
    <id>https://blog.eganx.cn/2023/02/04/383.%20ransom_note/</id>
    <published>2023-02-04T14:22:11.000Z</published>
    <updated>2023-03-07T07:44:34.902Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x0-题目描述"><a href="#0x0-题目描述" class="headerlink" title="0x0. 题目描述"></a>0x0. 题目描述</h3><p>给你两个字符串：ransomNote 和 magazine ，判断 ransomNote 能不能由 magazine 里面的字符构成。<br>如果可以，返回 true ；否则返回 false 。<br>magazine 中的每个字符只能在 ransomNote 中使用一次。</p><span id="more"></span><p>链接： <a href="https://leetcode.cn/problems/ransom-note">https://leetcode.cn/problems/ransom-note</a></p><h3 id="0x1-示例"><a href="#0x1-示例" class="headerlink" title="0x1. 示例"></a>0x1. 示例</h3><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：ransomNote &#x3D; &quot;a&quot;, magazine &#x3D; &quot;b&quot;</span><br><span class="line">输出：false</span><br><span class="line">示例 2：</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：ransomNote &#x3D; &quot;aa&quot;, magazine &#x3D; &quot;ab&quot;</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：ransomNote &#x3D; &quot;aa&quot;, magazine &#x3D; &quot;aab&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><h3 id="0x2-提示"><a href="#0x2-提示" class="headerlink" title="0x2. 提示"></a>0x2. 提示</h3><ul><li><code>1 &lt;= ransomNote.length, magazine.length &lt;= 105</code></li><li><code>ransomNote 和 magazine 由小写英文字母组成</code></li></ul><h3 id="0x3-解题思路1"><a href="#0x3-解题思路1" class="headerlink" title="0x3. 解题思路1"></a>0x3. 解题思路1</h3><ol><li> 创建一个长度为 27（26 个小写字母加一个边界值）的整型数组 <code>ml</code>，用于记录 magazine 中每个字符出现的次数。</li><li> 遍历字符串 <code>magazine</code> 中的每个字符 <code>v</code>，将 <code>ml[v-&#39;a&#39;]</code> 的值加 1，表示字符 <code>v</code> 出现了一次。</li><li> 遍历字符串 <code>ransomNote</code> 中的每个字符 <code>vv</code>，将 <code>ml[vv-&#39;a&#39;]</code> 的值减 1，表示字符 <code>vv</code> 在 <code>magazine</code> 中被使用了一次。如果 <code>ml[vv-&#39;a&#39;]</code> 的值小于 0，则说明 <code>ranasomNote</code> 中出现了一个 <code>magazine</code> 中没有的字符，返回 false。</li><li> 如果遍历完整个 <code>ransomNote</code> 后都没有返回 false，则说明可以由 <code>magazine</code> 构成，返回 true。</li></ol><h3 id="0x3-解题思路2"><a href="#0x3-解题思路2" class="headerlink" title="0x3. 解题思路2"></a>0x3. 解题思路2</h3><ol><li> 创建一个哈希表 <code>mag</code>，用于记录 magazine 中每个字符出现的次数。</li><li> 遍历 ransomNote 中的每个字符，检查它是否在哈希表 <code>mag</code> 中出现过。如果没有出现过，则说明不能由 magazine 构成，返回 false；如果出现过，则将该字符对应的计数减 1。</li><li> 如果遍历完整个 ransomNote 都没有返回 false，则说明可以由 magazine 构成，返回 true。</li></ol><h3 id="0x4-Go-语言实现的代码示例1："><a href="#0x4-Go-语言实现的代码示例1：" class="headerlink" title="0x4. Go 语言实现的代码示例1："></a>0x4. Go 语言实现的代码示例1：</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canConstruct</span><span class="params">(ransomNote <span class="keyword">string</span>, magazine <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">ml := <span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">27</span>)</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> magazine &#123;</span><br><span class="line">ml[v-<span class="string">&#x27;a&#x27;</span>]++</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, vv := <span class="keyword">range</span> ransomNote &#123;</span><br><span class="line">ml[vv-<span class="string">&#x27;a&#x27;</span>]--</span><br><span class="line"><span class="keyword">if</span> ml[vv-<span class="string">&#x27;a&#x27;</span>] &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用两个数组来分别记录两个字符串中每个字符出现的次数。由于只需要遍历两个字符串各一遍，因此时间复杂度为 O(m+n)，空间复杂度为 O(1)，其中 m 和 n 分别为字符串 ransomNote 和 magazine 的长度。</li></ul><h3 id="0x4-Go-语言实现的代码示例2："><a href="#0x4-Go-语言实现的代码示例2：" class="headerlink" title="0x4. Go 语言实现的代码示例2："></a>0x4. Go 语言实现的代码示例2：</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canConstruct</span><span class="params">(ransomNote <span class="keyword">string</span>, magazine <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    mag := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">byte</span>]<span class="keyword">int</span>) <span class="comment">// 创建哈希表</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> magazine &#123;</span><br><span class="line">        mag[magazine[i]]++    <span class="comment">// 记录 magazine 中每个字符出现的次数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> ransomNote &#123;</span><br><span class="line">        <span class="keyword">if</span> cnt, ok := mag[ransomNote[i]]; !ok || cnt == <span class="number">0</span> &#123; <span class="comment">// 检查 ransomNote 中的每个字符是否在 mag 中出现过</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mag[ransomNote[i]]-- <span class="comment">// 将 mag 中对应字符的计数减 1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度为 O(m+n)，空间复杂度为 O(m)，其中 m 和 n 分别为字符串 ransomNote 和 magazine 的长度。</li></ul>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;0x0-题目描述&quot;&gt;&lt;a href=&quot;#0x0-题目描述&quot; class=&quot;headerlink&quot; title=&quot;0x0. 题目描述&quot;&gt;&lt;/a&gt;0x0. 题目描述&lt;/h3&gt;&lt;p&gt;给你两个字符串：ransomNote 和 magazine ，判断 ransomNote 能不能由 magazine 里面的字符构成。&lt;br&gt;如果可以，返回 true ；否则返回 false 。&lt;br&gt;magazine 中的每个字符只能在 ransomNote 中使用一次。&lt;/p&gt;</summary>
    
    
    
    <category term="Leetcode" scheme="https://blog.eganx.cn/categories/Leetcode/"/>
    
    
    <category term="Go" scheme="https://blog.eganx.cn/tags/Go/"/>
    
    <category term="Leetcode" scheme="https://blog.eganx.cn/tags/Leetcode/"/>
    
    <category term="hashmap" scheme="https://blog.eganx.cn/tags/hashmap/"/>
    
  </entry>
  
  <entry>
    <title>349. 两个数组的交集</title>
    <link href="https://blog.eganx.cn/2023/02/04/349.%20intersection_of_two_arrays/"/>
    <id>https://blog.eganx.cn/2023/02/04/349.%20intersection_of_two_arrays/</id>
    <published>2023-02-04T14:22:11.000Z</published>
    <updated>2023-03-07T07:44:29.957Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x0-题目描述"><a href="#0x0-题目描述" class="headerlink" title="0x0. 题目描述"></a>0x0. 题目描述</h3><p>给定两个数组 nums1 和 nums2 ，返回 它们的交集 。输出结果中的每个元素一定是 唯一 的。我们可以 不考虑输出结果的顺序 。</p><span id="more"></span><p>链接： <a href="https://leetcode.cn/problems/intersection-of-two-arrays">https://leetcode.cn/problems/intersection-of-two-arrays</a></p><h3 id="0x1-示例"><a href="#0x1-示例" class="headerlink" title="0x1. 示例"></a>0x1. 示例</h3><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums1 &#x3D; [1,2,2,1], nums2 &#x3D; [2,2]</span><br><span class="line">输出：[2]</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums1 &#x3D; [4,9,5], nums2 &#x3D; [9,4,9,8,4]</span><br><span class="line">输出：[9,4]</span><br><span class="line">解释：[4,9] 也是可通过的</span><br></pre></td></tr></table></figure><h3 id="0x2-提示"><a href="#0x2-提示" class="headerlink" title="0x2. 提示"></a>0x2. 提示</h3><ul><li><code>1 &lt;= nums1.length, nums2.length &lt;= 1000</code></li><li><code>0 &lt;= nums1[i], nums2[i] &lt;= 1000</code></li></ul><h3 id="0x3-解题思路"><a href="#0x3-解题思路" class="headerlink" title="0x3. 解题思路"></a>0x3. 解题思路</h3><ol><li> 创建一个空的切片 <code>res</code> 和一个空的哈希表 <code>set</code>。</li><li> 遍历数组 <code>nums1</code> 中的每个元素 <code>v</code>，如果 <code>v</code> 在哈希表 <code>set</code> 中不存在，则将其加入哈希表中。</li><li> 遍历数组 <code>nums2</code> 中的每个元素 <code>v</code>，如果 <code>v</code> 在哈希表 <code>set</code> 中存在，则将其加入切片 <code>res</code> 中，并从哈希表 <code>set</code> 中删除。</li><li> 返回切片 <code>res</code>。</li></ol><h3 id="0x4-Go-语言实现的代码示例："><a href="#0x4-Go-语言实现的代码示例：" class="headerlink" title="0x4. Go 语言实现的代码示例："></a>0x4. Go 语言实现的代码示例：</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">intersection</span><span class="params">(nums1 []<span class="keyword">int</span>, nums2 []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">res := <span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">0</span>)</span><br><span class="line">set := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">interface</span>&#123;&#125;,<span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> nums1 &#123;</span><br><span class="line"><span class="keyword">if</span> _, ok := set[v]; !ok&#123;</span><br><span class="line">set[v] = v <span class="comment">//赋值随意，只要后面能取到东西就行</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> nums2 &#123;</span><br><span class="line"><span class="keyword">if</span> _, ok := set[v]; ok&#123;</span><br><span class="line">res = <span class="built_in">append</span>(res, v)</span><br><span class="line"><span class="built_in">delete</span>(set,v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用哈希表来记录一个数组中的元素，然后遍历另一个数组，找到其中在哈希表中出现过的元素。实现用一个接口类型来占据值的位置，只关注 key 的存在，而不关心具体的 value 值。</li><li>时间复杂度为 O(m+n)，空间复杂度为 O(min(m,n))，其中 m 和 n 分别为两个数组的长度。但需要注意的是，由于哈希表的散列函数可能会产生冲突，因此在极端情况下，时间复杂度可能会退化为 O(m * n)。</li></ul>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;0x0-题目描述&quot;&gt;&lt;a href=&quot;#0x0-题目描述&quot; class=&quot;headerlink&quot; title=&quot;0x0. 题目描述&quot;&gt;&lt;/a&gt;0x0. 题目描述&lt;/h3&gt;&lt;p&gt;给定两个数组 nums1 和 nums2 ，返回 它们的交集 。输出结果中的每个元素一定是 唯一 的。我们可以 不考虑输出结果的顺序 。&lt;/p&gt;</summary>
    
    
    
    <category term="Leetcode" scheme="https://blog.eganx.cn/categories/Leetcode/"/>
    
    
    <category term="Go" scheme="https://blog.eganx.cn/tags/Go/"/>
    
    <category term="Leetcode" scheme="https://blog.eganx.cn/tags/Leetcode/"/>
    
    <category term="hashmap" scheme="https://blog.eganx.cn/tags/hashmap/"/>
    
  </entry>
  
  <entry>
    <title>数据库基础--锁和隔离级别</title>
    <link href="https://blog.eganx.cn/2022/11/20/DB_base_%20lock_and_isolation/"/>
    <id>https://blog.eganx.cn/2022/11/20/DB_base_%20lock_and_isolation/</id>
    <published>2022-11-20T07:54:23.000Z</published>
    <updated>2022-12-31T02:55:40.471Z</updated>
    
    <content type="html"><![CDATA[<p>锁的类型和数据库事务隔离级别。</p><span id="more"></span><h2 id="0x0-锁粒度"><a href="#0x0-锁粒度" class="headerlink" title="0x0.锁粒度"></a>0x0.锁粒度</h2><p>MySQL提供了行级锁和表级锁。</p><p>应该尽量只锁定需要修改的那部分数据，而不是所有的资源。锁定的数据量越少，发生锁争用的可能性就越小，系统的并发程度就越高。</p><p>但是加锁需要消耗资源，各种锁操作都会增加系统开销。因此锁的粒度越小，系统开销就越大。在选择锁粒度的时候，需要平衡锁开销和系统并发程度。</p><h2 id="0x1-锁类型"><a href="#0x1-锁类型" class="headerlink" title="0x1.锁类型"></a>0x1.锁类型</h2><h4 id="1-读写锁"><a href="#1-读写锁" class="headerlink" title="1).读写锁"></a>1).读写锁</h4><ul><li><p>互斥锁(Exclusive)，简写X锁，又称写锁。</p></li><li><p>共享锁(Shared)，简写S锁，又称读锁。</p></li><li><p>一个事务对数据对象A加了X锁，就可以对A进行读取和更新。加锁期间其他事务不能对A加任何锁。</p></li><li><p>一个事务对数据对象A加了S锁，可以对A进行读取操作，不能进行更新操作。加锁期间其他事务能对A加S锁，但是不能加X锁。</p></li></ul><p>锁的兼容关系：</p><table><thead><tr><th align="center"></th><th align="center">X</th><th align="center">S</th></tr></thead><tbody><tr><td align="center">X</td><td align="center">❌</td><td align="center">❌</td></tr><tr><td align="center">S</td><td align="center">❌</td><td align="center"><strong>✔️</strong></td></tr></tbody></table><h4 id="2-意向锁"><a href="#2-意向锁" class="headerlink" title="2).意向锁"></a>2).意向锁</h4><p>使用意向锁可以更容易地支持多粒度封锁。</p><p>在存在行级锁和表级锁的情况下，事务T想要对表A加X锁，就需要先检测是否有其他事务对表A或者表A中的任意一行加了锁，需要对表A的每一行都检测一次，非常耗时。</p><p>意向锁就是在原来的X/S锁之上引入了IX/IS锁，IX/IS锁都是表锁，用来表示一个事务想要在表中的某个数据行上加X锁或S锁。</p><ul><li>一个事务在获得某个数据行对象的S锁之前，必须先获得表的IS锁或者更强的锁。</li><li>一个事务在获得某个数据行对象的X锁之前，必须先获得表的IX锁。</li></ul><p>通过引入意向锁，事务T想要对表A加X锁，只需要先检测是否有其他事务对表A加了X/IX/S/IS锁，如果加了就表示有其他事务正在使用这个表或者表中某一行的锁，因此事务T加X锁失败。</p><p>各种锁的兼容关系：</p><table><thead><tr><th align="center"></th><th align="center">X</th><th align="center">IX</th><th align="center">S</th><th align="center">IS</th></tr></thead><tbody><tr><td align="center">X</td><td align="center">❌</td><td align="center">❌</td><td align="center">❌</td><td align="center">❌</td></tr><tr><td align="center">IX</td><td align="center">❌</td><td align="center">✔️</td><td align="center">❌</td><td align="center">✔️</td></tr><tr><td align="center">S</td><td align="center">❌</td><td align="center">❌</td><td align="center">✔️</td><td align="center">✔️</td></tr><tr><td align="center">IS</td><td align="center">❌</td><td align="center">✔️</td><td align="center">✔️</td><td align="center">✔️</td></tr></tbody></table><ul><li>任意IS/IX锁之间都是兼容的，因为它们只表示想要对表加锁，而不是真正加锁。</li><li>兼容关系针对表级锁，而表级的IX锁和行级的X锁兼容，两个事务可以对两个数据行加X锁。（事务 T1 想要对数据行 R1 加 X 锁，事务 T2 想要对同一个表的数据行 R2 加 X 锁，两个事务都需要对该表加 IX 锁，但是 IX 锁是兼容的，并且 IX 锁与行级的 X 锁也是兼容的，因此两个事务都能加锁成功，对同一个表中的两个数据行做修改。）</li></ul><h2 id="0x2-锁协议"><a href="#0x2-锁协议" class="headerlink" title="0x2.锁协议"></a>0x2.锁协议</h2><h4 id="1-三级封锁协议"><a href="#1-三级封锁协议" class="headerlink" title="1).三级封锁协议"></a>1).三级封锁协议</h4><ul><li><p>一级封锁协议</p><p>事务T要修改数据A时必须加X锁，直到T结束才释放锁。</p><p>可以解决丢失修改的问题，不能同时有两个事务对同一个数据进行修改，那么事务的修改就不会被覆盖。</p></li><li><p>二级封锁协议</p><p>在一级的基础上，要求读取数据A时必须加S锁，读取完马上释放S锁。</p><p>可以解决读脏数据问题，因为如果一个事务在对数据A进行修改，根据1级封锁协议，会加X锁，那么就不能再加S锁了，也就是不会读入脏数据。</p></li><li><p>三级封锁协议</p><p>在二级的基础上，要求读取数据A时必须加S锁，直到事务结束了才能释放S锁。</p><p>可以解决不可重复读的问题，因为读取A时，其他事务不能对A加X锁，从而避免了在读的期间数据发生改变。</p></li></ul><h4 id="2-两段锁协议"><a href="#2-两段锁协议" class="headerlink" title="2).两段锁协议"></a>2).两段锁协议</h4><p>加锁和解锁分成两个阶段进行。</p><p>可串行化调度是指通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。串行执行的事务互不干扰，不会出现并发一致性问题。</p><p>事务遵循两段锁协议是保证可串行化调度的充分条件。例如以下操作满足两段锁协议，它是可串行化调度。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lock-x(A)...lock-s(B)...lock-s(C)...unlock(A)...unlock(C)...unlock(B)</span><br></pre></td></tr></table></figure><p>但不是必要条件，例如以下操作不满足两段锁协议，但它还是可串行化调度。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lock-x(A)...unlock(A)...lock-s(B)...unlock(B)...lock-s(C)...unlock(C)</span><br></pre></td></tr></table></figure><p>MySQL的InnoDB存储引擎采用两段锁协议，会根据隔离级别在需要的时候自动加锁，并且所有的锁都是在同一时刻被释放，这也被称为隐式锁定。</p><p>InnoDB也可使用语句进行显式加锁</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">LOCK</span> <span class="keyword">In</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span>;</span><br><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure><h2 id="0x3-隔离级别"><a href="#0x3-隔离级别" class="headerlink" title="0x3.隔离级别"></a>0x3.隔离级别</h2><h4 id="1-未提交读-READ-UNCOMMITTED"><a href="#1-未提交读-READ-UNCOMMITTED" class="headerlink" title="1).未提交读(READ UNCOMMITTED)"></a>1).未提交读(READ UNCOMMITTED)</h4><p>事务中的修改，即使没有提交，对其他事务也是可见的。</p><h4 id="2-提交读-READ-COMMITTED"><a href="#2-提交读-READ-COMMITTED" class="headerlink" title="2).提交读(READ COMMITTED)"></a>2).提交读(READ COMMITTED)</h4><p>一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其他事务是不可见的。</p><h4 id="3-可重复读-REPEATABLE-READ"><a href="#3-可重复读-REPEATABLE-READ" class="headerlink" title="3).可重复读(REPEATABLE READ)"></a>3).可重复读(REPEATABLE READ)</h4><p>保证在同一个事务中多次读取同一数据的结果是一样的。</p><h4 id="4-序列化（SERIALIZABLE）"><a href="#4-序列化（SERIALIZABLE）" class="headerlink" title="4).序列化（SERIALIZABLE）"></a>4).序列化（SERIALIZABLE）</h4><p>强制事务串行执行，这样多个事务互不干扰，不会出现并发一致性问题。</p><p>该隔离级别需要加锁实现，使用加锁机制保证同一时间只有一个事务执行，也就是保证事务串行执行。</p><p>隔离能解决的并发一致性问题如下所示：</p><table><thead><tr><th align="center"></th><th align="center">脏读</th><th align="center">不可重复读</th><th align="center">幻读</th></tr></thead><tbody><tr><td align="center">未提交读</td><td align="center">❌</td><td align="center">❌</td><td align="center">❌</td></tr><tr><td align="center">提交读</td><td align="center">✔️</td><td align="center">❌</td><td align="center">❌</td></tr><tr><td align="center">可重复读</td><td align="center">✔️</td><td align="center">✔️</td><td align="center">❌</td></tr><tr><td align="center">序列化</td><td align="center">✔️</td><td align="center">✔️</td><td align="center">✔️</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;p&gt;锁的类型和数据库事务隔离级别。&lt;/p&gt;</summary>
    
    
    
    <category term="Database" scheme="https://blog.eganx.cn/categories/Database/"/>
    
    
    <category term="DB" scheme="https://blog.eganx.cn/tags/DB/"/>
    
    <category term="lock" scheme="https://blog.eganx.cn/tags/lock/"/>
    
  </entry>
  
  <entry>
    <title>数据库基础--并发一致性问题</title>
    <link href="https://blog.eganx.cn/2022/11/19/DB_base_Concurrency_consistency/"/>
    <id>https://blog.eganx.cn/2022/11/19/DB_base_Concurrency_consistency/</id>
    <published>2022-11-19T14:12:54.000Z</published>
    <updated>2022-12-31T02:54:27.732Z</updated>
    
    <content type="html"><![CDATA[<p>在并发环境下，事务的隔离性很难保证，因此会出现很多并发一致性问题。产生并发不一致性问题的主要原因是破坏了事务的隔离性，解决方法是通过并发控制来保证隔离性。</p><span id="more"></span><h2 id="0x0-丢失修改"><a href="#0x0-丢失修改" class="headerlink" title="0x0.丢失修改"></a>0x0.丢失修改</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">┌──────────┐     ┌──────────┐</span><br><span class="line">│ T1 Start │     │ T2 Start │</span><br><span class="line">└─────┬────┘     └─────┬────┘</span><br><span class="line">      │                │</span><br><span class="line">      ▼                │</span><br><span class="line">┌──────────┐           │</span><br><span class="line">│Write A&#x3D;10│           │</span><br><span class="line">└─────┬────┘           │</span><br><span class="line">      │                ▼</span><br><span class="line">      │          ┌──────────┐</span><br><span class="line">      │          │Write A&#x3D;20│</span><br><span class="line">      │          └─────┬────┘</span><br><span class="line">      │                │</span><br><span class="line">      ▼                ▼</span><br><span class="line">┌──────────┐     ┌──────────┐</span><br><span class="line">│  T1 End  │     │  T2 End  │</span><br><span class="line">└──────────┘     └──────────┘</span><br><span class="line">  A&#x3D;20 A&#x3D;20</span><br></pre></td></tr></table></figure><p>丢失修改指一个事务的更新操作被另外一个事务的更新操作替换。一般在现实生活中常会遇到，例如：T1 和 T2 两个事务都对一个数据进行修改，T1 先修改并提交生效，T2 随后修改，T2 的修改覆盖了 T1 的修改。最终<code>A=20</code>，T1的修改丢失。</p><h2 id="0x1-读脏数据"><a href="#0x1-读脏数据" class="headerlink" title="0x1.读脏数据"></a>0x1.读脏数据</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">┌──────────┐     ┌──────────┐</span><br><span class="line">│ T1 Start │     │ T2 Start │</span><br><span class="line">└─────┬────┘     └─────┬────┘</span><br><span class="line">      │                │</span><br><span class="line">      ▼                │</span><br><span class="line">┌──────────┐           │</span><br><span class="line">│ Read A&#x3D;10│           │</span><br><span class="line">└─────┬────┘           │</span><br><span class="line">      │                │</span><br><span class="line">      ▼                │</span><br><span class="line">┌──────────┐           │</span><br><span class="line">│Write A&#x3D;20│           │</span><br><span class="line">└─────┬────┘           ▼</span><br><span class="line">      │          ┌──────────┐</span><br><span class="line">      │          │ Read A&#x3D;20│</span><br><span class="line">      ▼          └─────┬────┘</span><br><span class="line">┌──────────┐           │</span><br><span class="line">│ Rollback │           │</span><br><span class="line">└─────┬────┘           │</span><br><span class="line">      │                │</span><br><span class="line">      ▼                ▼</span><br><span class="line">┌──────────┐     ┌──────────┐</span><br><span class="line">│  T1 End  │     │  T2 End  │</span><br><span class="line">└──────────┘     └──────────┘</span><br><span class="line">    A&#x3D;10             A&#x3D;20</span><br></pre></td></tr></table></figure><p>读脏数据指在不同的事务下，当前事务可以读到另外事务未提交的数据。例如：T1 修改一个数据但未提交，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是脏数据。</p><h2 id="0x2-不可重复读"><a href="#0x2-不可重复读" class="headerlink" title="0x2.不可重复读"></a>0x2.不可重复读</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">┌──────────┐     ┌──────────┐</span><br><span class="line">│ T1 Start │     │ T2 Start │</span><br><span class="line">└─────┬────┘     └─────┬────┘</span><br><span class="line">      │                │</span><br><span class="line">      │                ▼</span><br><span class="line">      │          ┌──────────┐</span><br><span class="line">      │          │ Read A&#x3D;10│</span><br><span class="line">      │          └─────┬────┘</span><br><span class="line">      ▼                │</span><br><span class="line">┌──────────┐           │</span><br><span class="line">│Write A&#x3D;20│           │</span><br><span class="line">└─────┬────┘           │</span><br><span class="line">      │                │</span><br><span class="line">      │                ▼</span><br><span class="line">      │          ┌──────────┐</span><br><span class="line">      │          │ Read A&#x3D;20│</span><br><span class="line">      │          └─────┬────┘</span><br><span class="line">      │                │</span><br><span class="line">      │                │</span><br><span class="line">      │                │</span><br><span class="line">      ▼                ▼</span><br><span class="line">┌──────────┐     ┌──────────┐</span><br><span class="line">│  T1 End  │     │  T2 End  │</span><br><span class="line">└──────────┘     └──────────┘</span><br><span class="line">    A&#x3D;20             A&#x3D;20</span><br></pre></td></tr></table></figure><p>不可重复读指在一个事务内多次读取同一数据集合。在这一事务还未结束前，另一事务也访问了该同一数据集合并做了修改，由于第二个事务的修改，第一次事务的两次读取的数据可能不一致。例如：T2 读取一个数据，T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同。</p><h2 id="0x3-幻影读"><a href="#0x3-幻影读" class="headerlink" title="0x3.幻影读"></a>0x3.幻影读</h2><p>幻读本质上也属于不可重复读的情况，T1 读取某个范围的数据，T2 在这个范围内插入新的数据，T1 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在并发环境下，事务的隔离性很难保证，因此会出现很多并发一致性问题。产生并发不一致性问题的主要原因是破坏了事务的隔离性，解决方法是通过并发控制来保证隔离性。&lt;/p&gt;</summary>
    
    
    
    <category term="Database" scheme="https://blog.eganx.cn/categories/Database/"/>
    
    
    <category term="DB" scheme="https://blog.eganx.cn/tags/DB/"/>
    
    <category term="concurrency consistency" scheme="https://blog.eganx.cn/tags/concurrency-consistency/"/>
    
  </entry>
  
  <entry>
    <title>数据库基础--事务</title>
    <link href="https://blog.eganx.cn/2022/11/19/DB_base_%20transaction/"/>
    <id>https://blog.eganx.cn/2022/11/19/DB_base_%20transaction/</id>
    <published>2022-11-19T04:45:22.000Z</published>
    <updated>2022-12-31T02:54:23.744Z</updated>
    
    <content type="html"><![CDATA[<p><strong>数据库事务</strong>（简称：<strong>事务</strong>）是数据库管理系统执行过程中的一个逻辑单位，由一个有限的数据库操作序列构成。</p><span id="more"></span><h2 id="0x0-事务"><a href="#0x0-事务" class="headerlink" title="0x0.事务"></a>0x0.事务</h2><p>事务是指满足ACID特性的一组操作，可以通过Commit提交一个事务，也可以使用Rollback进行回滚。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">             ┌──────────────────────┐              ┌──────────┐</span><br><span class="line">             │                      │              │          │</span><br><span class="line">             │ insert，update，delete│              │  commit  │</span><br><span class="line">             │                      │              │          │</span><br><span class="line">             └─┬──────────────────┬─┘              └─────┬────┘</span><br><span class="line">               │                  │                      │</span><br><span class="line"></span><br><span class="line">               │                  │                      │</span><br><span class="line">               │                  │                      │</span><br><span class="line">               │</span><br><span class="line">┌────────┐          ┌────────┐    │      ┌────────┐      │     ┌────────┐</span><br><span class="line">│        │     │    │┼┼┼┼┼┼┼┼│    │      │┼┼┼┼┼┼┼┼│      │     │        │</span><br><span class="line">│        ├─────┴───►├┼┼┼┼┼┼┼┼┼────┴─────►├┼┼┼┼┼┼┼┼┼──────┴────►│        │</span><br><span class="line">│        │          │┼┼┼┼┼┼┼┼│           │┼┼┼┼┼┼┼┼│            │        │</span><br><span class="line">└────────┘          └────┼───┘           └────┼───┘            └────┬───┘</span><br><span class="line"> ▲  ▲  ▲                 │                    │                     │</span><br><span class="line"> │  │  │                 │                    │                     │</span><br><span class="line"> │  │  └─────────────────┘                    │                     │</span><br><span class="line"> │  │                                         │                     │</span><br><span class="line"> │  └─────────────────────────────────────────┘                     │</span><br><span class="line"> │                                                                  │</span><br><span class="line"> └──────────────────────────────┬───────────────────────────────────┘</span><br><span class="line">                                │</span><br><span class="line"></span><br><span class="line">                                │</span><br><span class="line">                     ┌──────────┴────────────┐</span><br><span class="line">                     │                       │</span><br><span class="line">                     │   Rollback or Error   │</span><br><span class="line">                     │                       │</span><br><span class="line">                     └───────────────────────┘</span><br><span class="line">*注：空白方块表示一致性状态，阴影方块表示中间状态。</span><br></pre></td></tr></table></figure><h2 id="0x1-ACID"><a href="#0x1-ACID" class="headerlink" title="0x1.ACID"></a>0x1.ACID</h2><h4 id="1-原子性-Atomicity"><a href="#1-原子性-Atomicity" class="headerlink" title="1).原子性(Atomicity)"></a>1).原子性(Atomicity)</h4><p>事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。</p><p>回滚可以用回滚日志（Undo Log）来实现，回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。</p><h4 id="2-一致性-Consistency"><a href="#2-一致性-Consistency" class="headerlink" title="2).一致性(Consistency)"></a>2).一致性(Consistency)</h4><p>数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对同一个数据的读取结果都是相同的。</p><h4 id="3-隔离性-Isolation"><a href="#3-隔离性-Isolation" class="headerlink" title="3).隔离性(Isolation)"></a>3).隔离性(Isolation)</h4><p>一个事务所做的修改子最终提交以前，对其他事务是不可见的。</p><h4 id="4-持久性-Durability"><a href="#4-持久性-Durability" class="headerlink" title="4).持久性(Durability)"></a>4).持久性(Durability)</h4><p>一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统崩溃，事务执行的结果也不能丢失。</p><p>系统发生崩溃可以用重做日志（Redo Log）进行恢复，从而实现持久性。与回滚日志记录数据的逻辑修改不同，重做日志记录的是数据页的物理修改。</p><blockquote><p>事务的 ACID 特性概念简单，但不是很好理解，主要是因为这几个特性不是一种平级关系：</p><ul><li>只有满足一致性，事务的执行结果才是正确的。</li><li>在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定能满足一致性。</li><li>在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性。</li><li>事务满足持久化是为了能应对系统崩溃的情况。</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">┌───────────┐  Concurrency&#x2F;Non concurrent</span><br><span class="line">│ Atomicity ├───────┐</span><br><span class="line">└───────────┘       │   ┌───────────┐</span><br><span class="line">                    ├──►│Consistency├───────► Correct execution</span><br><span class="line">┌───────────┐       │   └───────────┘</span><br><span class="line">│ Isolation ├───────┘</span><br><span class="line">└───────────┘  Concurrency</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                        ┌───────────┐</span><br><span class="line">                        │ Durability├───────► Dealing with system crashes</span><br><span class="line">                        └───────────┘</span><br></pre></td></tr></table></figure><h4 id="AutoCommit"><a href="#AutoCommit" class="headerlink" title="AutoCommit"></a>AutoCommit</h4><p>MySQL 默认采用自动提交模式。也就是说，如果不显式使用<code>START TRANSACTION</code>语句来开始一个事务，那么每个查询操作都会被当做一个事务并自动提交。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;数据库事务&lt;/strong&gt;（简称：&lt;strong&gt;事务&lt;/strong&gt;）是数据库管理系统执行过程中的一个逻辑单位，由一个有限的数据库操作序列构成。&lt;/p&gt;</summary>
    
    
    
    <category term="Database" scheme="https://blog.eganx.cn/categories/Database/"/>
    
    
    <category term="DB" scheme="https://blog.eganx.cn/tags/DB/"/>
    
    <category term="transaction" scheme="https://blog.eganx.cn/tags/transaction/"/>
    
  </entry>
  
  <entry>
    <title>Golang GC(Garbage Collection)</title>
    <link href="https://blog.eganx.cn/2022/11/16/Go_GC/"/>
    <id>https://blog.eganx.cn/2022/11/16/Go_GC/</id>
    <published>2022-11-16T14:12:29.000Z</published>
    <updated>2022-12-28T02:45:00.841Z</updated>
    
    <content type="html"><![CDATA[<p>内存管理是程序员开发应用的一大难题。传统的系统级编程语言（主要指C/C++）中，程序开发者必须对内存小心的进行管理操作，控制内存的申请及释放。 因为稍有不慎，就可能产生内存泄露问题，这种问题不易发现并且难以定位，一直成为困扰程序开发者的噩梦。</p><span id="more"></span><h2 id="0x0-Garbage-Collection"><a href="#0x0-Garbage-Collection" class="headerlink" title="0x0.Garbage Collection"></a>0x0.Garbage Collection</h2><p>GC(Garbage Collection)，垃圾回收是一种自动内存管理机制。当某个程序占用的一部分内存空间不再被这个程序访问时，这个程序会借助<strong>垃圾回收</strong>算法向操作系统归还这部分内存空间。垃圾回收器可以减轻程序员的负担，也减少程序中的错误。垃圾回收最早起源于<a href="https://zh.wikipedia.org/wiki/LISP">LISP</a>语言。</p><p>垃圾回收器的执行过程通常被划分成两个独立的组件：</p><ul><li>赋值器：指代用户态的代码。对于垃圾回收器来说，用户态的代码只是在修改对象之间的引用关系。</li><li>回收器：负责执行垃圾回收的代码。</li></ul><h2 id="0x1-根对象"><a href="#0x1-根对象" class="headerlink" title="0x1.根对象"></a>0x1.根对象</h2><p>根集合是垃圾回收器在标记过程中最先检查的对象，包括：</p><ul><li>全局变量</li><li>执行栈：每个goroutine都包含自己的执行栈，包含栈上的变量以及指向分配的堆内存区块的指针。</li><li>寄存器</li></ul><h2 id="0x2-GC实现方式"><a href="#0x2-GC实现方式" class="headerlink" title="0x2.GC实现方式"></a>0x2.GC实现方式</h2><p>GC的常见实现方式有追踪式GC和引用计数式GC。</p><ul><li><p>追踪式GC</p><p>从根对象出发，根据对象之间的引用信息，逐步扫描直至扫完整个堆并确定保留的对象，从而回收所有可回收的对象。</p></li><li><p>引用计数式GC</p><p>每个对象自身包含一个被引用的计数器，当计数器归零时自动得到回收。</p></li></ul><p>Go 的 GC 目前使用的是无分代（对象没有代际之分）、非移动（回收过程中不对对象进行移动与整理）、并发（与用户代码并发执行）的三色标记清扫算法。属于追踪式GC的一种。</p><h2 id="0x3-三色标记法"><a href="#0x3-三色标记法" class="headerlink" title="0x3.三色标记法"></a>0x3.三色标记法</h2><p>golang的垃圾回收是基于标记清扫算法，这种算法需要进行STW(stop the world)，这个过程会导致程序卡顿，所以频繁的GC是会严重影响程序性能的。golang在此基础上进行了改进，通过<strong>三色标记清扫算法</strong>和<strong>写屏障</strong>来减少STW的时间。</p><h4 id="GC的四个过程"><a href="#GC的四个过程" class="headerlink" title="GC的四个过程"></a>GC的四个过程</h4><ul><li>1、栈扫描（开始时STW），所有对象开始都是白色。</li><li>2、从root开始找到所有可达对象（所有可以找到的对象），标记成灰色，放入待处理队列。</li><li>3、遍历灰色对象队列，将其<strong>引用对象</strong>标记成灰色放入待处理队列，自身标记为黑色。</li><li>4、清除（并发）循环步骤3直到灰色队列为空。此时所有的引用对象都被标记为黑色，所有不可达的对象依然是白色，白色的就是需要进行回收的对象。</li></ul><p>三色标记法相对于普通的标记清扫，减少了STW的时间，这主要得益于标记过程是”on-the-fly”的，标记过程中是不需要STW的，它与程序是并发执行的，大大缩短了STW的时间。Golang gc优化的核心就是尽量使得STW的时间越来越短。</p><table><thead><tr><th align="center">阶段</th><th align="center">说明</th><th align="center">赋值器状态</th></tr></thead><tbody><tr><td align="center">SweepTermination</td><td align="center">清扫终止阶段，为下一个阶段的并发标记做准备工作，启动写屏障</td><td align="center">STW</td></tr><tr><td align="center">Mark</td><td align="center">扫描标记阶段，与赋值器并发执行，写屏障开启</td><td align="center">并发</td></tr><tr><td align="center">MarkTermination</td><td align="center">标记终止阶段，保证一个周期内标记任务完成，停止写屏障</td><td align="center">STW</td></tr><tr><td align="center">GCoff</td><td align="center">内存清扫阶段，将需要回收的内存归还到堆中，写屏障关闭</td><td align="center">并发</td></tr><tr><td align="center">GCoff</td><td align="center">内存归还阶段，将过多的内存归还给操作系统，写屏障关闭</td><td align="center">并发</td></tr></tbody></table><h4 id="写屏障"><a href="#写屏障" class="headerlink" title="写屏障"></a>写屏障</h4><p>当标记的程序是并发执行的，有可能在标记过程中，有新的引用产生，可能会导致误清扫。</p><p>清扫开始前，标记为黑色的对象引用一个新申请的对象，此时它肯定是白色的，而黑色对象不会被再次扫描，那么这个白色对象无法被扫描变成灰色、黑色，它最终会被清扫，而实际上它不应该被清扫。</p><p>golang采取了写屏障，其作用就是为了避免这类误清扫问题。写屏障在内存写操作前，维护一个约束，从而确保清扫开始前，黑色的对象不能引用白色对象。</p><h2 id="0x4-触发GC的时机"><a href="#0x4-触发GC的时机" class="headerlink" title="0x4.触发GC的时机"></a>0x4.触发GC的时机</h2><p>Go 语言中对 GC 的触发时机存在两种形式：</p><ol><li><strong>主动触发</strong>，通过调用 runtime.GC 来触发 GC，此调用阻塞式地等待当前 GC 运行完毕。</li><li><strong>被动触发</strong>，分为两种方式：<ul><li>使用系统监控，当超过两分钟没有产生任何 GC 时，强制触发 GC。</li><li>使用步调（Pacing）算法，其核心思想是控制内存增长的比例，当前内存分配达到一定比例则触发。</li></ul></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;内存管理是程序员开发应用的一大难题。传统的系统级编程语言（主要指C/C++）中，程序开发者必须对内存小心的进行管理操作，控制内存的申请及释放。 因为稍有不慎，就可能产生内存泄露问题，这种问题不易发现并且难以定位，一直成为困扰程序开发者的噩梦。&lt;/p&gt;</summary>
    
    
    
    <category term="Golang" scheme="https://blog.eganx.cn/categories/Golang/"/>
    
    
    <category term="GC" scheme="https://blog.eganx.cn/tags/GC/"/>
    
    <category term="go" scheme="https://blog.eganx.cn/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>Go反射(reflect)</title>
    <link href="https://blog.eganx.cn/2022/11/13/Go_reflect/"/>
    <id>https://blog.eganx.cn/2022/11/13/Go_reflect/</id>
    <published>2022-11-13T11:21:43.000Z</published>
    <updated>2022-12-27T09:04:09.169Z</updated>
    
    <content type="html"><![CDATA[<p>不同语言的反射模型不尽相同。闲来无事，看看Go的反射机制。</p><span id="more"></span><h2 id="0x0-反射的定义"><a href="#0x0-反射的定义" class="headerlink" title="0x0.反射的定义"></a>0x0.反射的定义</h2><p>维基百科上反射的定义：</p><blockquote><p>在计算机科学中，反射是指电脑程序在运行时（runtime）可以访问、检测和修改它本身状态或行为的一种能力。用比喻来说，反射就是程序在运行的时候能够“观察”并且修改自己的行为。</p></blockquote><p>Go 语言提供了一种机制在运行时更新变量和检查它们的值、调用它们的方法，但是在编译时并不知道这些变量的具体类型，这称为反射机制。</p><h2 id="0x1-反射的实现"><a href="#0x1-反射的实现" class="headerlink" title="0x1.反射的实现"></a>0x1.反射的实现</h2><p>反射通过接口的类型信息实现。反射是建立在类型的基础上。</p><p>Go在reflect包中定义了各种类型，实现了反射的各种函数，通过它们可以在运行时检测类型的信息和改变类型的值。</p><h4 id="1-反射的基本函数"><a href="#1-反射的基本函数" class="headerlink" title="1).反射的基本函数"></a>1).反射的基本函数</h4><p>reflect 包里定义了一个接口和一个结构体，即 <code>reflect.Type</code> 和 <code>reflect.Value</code>，它们提供很多函数来获取存储在接口里的类型信息。</p><p><code>reflect.Type</code> 主要提供关于类型相关的信息，所以它和 <code>_type</code> 关联比较紧密；<code>reflect.Value</code> 则结合 <code>_type</code> 和 <code>data</code> 两者，因此我们可以获取甚至改变类型的值。</p><p>reflect 包中提供了两个基础的关于反射的函数来获取上述的接口和结构体：</p><blockquote><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TypeOf</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">Type</span></span> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ValueOf</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">Value</span></span></span><br></pre></td></tr></table></figure></blockquote><p><code>TypeOf</code> 函数用来提取一个接口中值的类型信息。由于它的输入参数是一个空的 <code>interface&#123;&#125;</code>，调用此函数时，实参会先被转化为 <code>interface&#123;&#125;</code>类型。这样，实参的类型信息、方法集、值信息都存储到 <code>interface&#123;&#125;</code> 变量里了。</p><p><code>fmt.Printf()</code> 函数，如果使用 <code>%T</code> 来作为格式参数，输出的是 <code>reflect.TypeOf</code> 的结果，也就是动态类型。</p><p><code>TypeOf()</code> 函数返回一个接口，这个接口定义了一系列方法，利用这些方法可以获取关于类型的所有信息； <code>ValueOf()</code> 函数返回一个结构体变量，包含类型信息以及实际值。</p><h4 id="2-反射的三大定律"><a href="#2-反射的三大定律" class="headerlink" title="2).反射的三大定律"></a>2).反射的三大定律</h4><ul><li><p> Reflection goes from interface value to reflection object.</p></li><li><p> Reflection goes from reflection object to interface value.</p></li><li><p>To modify a reflection object, the value must be settable.</p><p><code>接口型变量</code> 和 <code>反射类型对象</code> 可以相互转化。如果想要操作原变量，反射变量 <code>Value</code> 必须要 hold 住原变量的地址才行。</p></li></ul><h2 id="0x2-反射的使用场景"><a href="#0x2-反射的使用场景" class="headerlink" title="0x2.反射的使用场景"></a>0x2.反射的使用场景</h2><p>使用反射的常见场景有以下两种：</p><ol><li>不能明确接口调用哪个函数，需要根据传入的参数在运行时决定。</li><li>不能明确传入函数的参数类型，需要在运行时处理任意对象。</li></ol><blockquote><p> 反射对性能影响还是比较大的，比正常代码运行速度慢一到两个数量级。关键代码避免使用反射特性。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;不同语言的反射模型不尽相同。闲来无事，看看Go的反射机制。&lt;/p&gt;</summary>
    
    
    
    <category term="Golang" scheme="https://blog.eganx.cn/categories/Golang/"/>
    
    
    <category term="go" scheme="https://blog.eganx.cn/tags/go/"/>
    
    <category term="reflect" scheme="https://blog.eganx.cn/tags/reflect/"/>
    
  </entry>
  
  <entry>
    <title>Mongo cluster(docker compose)</title>
    <link href="https://blog.eganx.cn/2022/11/10/DB_Mongo_0/"/>
    <id>https://blog.eganx.cn/2022/11/10/DB_Mongo_0/</id>
    <published>2022-11-10T13:12:34.000Z</published>
    <updated>2022-12-31T02:39:20.851Z</updated>
    
    <content type="html"><![CDATA[<p>初次使用docker compose搭建mongo集群，记录一下。虽然问题还很多，但至少跑起来了。。。</p><span id="more"></span><h2 id="0x0-文件目录结构"><a href="#0x0-文件目录结构" class="headerlink" title="0x0.文件目录结构"></a>0x0.文件目录结构</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mongodb</span><br><span class="line">└── mongo</span><br><span class="line">    ├── data</span><br><span class="line">    │   ├── hosts</span><br><span class="line">    │   └── mongod.conf</span><br><span class="line">    └── docker-compose.yml</span><br></pre></td></tr></table></figure><h2 id="0x1-mongod-conf"><a href="#0x1-mongod-conf" class="headerlink" title="0x1.mongod.conf"></a>0x1.mongod.conf</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemLog:</span><br><span class="line">  destination: file</span><br><span class="line">  path: &#x2F;data&#x2F;log&#x2F;mongo.log</span><br><span class="line">  logAppend: true</span><br><span class="line">storage:</span><br><span class="line">  dbPath: &#x2F;data&#x2F;db</span><br><span class="line">net:</span><br><span class="line">  bindIp: 0.0.0.0</span><br><span class="line">replication:</span><br><span class="line">  replSetName: rs0</span><br></pre></td></tr></table></figure><h2 id="0x2-hosts"><a href="#0x2-hosts" class="headerlink" title="0x2.hosts"></a>0x2.hosts</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1localhost</span><br><span class="line">255.255.255.255broadcasthost</span><br><span class="line">::1                     localhost</span><br></pre></td></tr></table></figure><h2 id="0x3-docker-compose-yml"><a href="#0x3-docker-compose-yml" class="headerlink" title="0x3.docker-compose.yml"></a>0x3.docker-compose.yml</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">db:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">mongo1:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mongo</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">mongo1</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">mongod</span> <span class="string">--config</span> <span class="string">/etc/mongod.conf</span></span><br><span class="line">    <span class="attr">expose:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">27017</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./data/mongo1/db:/data/db</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./data/mongo1/configdb:/data/configdb</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./data/mongo1/log:/data/log</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./data/mongod.conf:/etc/mongod.conf</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./data/hosts:/etc/hosts</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;27017:27017&quot;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">db</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">mongo2:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mongo</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">mongo2</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">mongod</span> <span class="string">--config</span> <span class="string">/etc/mongod.conf</span></span><br><span class="line">    <span class="attr">expose:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">27017</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./data/mongo2/db:/data/db</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./data/mongo2/configdb:/data/configdb</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./data/mongo2/log:/data/log</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./data/mongod.conf:/etc/mongod.conf</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./data/hosts:/etc/hosts</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;27018:27017&quot;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">db</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">mongo3:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mongo</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">mongo3</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">mongod</span> <span class="string">--config</span> <span class="string">/etc/mongod.conf</span></span><br><span class="line">    <span class="attr">expose:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">27017</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./data/mongo3/db:/data/db</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./data/mongo3/configdb:/data/configdb</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./data/mongo3/log:/data/log</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./data/mongod.conf:/etc/mongod.conf</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./data/hosts:/etc/hosts</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;27019:27017&quot;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">db</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="0x4-开始部署"><a href="#0x4-开始部署" class="headerlink" title="0x4.开始部署"></a>0x4.开始部署</h2><ul><li>进入docker-compose.yml文件所在目录</li><li>执行命令：<code>docker compose -f docker-compose.yml up -d</code></li></ul><h2 id="0x5-建立副本集"><a href="#0x5-建立副本集" class="headerlink" title="0x5.建立副本集"></a>0x5.建立副本集</h2><ul><li><p>进入mongo容器：<code>docker exec -it mongo1 bash</code></p></li><li><p>进入mongo：<code>mongosh</code> ,老版本的mongo到指令是<code>mongo</code></p></li><li><p>切换管理员用户：<code>use admin</code></p></li><li><p>初始化副本集：<code>rs.initiate()</code>,无参初始化时，会默认当前节点PRIMARY节点</p></li><li><p>添加副节点：<code>rs.add(&#39;mongo2:27017&#39;)</code></p></li><li><p>添加仲裁节点：<code>rs.addArb(&#39;mongo3:27017&#39;)</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 添加仲裁节点要是报错，可以试试运行以下代码</span><br><span class="line"> db.adminCommand(&#123;</span><br><span class="line">  &quot;setDefaultRWConcern&quot; : 1,</span><br><span class="line">  &quot;defaultWriteConcern&quot; : &#123;</span><br><span class="line">    &quot;w&quot; : 2</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>查看副本集配置信息：<code>rs.conf()</code></p></li><li><p>查看副本集运行状态：<code>rs.status()</code></p></li></ul><p>要是需要修改配置，可以按照以下步骤来：</p><ul><li><code>cfg = rs.conf()</code></li><li><code>cfg.members[0].xxx = xxx</code></li><li><code>rs.reconfig(cfg)</code></li></ul><h2 id="0x6-验证副本集"><a href="#0x6-验证副本集" class="headerlink" title="0x6.验证副本集"></a>0x6.验证副本集</h2><p>切换节点查看同步状态：<code>rs.printReplicationInfo()</code></p><p>仅当建立了集合后副节点才会进行同步。</p><h2 id="0x7-外部连接"><a href="#0x7-外部连接" class="headerlink" title="0x7.外部连接"></a>0x7.外部连接</h2><p>准备使用Robo 3T(现在变成Studio 3T Free)连接数据库时，会有连接失败的异常，可以将WSL的IP地址写入电脑C盘hosts文件里：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">172.23.224.1mongo1</span><br><span class="line">172.23.224.1mongo2</span><br><span class="line">172.23.224.1mongo3</span><br></pre></td></tr></table></figure><p>然后使用以下链接来连接数据库</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mongo1:27017</span><br><span class="line">mongo2:27017</span><br><span class="line">mongo3:27017</span><br></pre></td></tr></table></figure><p>但是如果还是连接不上，或者重启后连接不上，可以将<code>mongo</code>容器的IP写到<code>mongo\data\hosts</code>文件里，容器的IP可以使用<code>docker inspect mongo1</code>来获取。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">172.30.0.2 mongo1</span><br><span class="line">172.30.0.3 mongo2</span><br><span class="line">172.30.0.4 mongo3</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;初次使用docker compose搭建mongo集群，记录一下。虽然问题还很多，但至少跑起来了。。。&lt;/p&gt;</summary>
    
    
    
    <category term="Database" scheme="https://blog.eganx.cn/categories/Database/"/>
    
    
    <category term="DB" scheme="https://blog.eganx.cn/tags/DB/"/>
    
    <category term="mongo" scheme="https://blog.eganx.cn/tags/mongo/"/>
    
  </entry>
  
  <entry>
    <title>Go语言中new和make的区别</title>
    <link href="https://blog.eganx.cn/2022/11/07/Go_New_and_Make/"/>
    <id>https://blog.eganx.cn/2022/11/07/Go_New_and_Make/</id>
    <published>2022-11-07T01:07:12.000Z</published>
    <updated>2022-12-27T09:04:20.424Z</updated>
    
    <content type="html"><![CDATA[<p>在Go语言中，make关键字在初始化的时候被频繁使用，之前写C# 的时候都是使用new关键字，Go中new关键字也是存在的。准备看看两者的区别。</p><span id="more"></span><h2 id="0x0-new"><a href="#0x0-new" class="headerlink" title="0x0.new"></a>0x0.new</h2><p><code>new</code>可以对类型进行内存创建和初始化，<strong>其返回值是所创建类型的指针引用</strong>。<code>new</code>会根据变量类型返回一个指向该类型的指针。</p><h2 id="0x1-make"><a href="#0x1-make" class="headerlink" title="0x1.make"></a>0x1.make</h2><p><code>make</code> 函数也是用于内存分配的，但是和<code>new</code>不同，仅支持 <code>slice</code>、<code>map</code>、<code>channel</code> 三种数据类型的内存创建，其返回值是所创建类型的本身，而不是新的指针引用。<code>make</code>不仅可以开辟一个内存，还能给这个内存的类型初始化其零值。</p><h2 id="0x2-总结"><a href="#0x2-总结" class="headerlink" title="0x2.总结"></a>0x2.总结</h2><ul><li>make和new都是golang用来分配内存的函数，且在堆上分配内存，make 即分配内存，也初始化内存。new只是将内存清零，并没有初始化内存。</li><li>make返回的还是引用类型本身；而new返回的是指向类型的指针。</li><li>make只能用来分配及初始化类型为slice，map，channel的数据；new可以分配任意类型的数据。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;在Go语言中，make关键字在初始化的时候被频繁使用，之前写C# 的时候都是使用new关键字，Go中new关键字也是存在的。准备看看两者的区别。&lt;/p&gt;</summary>
    
    
    
    <category term="Golang" scheme="https://blog.eganx.cn/categories/Golang/"/>
    
    
    <category term="make" scheme="https://blog.eganx.cn/tags/make/"/>
    
    <category term="new" scheme="https://blog.eganx.cn/tags/new/"/>
    
  </entry>
  
  <entry>
    <title>Windows10下WSL2和Docker的安装和配置</title>
    <link href="https://blog.eganx.cn/2022/11/06/Win10_WSL_Docker/"/>
    <id>https://blog.eganx.cn/2022/11/06/Win10_WSL_Docker/</id>
    <published>2022-11-06T04:12:32.000Z</published>
    <updated>2022-12-17T13:27:04.083Z</updated>
    
    <content type="html"><![CDATA[<p>最近需要搭建mongo集群，看教程说使用docker比较好部署，准备在公司电脑（ThinkPad）上先试一下，所以需要安装一下WSL和docker。自己也没有在Windows环境下使用过docker，所以记录一下。</p><span id="more"></span><h2 id="0x0-Windows-Terminal"><a href="#0x0-Windows-Terminal" class="headerlink" title="0x0.Windows Terminal"></a>0x0.Windows Terminal</h2><p>用过 <code>Windows</code> 默认终端的都知道，真的不怎么美观。 微软也逐渐意识到这个问题，并在 <code>Build2019</code> 大会上发布了 新一代 <code>Windows</code> 终端程序：<code>Windows Terminal</code> 。</p><p><code>Windows Terminal</code> 是一款新式、快速、高效、强大且高效的终端应用程序，适用于命令行工具和命令提示符，PowerShell和 WSL 等 Shell 用户。主要功能包括多个选项卡、窗格、Unicode、和 UTF-8 字符支持，GPU 加速文本渲染引擎以及自定义主题、样式和配置。</p><p>而且这个是开源的，如果不喜欢在Microsoft Store里安装软件，可以直接去GitHub里下载，这里给出GitHub项目地址：<code>https://github.com/microsoft/terminal</code>。</p><h2 id="0x1-Windows-WSL2"><a href="#0x1-Windows-WSL2" class="headerlink" title="0x1.Windows WSL2"></a>0x1.Windows WSL2</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1).概述"></a>1).概述</h3><p>WSL是windows推出的可让开发人员不需要安装虚拟机（vmware，virtbox）或者设置双系统启动就可以原生支持运行GNU/Linux的系统环境，简称WSL子系统。目前最新的版本是WSL2，在原先的基础上提高了文件系统的性能并添加了完全的的系统调用支持。WSL2使用全新体系架构使其能真正的运行一个Linux内核。</p><h3 id="2-安装"><a href="#2-安装" class="headerlink" title="2).安装"></a>2).安装</h3><ul><li>WSL2对系统版本有一定的要求：必须运行 Windows 10 版本 2004 及更高版本（内部版本 19041 及更高版本）或 Windows 11。</li><li>在 <code>控制面板</code>-<code>程序</code>- <code>启用或关闭 Windows 功能</code> 中勾选 <code>适用于 Linux 的 Windows 子系统</code>以及 <code>虚拟机平台</code>(wsl2 需要)。<font color=red>此步骤完成后需要重启电脑。</font></li><li>打开微软商店应用，在搜索框中输入“Linux”或者“ubuntu”然后搜索，你可以看到搜索结果中有很多的 Linux 发行版可以选择。我选Ubuntu22.04<ul><li>有可能启动ubuntu报告<code>WslRegisterDistribution failed with error: 0x800701bc</code>是因为没有升级linux内核使用<code>wsl --update</code>下载更新即可。</li><li>在商店安装后并没有完全完成子系统安装，还需要运行一次Ubuntu来完成内核下载以及用户名密码的设置。</li></ul></li><li>启动WSL2<ul><li><code>Windows Terminal</code>里面使用<code>wsl -l</code>命令来查看所有的子系统。使用<code>wsl --set-default-version 2</code>设置为每个安装的发行版默认WSL2启动。</li></ul></li></ul><h3 id="3-导出Ubuntu-22-04到D盘下"><a href="#3-导出Ubuntu-22-04到D盘下" class="headerlink" title="3).导出Ubuntu-22.04到D盘下"></a>3).导出Ubuntu-22.04到D盘下</h3><p>这一步可以缓解一下C盘的压力，C盘没有压力的就当没看见这一步。</p><ul><li>查看已安装的Linux发行版: <code>wsl -l --all -v</code></li><li>导出Linux发行版tar文件到指定文件夹: <code>wsl --export Ubuntu-22.04 d:/wsl/ubuntu/wsl-ubuntu-22.04.tar</code></li><li>注销Ubuntu-22.04: <code>wsl --unregister Ubuntu-22.04</code></li><li>重新导入并安装WSL2到D盘: <code>wsl --import Ubuntu-22.04 d:/wsl/ubuntu/ d:/wsl/ubuntu/wsl-ubuntu-22.04.tar --version 2</code></li></ul><h2 id="0x2-Windows-Docker-Desktop"><a href="#0x2-Windows-Docker-Desktop" class="headerlink" title="0x2.Windows Docker Desktop"></a>0x2.Windows Docker Desktop</h2><p>这个没啥好说的，官网下载，直接安装就完了。官网地址传送：<code>https://www.docker.com/products/docker-desktop/</code>.</p><p>安装完成后，打开Docker Desktop的设置，找到<code>Resources-WSL Integration</code>，打开Enable integration with additional distors，将自己的WSL打开。这样docker就会跑在WSL上。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近需要搭建mongo集群，看教程说使用docker比较好部署，准备在公司电脑（ThinkPad）上先试一下，所以需要安装一下WSL和docker。自己也没有在Windows环境下使用过docker，所以记录一下。&lt;/p&gt;</summary>
    
    
    
    <category term="Database" scheme="https://blog.eganx.cn/categories/Database/"/>
    
    
    <category term="mongo" scheme="https://blog.eganx.cn/tags/mongo/"/>
    
    <category term="tool" scheme="https://blog.eganx.cn/tags/tool/"/>
    
  </entry>
  
  <entry>
    <title>Studio 3T Free跳过一个月Full product的登陆试用(Windows)</title>
    <link href="https://blog.eganx.cn/2022/11/05/Tool_Studio3t/"/>
    <id>https://blog.eganx.cn/2022/11/05/Tool_Studio3t/</id>
    <published>2022-11-05T14:32:12.000Z</published>
    <updated>2022-12-16T02:16:06.630Z</updated>
    
    <content type="html"><![CDATA[<p>当Robo 3T变成了Studio 3T Free，不想试用Studio 3T的Full product。只想使用Robo 3T Free(Robo 3T)，该如何跳过一个月Full product的登陆试用呢？</p><span id="more"></span><h2 id="0x0-尊重付费软件"><a href="#0x0-尊重付费软件" class="headerlink" title="0x0.尊重付费软件"></a>0x0.尊重付费软件</h2><p>Robo 3T作为常用的MongoDB GUI，现在变成了Studio 3T Free。依旧是免费，但是在Windows下初次打开Studio 3T软件时，会要求必须登陆，然后开始一个月的Full product trial。这个就很烦，我就只想用免费版的，毕竟免费版就可以满足我的需求。体验试用是好事，但是当这件事成为必选项时，就会让人很不爽😕</p><p>所以在不进行非正规手段进行软件破解时，该如何进行跳过登陆激活进行免费版的使用呢？</p><p>找到位于<code>C:\Windows\System32\drivers\ect</code>下的<code>hosts</code>文件，将下面两行添加进去。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1        update.studio3t.com</span><br><span class="line">127.0.0.1        license-portal-eb.studio3t.com</span><br></pre></td></tr></table></figure><p>然后重启Studio 3T时，Product activation弹窗就会跳过<code>Login/Register</code>这一步，直接到达<code>Finish</code>。Nice! 大功告成。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;当Robo 3T变成了Studio 3T Free，不想试用Studio 3T的Full product。只想使用Robo 3T Free(Robo 3T)，该如何跳过一个月Full product的登陆试用呢？&lt;/p&gt;</summary>
    
    
    
    <category term="Tool" scheme="https://blog.eganx.cn/categories/Tool/"/>
    
    
    <category term="tool" scheme="https://blog.eganx.cn/tags/tool/"/>
    
    <category term="studio3t" scheme="https://blog.eganx.cn/tags/studio3t/"/>
    
  </entry>
  
  <entry>
    <title>Go Context</title>
    <link href="https://blog.eganx.cn/2022/11/04/Go_Context/"/>
    <id>https://blog.eganx.cn/2022/11/04/Go_Context/</id>
    <published>2022-11-04T03:45:19.000Z</published>
    <updated>2022-12-05T10:54:58.287Z</updated>
    
    <content type="html"><![CDATA[<p>context是Go的一个标准库，中文一般叫做”上下文”。context主要是用来在goroutine之间传递上下午信息，包括取消信号、超时时间等。context.Context类型的值可以协调多个goroutine中的代码执行“取消”操作，并且可以存储键值对。而且还是并发安全的。与它协作可以在API的外部控制执行“取消”操作，比如取消一个HTTP请求的执行。</p><span id="more"></span><h2 id="0x0-context的作用"><a href="#0x0-context的作用" class="headerlink" title="0x0.context的作用"></a>0x0.context的作用</h2><p>在http server中，一个请求有可能会起若干个协程，这些goroutine有时候是需要共享请求的基本数据的，包括token，超时时间和取消信号等。当请求迟迟得不到回应或者此次请求被取消，可能是使用者关闭了浏览器或已经超过了请求方的超时时间，请求方直接放弃了这次请求的结果。这个时候，所有为这个请求工作的goroutine需要快速退出，因为工作成果变成了无意义的。在相关的goroutine退出后，系统可以回收相关资源。</p><p>正常关闭协程是采用<code>channel+select</code>方式来控制。但是当一个请求相关联的协程数量过多，且相互关联，能够同时关闭，可以使用context来实现。</p><blockquote><p><font color=ligblue>context用来解决goroutine之间退出通知、元数据传递的功能。    </font></p></blockquote><p>context的使用建议：</p><ul><li><p>不要将 Context 塞到结构体里。直接将 Context 类型作为函数的第一参数，而且一般都命名为 ctx。</p></li><li><p>不要向函数传入一个 nil 的 context，如果你实在不知道传什么，标准库给你准备好了一个 context：todo。</p></li><li><p>不要把本应该作为函数参数的类型塞到 context 中，context 存储的应该是一些共同的数据。例如：登陆的 session、cookie 等。</p></li><li><p>同一个 context 可能会被传递到多个 goroutine，别担心，context 是并发安全的。</p></li></ul><h3 id="1-传递共享的数据"><a href="#1-传递共享的数据" class="headerlink" title="1).传递共享的数据"></a>1).传递共享的数据</h3><p>对于web服务端开发，往往希望将一个请求处理的整个过程串起来，因此需要在函数调用的时候传递context。</p><p>context的常见创建函数：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建空白的根节点context</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Background</span><span class="params">()</span> <span class="title">Context</span></span> </span><br><span class="line"><span class="comment">// 创建子节点context</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithCancel</span><span class="params">(parent Context)</span> <span class="params">(ctx Context, cancel CancelFunc)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithDeadline</span><span class="params">(parent Context, deadline time.Time)</span> <span class="params">(Context, CancelFunc)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithTimeout</span><span class="params">(parent Context, timeout time.Duration)</span> <span class="params">(Context, CancelFunc)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithValue</span><span class="params">(parent Context, key, val <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">Context</span></span></span><br></pre></td></tr></table></figure><h3 id="2-取消goroutine"><a href="#2-取消goroutine" class="headerlink" title="2).取消goroutine"></a>2).取消goroutine</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">func_eg</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        ... <span class="comment">// 业务代码：1秒刷新1次</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">            <span class="comment">// 被取消，直接返回</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">case</span> &lt;-time.After(time.Second):</span><br><span class="line">            <span class="comment">// block 1 秒钟 </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main</span></span><br><span class="line">ctx, cancel := context.WithTimeout(context.Background(), time.Hour)</span><br><span class="line"><span class="keyword">go</span> func_eg(ctx)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端取消时，调用cancel函数</span></span><br><span class="line">cancel()</span><br></pre></td></tr></table></figure><p><code>cancel()</code>函数返回的context和cancelFun是分开的。context本身是没有cancel函数，保证取消函数只能由外部调用，防止子节点context调用取消函数，从而严格控制信息流从父节点context流向子节点context。</p><h3 id="3-防止goroutine泄露"><a href="#3-防止goroutine泄露" class="headerlink" title="3).防止goroutine泄露"></a>3).防止goroutine泄露</h3><p>某些goroutine处于无限循环状态，若无外部取消函数，会造成系统资源泄露。</p><h2 id="0x1-context详细解析"><a href="#0x1-context详细解析" class="headerlink" title="0x1.context详细解析"></a>0x1.context详细解析</h2><table><thead><tr><th>类型</th><th>名称</th><th>作用</th></tr></thead><tbody><tr><td>Context</td><td>接口</td><td>定义了 Context 接口的四个方法</td></tr><tr><td>emptyCtx</td><td>结构体</td><td>实现了 Context 接口，它其实是个空的 context</td></tr><tr><td>CancelFunc</td><td>函数</td><td>取消函数</td></tr><tr><td>canceler</td><td>接口</td><td>context 取消接口，定义了两个方法</td></tr><tr><td>cancelCtx</td><td>结构体</td><td>可以被取消</td></tr><tr><td>timerCtx</td><td>结构体</td><td>超时会被取消</td></tr><tr><td>valueCtx</td><td>结构体</td><td>可以存储 k-v 对</td></tr><tr><td>Background</td><td>函数</td><td>返回一个空的 context，常作为根 context</td></tr><tr><td>TODO</td><td>函数</td><td>返回一个空的 context，常用于重构时期，没有合适的 context 可用</td></tr><tr><td>WithCancel</td><td>函数</td><td>基于父 context，生成一个可以取消的 context</td></tr><tr><td>newCancelCtx</td><td>函数</td><td>创建一个可取消的 context</td></tr><tr><td>propagateCancel</td><td>函数</td><td>向下传递 context 节点间的取消关系</td></tr><tr><td>parentCancelCtx</td><td>函数</td><td>找到第一个可取消的父节点</td></tr><tr><td>removeChild</td><td>函数</td><td>去掉父节点的孩子节点</td></tr><tr><td>init</td><td>函数</td><td>包初始化</td></tr><tr><td>WithDeadline</td><td>函数</td><td>创建一个有 deadline 的 context</td></tr><tr><td>WithTimeout</td><td>函数</td><td>创建一个有 timeout 的 context</td></tr><tr><td>WithValue</td><td>函数</td><td>创建一个存储 k-v 对的 context</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;p&gt;context是Go的一个标准库，中文一般叫做”上下文”。context主要是用来在goroutine之间传递上下午信息，包括取消信号、超时时间等。context.Context类型的值可以协调多个goroutine中的代码执行“取消”操作，并且可以存储键值对。而且还是并发安全的。与它协作可以在API的外部控制执行“取消”操作，比如取消一个HTTP请求的执行。&lt;/p&gt;</summary>
    
    
    
    <category term="Golang" scheme="https://blog.eganx.cn/categories/Golang/"/>
    
    
    <category term="go" scheme="https://blog.eganx.cn/tags/go/"/>
    
    <category term="context" scheme="https://blog.eganx.cn/tags/context/"/>
    
  </entry>
  
  <entry>
    <title>Go Channel关闭方式</title>
    <link href="https://blog.eganx.cn/2022/11/02/Go_Channel_Close/"/>
    <id>https://blog.eganx.cn/2022/11/02/Go_Channel_Close/</id>
    <published>2022-11-02T15:56:54.000Z</published>
    <updated>2022-11-24T07:06:51.771Z</updated>
    
    <content type="html"><![CDATA[<p>channel的关闭是比较头疼的，搞不好就panic。直接panic-recover要被喷莽夫，不优雅。所以找了很多资料，总结一下channel的关闭过程，常见的关闭方式和优雅的关闭方式（<strong>没有人会比福杰一家还要优雅</strong>）</p><span id="more"></span><h2 id="0x0-关闭chan过程"><a href="#0x0-关闭chan过程" class="headerlink" title="0x0.关闭chan过程"></a>0x0.关闭chan过程</h2><p>关闭channel的执行函数是<code>closechan</code>，源码如下</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// go version: go1.18.2</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">closechan</span><span class="params">(c *hchan)</span></span> &#123;</span><br><span class="line"><span class="comment">// 关闭一个nil channel，直接panic。</span></span><br><span class="line">  <span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(plainError(<span class="string">&quot;close of nil channel&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 锁</span></span><br><span class="line">lock(&amp;c.lock)</span><br><span class="line">  <span class="comment">// channel已经关闭</span></span><br><span class="line"><span class="keyword">if</span> c.closed != <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// 解锁，然后panic</span></span><br><span class="line">    unlock(&amp;c.lock)</span><br><span class="line"><span class="built_in">panic</span>(plainError(<span class="string">&quot;close of closed channel&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">callerpc := getcallerpc()</span><br><span class="line">racewritepc(c.raceaddr(), callerpc, abi.FuncPCABIInternal(closechan))</span><br><span class="line">racerelease(c.raceaddr())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置chan已关闭</span></span><br><span class="line">c.closed = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> glist gList</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 释放channel里所有等待接收队列里的sudog</span></span><br><span class="line"><span class="comment">// release all readers</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">sg := c.recvq.dequeue()</span><br><span class="line"><span class="keyword">if</span> sg == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// elem不为空，还想要接收数据，给个相对应类型的零值。</span></span><br><span class="line"><span class="keyword">if</span> sg.elem != <span class="literal">nil</span> &#123;</span><br><span class="line">typedmemclr(c.elemtype, sg.elem)</span><br><span class="line">sg.elem = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> sg.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">sg.releasetime = cputicks()</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 取出goroutine</span></span><br><span class="line">gp := sg.g</span><br><span class="line">gp.param = unsafe.Pointer(sg)</span><br><span class="line">sg.success = <span class="literal">false</span></span><br><span class="line"><span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">raceacquireg(gp, c.raceaddr())</span><br><span class="line">&#125;</span><br><span class="line">glist.push(gp)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 释放channel里所有等待发送队列里的sudog，同时这些goroutine将会panic。</span></span><br><span class="line"><span class="comment">// release all writers (they will panic)</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">sg := c.sendq.dequeue()</span><br><span class="line"><span class="keyword">if</span> sg == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">sg.elem = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">if</span> sg.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">sg.releasetime = cputicks()</span><br><span class="line">&#125;</span><br><span class="line">gp := sg.g</span><br><span class="line">gp.param = unsafe.Pointer(sg)</span><br><span class="line">sg.success = <span class="literal">false</span></span><br><span class="line"><span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">raceacquireg(gp, c.raceaddr())</span><br><span class="line">&#125;</span><br><span class="line">glist.push(gp)</span><br><span class="line">&#125;</span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Ready all Gs now that we&#x27;ve dropped the channel lock.</span></span><br><span class="line">  <span class="comment">// 遍历glist，唤醒goroutine</span></span><br><span class="line"><span class="keyword">for</span> !glist.empty() &#123;</span><br><span class="line">gp := glist.pop()</span><br><span class="line">gp.schedlink = <span class="number">0</span></span><br><span class="line">goready(gp, <span class="number">3</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将<code>recvq</code>和<code>sendq</code>两个队列中的Goroutine加入到gList中，并清除掉所有sudog上未被处理掉元素。最后将glist中所有的goroutine加到调度队列，等待被唤醒。</p><blockquote><p><font color=red>发送者在被唤醒之后会panic。</font></p></blockquote><p>总结一下:</p><table><thead><tr><th align="center">操作</th><th align="center">closed channel</th></tr></thead><tbody><tr><td align="center">关闭(close)</td><td align="center">panic</td></tr><tr><td align="center">发送(c&lt;-)</td><td align="center">panic</td></tr><tr><td align="center">接收(&lt;-c)</td><td align="center">永远不阻塞</td></tr></tbody></table><h2 id="0x1-关闭channel的常见方式"><a href="#0x1-关闭channel的常见方式" class="headerlink" title="0x1.关闭channel的常见方式"></a>0x1.关闭channel的常见方式</h2><p>channel的关闭与否都有可能造成panic。如何获取channel是否关闭和如何稳妥的关闭channel是非常重要的事情‼️</p><ul><li>在不改变channel自身状态的情况下，无法获知一个channel是否关闭。</li><li>关闭一个closed channel会导致panic。所以在关闭channel的时候，关闭的一方在不清楚当前channel是否关闭的情况下去关闭channel是很危险的⚠️。</li><li>向一个closed channel发送数据会导致panic。同上，在发送方不知道channel是否关闭的情况下向channel发送数据，也是很危险的⚠️</li></ul><p>关闭channel原则：</p><blockquote><p>一般原则上使用channel是不允许接收方关闭channel和 <strong>不能关闭一个有多个并发发送者的channel</strong>。 换而言之， 你只能在发送方的 goroutine 中关闭只有该发送方的channel。</p></blockquote><h3 id="1-defer-recover粗暴关闭channel"><a href="#1-defer-recover粗暴关闭channel" class="headerlink" title="1).defer-recover粗暴关闭channel"></a>1).<strong>defer-recover粗暴关闭channel</strong></h3><p>使用defer-recover机制来确保程序不会因panic而崩溃，然后直接关闭chan。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SafeClose</span><span class="params">(ch <span class="keyword">chan</span> T)</span> <span class="params">(justClosed <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">recover</span>() != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// 返回值可以被修改</span></span><br><span class="line">            <span class="comment">// 在一个延时函数的调用中。</span></span><br><span class="line">            justClosed = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 假设这里 ch != nil 。</span></span><br><span class="line">    <span class="built_in">close</span>(ch)   <span class="comment">// 如果 ch 已经被关闭将会引发 panic</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span> <span class="comment">// &lt;=&gt; justClosed = true; return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的思想也可以用在发送方，确保向closed channel发送数据不会造成程序崩了。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SafeSend</span><span class="params">(ch <span class="keyword">chan</span> T, value T)</span> <span class="params">(closed <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">recover</span>() != <span class="literal">nil</span> &#123;</span><br><span class="line">            closed = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    ch &lt;- value  <span class="comment">// 如果 ch 已经被关闭将会引发 panic</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span> <span class="comment">// &lt;=&gt; closed = false; return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的方法虽然处理了panic，但是并没有避免panic的发生。</p><h3 id="2-使用sync-Once关闭channel"><a href="#2-使用sync-Once关闭channel" class="headerlink" title="2).使用sync.Once关闭channel"></a>2).<strong>使用sync.Once关闭channel</strong></h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> MyChannel <span class="keyword">struct</span> &#123;</span><br><span class="line">    C    <span class="keyword">chan</span> T</span><br><span class="line">    once sync.Once</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewMyChannel</span><span class="params">()</span> *<span class="title">MyChannel</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;MyChannel&#123;C: <span class="built_in">make</span>(<span class="keyword">chan</span> T)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mc *MyChannel)</span> <span class="title">SafeClose</span><span class="params">()</span></span> &#123;</span><br><span class="line">    mc.once.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">close</span>(mc.C)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-使用sync-Mutex避免多次关闭同一个channel"><a href="#3-使用sync-Mutex避免多次关闭同一个channel" class="headerlink" title="3).使用sync.Mutex避免多次关闭同一个channel"></a>3).<strong>使用sync.Mutex避免多次关闭同一个channel</strong></h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> MyChannel <span class="keyword">struct</span> &#123;</span><br><span class="line">    C      <span class="keyword">chan</span> T</span><br><span class="line">    closed <span class="keyword">bool</span></span><br><span class="line">    mutex  sync.Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewMyChannel</span><span class="params">()</span> *<span class="title">MyChannel</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;MyChannel&#123;C: <span class="built_in">make</span>(<span class="keyword">chan</span> T)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mc *MyChannel)</span> <span class="title">SafeClose</span><span class="params">()</span></span> &#123;</span><br><span class="line">    mc.mutex.Lock()</span><br><span class="line">    <span class="keyword">defer</span> mc.mutex.Unlock()</span><br><span class="line">    <span class="keyword">if</span> !mc.closed &#123;</span><br><span class="line">        <span class="built_in">close</span>(mc.C)</span><br><span class="line">        mc.closed = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mc *MyChannel)</span> <span class="title">IsClosed</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    mc.mutex.Lock()</span><br><span class="line">    <span class="keyword">defer</span> mc.mutex.Unlock()</span><br><span class="line">    <span class="keyword">return</span> mc.closed</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0x2-优雅的关闭channel"><a href="#0x2-优雅的关闭channel" class="headerlink" title="0x2.优雅的关闭channel"></a>0x2.优雅的关闭channel</h2><p>上面的几种关闭channel的方式，用的人应该不少(说实话，我也很喜欢使用<code>sync.Once</code>的方式去关闭channel)。但是，有许多人认为代码在考虑业务实现的同时，应该优雅优雅再优雅！（舍监表示很开心！阿尼亚表示很难受！）</p><p>那么如何优雅的关闭channel？按照发送者和接收者的数量可以分为以下四种：</p><blockquote><p><font color = ligblue>1. 一个 sender，一个 receiver</font><br><font color = ligblue>2. 一个 sender， N个 receiver</font><br><font color = ligblue>3. M个 sender， 一个 receiver</font><br><font color = ligblue>4. M个 sender， N个 receiver</font></p></blockquote><h3 id="1-只有一个发送者，关闭唯一的发送者"><a href="#1-只有一个发送者，关闭唯一的发送者" class="headerlink" title="1).只有一个发送者，关闭唯一的发送者"></a>1).只有一个发送者，关闭唯一的发送者</h3><p>第一种和第二种情况比较好处理，因为只有一个发送者，只需要关闭唯一的发送者就可以。<code>sync.WaitGroup</code> 会被用于完成例子。 它在实践中并不是必要的。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">    <span class="string">&quot;math/rand&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    rand.Seed(time.Now().UnixNano())</span><br><span class="line">    log.SetFlags(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> MaxRandomNumber = <span class="number">100000</span></span><br><span class="line">    <span class="keyword">const</span> NumReceivers = <span class="number">100</span></span><br><span class="line"></span><br><span class="line">    wgReceivers := sync.WaitGroup&#123;&#125;</span><br><span class="line">    wgReceivers.Add(NumReceivers)</span><br><span class="line"></span><br><span class="line">    dataCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送者</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> value := rand.Intn(MaxRandomNumber); value == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="comment">// 唯一的发送者可以安全地关闭通道。</span></span><br><span class="line">                <span class="built_in">close</span>(dataCh)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;            </span><br><span class="line">                dataCh &lt;- value</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收者</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; NumReceivers; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> wgReceivers.Done()</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 接收数据直到 dataCh 被关闭或者</span></span><br><span class="line">            <span class="comment">// dataCh 的数据缓存队列是空的。</span></span><br><span class="line">            <span class="keyword">for</span> value := <span class="keyword">range</span> dataCh &#123;</span><br><span class="line">                log.Println(value)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wgReceivers.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-多个发送者，一个接收者。"><a href="#2-多个发送者，一个接收者。" class="headerlink" title="2).多个发送者，一个接收者。"></a>2).多个发送者，一个接收者。</h3><p>接收者通过关闭一个channel，告诉发送者不要再发了。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">    <span class="string">&quot;math/rand&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    rand.Seed(time.Now().UnixNano())</span><br><span class="line">    log.SetFlags(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">const</span> MaxRandomNumber = <span class="number">100000</span></span><br><span class="line">    <span class="keyword">const</span> NumSenders = <span class="number">1000</span></span><br><span class="line"></span><br><span class="line">    wgReceivers := sync.WaitGroup&#123;&#125;</span><br><span class="line">    wgReceivers.Add(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    dataCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">100</span>)</span><br><span class="line">    stopCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">        <span class="comment">// stopCh 是一个信号通道。</span></span><br><span class="line">        <span class="comment">// 它的发送者是 dataCh 的接收者。</span></span><br><span class="line">        <span class="comment">// 它的接收者是 dataCh 的发送者。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送者</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; NumSenders; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">for</span> &#123;</span><br><span class="line">                <span class="keyword">select</span> &#123;</span><br><span class="line">                <span class="keyword">case</span> &lt;- stopCh:</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                <span class="keyword">case</span> dataCh &lt;- rand.Intn(MaxRandomNumber):</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收者</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> wgReceivers.Done()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> value := <span class="keyword">range</span> dataCh &#123;</span><br><span class="line">            <span class="keyword">if</span> value == MaxRandomNumber<span class="number">-1</span> &#123;</span><br><span class="line">                <span class="comment">// dataCh 通道的接收者也是 stopCh 通道的发送者。</span></span><br><span class="line">                <span class="comment">// 在这里关闭停止通道是安全的。.</span></span><br><span class="line">                <span class="built_in">close</span>(stopCh)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            log.Println(value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    wgReceivers.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-多个发送者，多个接收者。"><a href="#3-多个发送者，多个接收者。" class="headerlink" title="3).多个发送者，多个接收者。"></a>3).多个发送者，多个接收者。</h3><p>当发送者和接收者都是多个的时候，没办法通过任何一方去终止这场游戏。因此需要增加一个中间人的角色来处理。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">    <span class="string">&quot;math/rand&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    rand.Seed(time.Now().UnixNano())</span><br><span class="line">    log.SetFlags(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">const</span> MaxRandomNumber = <span class="number">100000</span></span><br><span class="line">    <span class="keyword">const</span> NumReceivers = <span class="number">100</span></span><br><span class="line">    <span class="keyword">const</span> NumSenders = <span class="number">1000</span></span><br><span class="line"></span><br><span class="line">    wgReceivers := sync.WaitGroup&#123;&#125;</span><br><span class="line">    wgReceivers.Add(NumReceivers)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    dataCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">100</span>)</span><br><span class="line">    stopCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">        <span class="comment">// stopCh 是一个信号通道。</span></span><br><span class="line">        <span class="comment">// 它的发送者是下面的主持人 goroutine。</span></span><br><span class="line">        <span class="comment">// 它的接收者是 dataCh的所有发送者和接收者。</span></span><br><span class="line">    toStop := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">1</span>)</span><br><span class="line">        <span class="comment">// toStop 通道通常用来通知主持人去关闭信号通道( stopCh )。</span></span><br><span class="line">        <span class="comment">// 它的发送者是 dataCh的任意发送者和接收者。</span></span><br><span class="line">        <span class="comment">// 它的接收者是下面的主持人 goroutine</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> stoppedBy <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主持人</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        stoppedBy = &lt;-toStop</span><br><span class="line">        <span class="built_in">close</span>(stopCh)</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送者</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; NumSenders; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(id <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">for</span> &#123;</span><br><span class="line">                value := rand.Intn(MaxRandomNumber)</span><br><span class="line">                <span class="keyword">if</span> value == <span class="number">0</span> &#123;</span><br><span class="line">                    <span class="comment">// 用于通知主持人关闭信号通道。</span></span><br><span class="line">                    <span class="keyword">select</span> &#123;</span><br><span class="line">                    <span class="keyword">case</span> toStop &lt;- <span class="string">&quot;sender#&quot;</span> + id:</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">select</span> &#123;</span><br><span class="line">                <span class="keyword">case</span> &lt;- stopCh:</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                <span class="keyword">case</span> dataCh &lt;- value:</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;(strconv.Itoa(i))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收者</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; NumReceivers; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(id <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> wgReceivers.Done()</span><br><span class="line">            <span class="keyword">for</span> &#123;</span><br><span class="line">                <span class="keyword">select</span> &#123;</span><br><span class="line">                <span class="keyword">case</span> &lt;- stopCh:</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                <span class="keyword">case</span> value := &lt;-dataCh:</span><br><span class="line">                    <span class="keyword">if</span> value == MaxRandomNumber<span class="number">-1</span> &#123;</span><br><span class="line">                        <span class="comment">// 同样用于通知主持人去关闭信号通道。</span></span><br><span class="line">                        <span class="keyword">select</span> &#123;</span><br><span class="line">                        <span class="keyword">case</span> toStop &lt;- <span class="string">&quot;receiver#&quot;</span> + id:</span><br><span class="line">                        <span class="keyword">default</span>:</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">return</span></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    log.Println(value)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;(strconv.Itoa(i))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    wgReceivers.Wait()</span><br><span class="line">    log.Println(<span class="string">&quot;stopped by&quot;</span>, stoppedBy)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时<code>toStop</code>通道的缓存大小是1。不使用非缓冲型channel是为了避免第一个关闭信号在主持人准备好从<code>toStop</code>接收数据之前发送，造成丢失。</p><p>也可以设置<code>toStop</code>通道的buf为发送者和接收者数量之和。toStop的容量足够的时候，就不用担心阻塞了。也就不需要借助select语句了。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">toStop := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, NumReceivers + NumSenders)</span><br><span class="line">...</span><br><span class="line">            value := rand.Intn(MaxRandomNumber)</span><br><span class="line">            <span class="keyword">if</span> value == <span class="number">0</span> &#123;</span><br><span class="line">                toStop &lt;- <span class="string">&quot;sender#&quot;</span> + id</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">...</span><br><span class="line">                <span class="keyword">if</span> value == MaxRandomNumber<span class="number">-1</span> &#123;</span><br><span class="line">                    toStop &lt;- <span class="string">&quot;receiver#&quot;</span> + id</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><font color = green>Q&amp;A: 关闭的channel还能读吗？</font></p><blockquote><p>可以。从一个带缓冲的chan里读取数据时，当channel被关闭，是可以读到有效值的。可以是comma-ok的方式读取chan数据，当ok值为false时，说明channel已经关闭且通道无数据，读出的数据开始无效。</p></blockquote><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">3</span>)</span><br><span class="line">ch &lt;- <span class="number">0</span></span><br><span class="line">ch &lt;- <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">close</span>(ch)</span><br><span class="line">x, ok := &lt;-ch</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;received: &quot;</span>, x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">y, ok := &lt;-ch</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;received: &quot;</span>, y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">z, ok := &lt;-ch</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;received false &quot;</span>, z)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果：<br>received:  0<br>received:  1<br>received false:  0</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;channel的关闭是比较头疼的，搞不好就panic。直接panic-recover要被喷莽夫，不优雅。所以找了很多资料，总结一下channel的关闭过程，常见的关闭方式和优雅的关闭方式（&lt;strong&gt;没有人会比福杰一家还要优雅&lt;/strong&gt;）&lt;/p&gt;</summary>
    
    
    
    <category term="Golang" scheme="https://blog.eganx.cn/categories/Golang/"/>
    
    
    <category term="go" scheme="https://blog.eganx.cn/tags/go/"/>
    
    <category term="channel" scheme="https://blog.eganx.cn/tags/channel/"/>
    
  </entry>
  
  <entry>
    <title>Go Channel数据结构和创建</title>
    <link href="https://blog.eganx.cn/2022/11/01/Go_Channel_DS/"/>
    <id>https://blog.eganx.cn/2022/11/01/Go_Channel_DS/</id>
    <published>2022-11-01T13:09:13.000Z</published>
    <updated>2022-11-24T06:59:34.802Z</updated>
    
    <content type="html"><![CDATA[<p>Go语言的并发是最好用的，而channel也算是Go语言并发机制的半壁江山了。</p><span id="more"></span><h2 id="0x0-CSP"><a href="#0x0-CSP" class="headerlink" title="0x0.CSP"></a>0x0.CSP</h2><p>CSP全称“Communicating Sequential Processes”，中文可以叫做通信顺序进程。go的并发是基于channel实现，依赖的就是CSP模型。CSP描述了并发系统中的互动模式，实际上Go只是用到了CSP理论中一部分，即理论中的Process/Channel，在Go中对应goroutine/channel。这两个并发原语之间没有从属关系， Process 可以订阅任意个 Channel，Channel 也并不关心是哪个 Process 在利用它进行通信；Process 围绕 Channel 进行读写，形成一套有序阻塞和可预测的并发模型。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">┌─────────────┐     ┌─────────────┐      ┌─────────────┐</span><br><span class="line">│             │     │             │      │             │</span><br><span class="line">│  Goroutine  ├────►│   Channel   ├─────►│  Goroutine  │</span><br><span class="line">│             │     │             │      │             │</span><br><span class="line">└─────────────┘     └─────────────┘      └─────────────┘</span><br></pre></td></tr></table></figure><p>Goroutine + channel支撑起了Go语言的并发机制。</p><h2 id="0x1-channel数据结构"><a href="#0x1-channel数据结构" class="headerlink" title="0x1.channel数据结构"></a>0x1.channel数据结构</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123;</span><br><span class="line">qcount   <span class="keyword">uint</span>           <span class="comment">// total data in the queue //循环队列元素个数</span></span><br><span class="line">dataqsiz <span class="keyword">uint</span>           <span class="comment">// size of the circular queue //循环队列大小</span></span><br><span class="line">buf      unsafe.Pointer <span class="comment">// points to an array of dataqsiz elements //循环队列指针</span></span><br><span class="line">elemsize <span class="keyword">uint16</span> <span class="comment">//chan元素大小</span></span><br><span class="line">closed   <span class="keyword">uint32</span> <span class="comment">//是否已经关闭</span></span><br><span class="line">elemtype *_type <span class="comment">// element type //chan元素类型</span></span><br><span class="line">sendx    <span class="keyword">uint</span>   <span class="comment">// send index //chan发送操作处理到的位置</span></span><br><span class="line">recvx    <span class="keyword">uint</span>   <span class="comment">// receive index //chan接收操作处理到的位置</span></span><br><span class="line">recvq    waitq  <span class="comment">// list of recv waiters //等待接收数据的goroutine列表</span></span><br><span class="line">sendq    waitq  <span class="comment">// list of send waiters //等待发送数据的goroutine列表</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// lock protects all fields in hchan, as well as several</span></span><br><span class="line"><span class="comment">// fields in sudogs blocked on this channel.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Do not change another G&#x27;s status while holding this lock</span></span><br><span class="line"><span class="comment">// (in particular, do not ready a G), as this can deadlock</span></span><br><span class="line"><span class="comment">// with stack shrinking.</span></span><br><span class="line">lock mutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>buf</code>字段只有在缓冲型的channel才有，指向底层的循环数组。</p><p><code>sendx</code>和<code>recvx</code>分别表示已发送和已接收的元素在循环数组中的索引。</p><p><code>sendq</code>和<code>recvq</code>分别表示等待接收和等待发送的goroutine队列。这些goroutine由于尝试读取channel或者向channel发送数据而被阻塞。</p><p><code>lock</code>用来保护hchan中所有的字段。保证每个channel的读写都是原子的。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sudog 双向列表，sudog实际上是对goroutine的一个封装。</span></span><br><span class="line"><span class="keyword">type</span> waitq <span class="keyword">struct</span> &#123;</span><br><span class="line">first *sudog</span><br><span class="line">last  *sudog</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> ┌─────┐</span><br><span class="line"> │hchan│</span><br><span class="line"> ├─────┴────────────┐</span><br><span class="line">5│   qcount uint    │</span><br><span class="line"> ├──────────────────┤</span><br><span class="line">8│  dataqsiz uint   │                 0   1   2   3   4   5   6   7</span><br><span class="line"> ├──────────────────┤               ┌───┬───┬───┬───┬───┬───┬───┬───┐</span><br><span class="line"> │buf unsafe.Pointer├──────────────►│ a │ b │ c │ d │ e │   │   │   │</span><br><span class="line"> ├──────────────────┤               └───┴───┴───┴───┴───┴───┴───┴───┘</span><br><span class="line"> │ elemsize uint16  │                 ▲                   ▲</span><br><span class="line"> ├──────────────────┤                 │                   │</span><br><span class="line"> │  closed uint32   │                 │                   │</span><br><span class="line"> ├──────────────────┤                 │                   │</span><br><span class="line"> │  elemtype *_type │                 │                   │</span><br><span class="line"> ├──────────────────┤                 │                   │</span><br><span class="line">0│    sendx uint    ├─────────────────┘                   │</span><br><span class="line"> ├──────────────────┤                                     │</span><br><span class="line">5│    recvx uint    ├─────────────────────────────────────┘</span><br><span class="line"> ├──────────────────┤</span><br><span class="line"> │    recvq waitq   ├─────────┬───────────────────────────────────────────┐</span><br><span class="line"> ├──────────────────┤         │                                           │</span><br><span class="line"> │    sendq waitq   ├─────┐   │   ┌───────┐     ┌───────┐     ┌───────┐   │</span><br><span class="line"> ├──────────────────┤     │   └──►│ sudog │◄───►│ sudog │◄───►│ sudog │◄──┘</span><br><span class="line"> │    lock mutex    │     │       └───────┘     └───────┘     └───────┘</span><br><span class="line"> └──────────────────┘     │</span><br><span class="line">                          │</span><br><span class="line">                          │       ┌───────┐     ┌───────┐     ┌───────┐</span><br><span class="line">                          │   ┌──►│ sudog │◄───►│ sudog │◄───►│ sudog │◄──┐</span><br><span class="line">                          │   │   └───────┘     └───────┘     └───────┘   │</span><br><span class="line">                          │   │                                           │</span><br><span class="line">                          └───┴───────────────────────────────────────────┘</span><br></pre></td></tr></table></figure><h2 id="0x2-创建channel"><a href="#0x2-创建channel" class="headerlink" title="0x2.创建channel"></a>0x2.创建channel</h2><p>创建<code>chan</code>一般使用<code>make</code>关键字。其中<code>chan</code>的类型分为有无缓冲两种模式。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>) <span class="comment">//无缓冲</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">2</span>) <span class="comment">//有缓冲</span></span><br></pre></td></tr></table></figure><p>翻翻源码，有些看不太明白，只能是能看多少看多少了😭。在runtime/chan.go中都是使用<code>makechan</code>来创建<code>chan</code>。中文是个人注释，英文是官方注释。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">maxAlign  = <span class="number">8</span></span><br><span class="line">hchanSize = unsafe.Sizeof(hchan&#123;&#125;) + <span class="keyword">uintptr</span>(-<span class="keyword">int</span>(unsafe.Sizeof(hchan&#123;&#125;))&amp;(maxAlign<span class="number">-1</span>)) <span class="comment">//hchan结构体大小</span></span><br><span class="line">debugChan = <span class="literal">false</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makechan64</span><span class="params">(t *chantype, size <span class="keyword">int64</span>)</span> *<span class="title">hchan</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">int64</span>(<span class="keyword">int</span>(size)) != size &#123;</span><br><span class="line"><span class="built_in">panic</span>(plainError(<span class="string">&quot;makechan: size out of range&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> makechan(t, <span class="keyword">int</span>(size))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makechan</span><span class="params">(t *chantype, size <span class="keyword">int</span>)</span> *<span class="title">hchan</span></span> &#123;</span><br><span class="line">elem := t.elem</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 检查channel size和align</span></span><br><span class="line"><span class="comment">// compiler checks this but be safe.</span></span><br><span class="line"><span class="keyword">if</span> elem.size &gt;= <span class="number">1</span>&lt;&lt;<span class="number">16</span> &#123;</span><br><span class="line">throw(<span class="string">&quot;makechan: invalid channel element type&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> hchanSize%maxAlign != <span class="number">0</span> || elem.align &gt; maxAlign &#123;</span><br><span class="line">throw(<span class="string">&quot;makechan: bad alignment&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 元素大小*个数，计算buf需要的内存大小</span></span><br><span class="line">mem, overflow := math.MulUintptr(elem.size, <span class="keyword">uintptr</span>(size))</span><br><span class="line"><span class="keyword">if</span> overflow || mem &gt; maxAlloc-hchanSize || size &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(plainError(<span class="string">&quot;makechan: size out of range&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Hchan does not contain pointers interesting for GC when elements stored in buf do not contain pointers.</span></span><br><span class="line"><span class="comment">// buf points into the same allocation, elemtype is persistent.</span></span><br><span class="line"><span class="comment">// SudoG&#x27;s are referenced from their owning thread so they can&#x27;t be collected.</span></span><br><span class="line"><span class="comment">// TODO(dvyukov,rlh): Rethink when collector can move allocated objects.</span></span><br><span class="line"><span class="keyword">var</span> c *hchan</span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line">  <span class="comment">// 表示元素大小为零或者缓冲区大小为0（无缓冲类型），不需要创建buf。只进行一次内存分配。分配内存的大小就是hchan结构体大小。</span></span><br><span class="line"><span class="keyword">case</span> mem == <span class="number">0</span>:</span><br><span class="line"><span class="comment">// Queue or element size is zero.</span></span><br><span class="line">c = (*hchan)(mallocgc(hchanSize, <span class="literal">nil</span>, <span class="literal">true</span>))</span><br><span class="line"><span class="comment">// Race detector uses this location for synchronization.</span></span><br><span class="line">c.buf = c.raceaddr()</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 元素类型不含指针，进行一次内存分配，分配一块连续的内存，大小是“hchan结构体大小+个数*元素大小”。</span></span><br><span class="line">  <span class="comment">// 同时元素大小不等于0且是缓冲区大小不为0</span></span><br><span class="line"><span class="keyword">case</span> elem.ptrdata == <span class="number">0</span>:</span><br><span class="line"><span class="comment">// Elements do not contain pointers.</span></span><br><span class="line"><span class="comment">// Allocate hchan and buf in one call.</span></span><br><span class="line">c = (*hchan)(mallocgc(hchanSize+mem, <span class="literal">nil</span>, <span class="literal">true</span>))</span><br><span class="line">c.buf = add(unsafe.Pointer(c), hchanSize)</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 元素包含指针，缓冲区大小不为0，进行两次内存分配，单独为hchan和buf分配内存。</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="comment">// Elements contain pointers.</span></span><br><span class="line">c = <span class="built_in">new</span>(hchan)</span><br><span class="line">c.buf = mallocgc(mem, elem, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">c.elemsize = <span class="keyword">uint16</span>(elem.size)</span><br><span class="line">c.elemtype = elem</span><br><span class="line">c.dataqsiz = <span class="keyword">uint</span>(size)</span><br><span class="line">lockInit(&amp;c.lock, lockRankHchan)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> debugChan &#123;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;makechan: chan=&quot;</span>, c, <span class="string">&quot;; elemsize=&quot;</span>, elem.size, <span class="string">&quot;; dataqsiz=&quot;</span>, size, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据channel中收发的元素类型和缓冲区的大小，初始化hchan时有以下三种情况：</p><ul><li>元素大小为零或者缓冲区大小为0（无缓冲类型），不需要创建buf。进行一次内存分配。分配内存的大小就是hchan结构体大小。</li><li>元素大小和缓冲区大小均不为0，且元素类型不含指针。进行一次内存分配，分配一块连续的内存，大小是“hchan结构体大小+个数*元素大小”。</li><li>元素包含指针，缓冲区大小不为0。进行两次内存分配，单独为hchan和buf分配内存。</li></ul><h2 id="0x3-channel的基本应用"><a href="#0x3-channel的基本应用" class="headerlink" title="0x3.channel的基本应用"></a>0x3.channel的基本应用</h2><h3 id="1-超时处理"><a href="#1-超时处理" class="headerlink" title="1).超时处理"></a>1).超时处理</h3><p><code>res := &lt;- c1</code> 等待结果，<code>&lt;-time.After</code> 等待超时（1秒钟）以后发送的值。 由于 <code>select</code> 默认处理第一个已准备好的接收操作， 因此如果操作耗时超过了允许的 1 秒的话，将会执行超时 <code>case</code>。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    c1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">        c1 &lt;- <span class="string">&quot;result 1&quot;</span></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> res := &lt;-c1:</span><br><span class="line">        fmt.Println(res)</span><br><span class="line">    <span class="keyword">case</span> &lt;-time.After(<span class="number">1</span> * time.Second):</span><br><span class="line">        fmt.Println(<span class="string">&quot;timeout 1&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    c2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">        c2 &lt;- <span class="string">&quot;result 2&quot;</span></span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> res := &lt;-c2:</span><br><span class="line">        fmt.Println(res)</span><br><span class="line">    <span class="keyword">case</span> &lt;-time.After(<span class="number">3</span> * time.Second):</span><br><span class="line">        fmt.Println(<span class="string">&quot;timeout 2&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">timeout 1</span><br><span class="line">result 2</span><br></pre></td></tr></table></figure></blockquote><h3 id="2-控制并发"><a href="#2-控制并发" class="headerlink" title="2).控制并发"></a>2).控制并发</h3><p>构建一个缓冲型的 channel，容量为 3。接着遍历任务列表，每个任务启动一个 goroutine 去完成。真正执行任务，访问第三方的动作在 w() 中完成，在执行 w() 之前，先要从 limit 中拿“许可证”，拿到许可证之后，才能执行 w()，并且在执行完任务，要将“许可证”归还。这样就可以控制同时运行的 goroutine 数。如果 w() 发生 panic，那“许可证”可能就还不回去了，因此需要使用 defer 来保证。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> limit = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">// ......</span></span><br><span class="line">    <span class="keyword">for</span> _, w := <span class="keyword">range</span> work &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            limit &lt;- <span class="number">1</span></span><br><span class="line">            w()</span><br><span class="line">            &lt;-limit</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-生产者消费者模型"><a href="#3-生产者消费者模型" class="headerlink" title="3).生产者消费者模型"></a>3).生产者消费者模型</h3><p>并发编程中最常见的例子就是生产者消费者模式，该模式主要通过平衡生产线程和消费线程的工作能力来提高程序的整体处理数据的速度。简单地说，就是生产者生产一些数据，然后放到成果队列中，同时消费者从成果队列中来取这些数据。这样就让生产消费变成了异步的两个过程。当成果队列中没有数据时，消费者就进入饥饿的等待中；而当成果队列中数据已满时，生产者则面临因产品挤压导致 CPU 被剥夺的下岗问题。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 生产者: 生成 factor 整数倍的序列</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Producer</span><span class="params">(factor <span class="keyword">int</span>, out <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; ; i++ &#123;</span><br><span class="line">        out &lt;- i*factor</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Consumer</span><span class="params">(in &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> v := <span class="keyword">range</span> in &#123;</span><br><span class="line">        fmt.Println(v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">64</span>) <span class="comment">// 成果队列</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> Producer(<span class="number">3</span>, ch) <span class="comment">// 生成 3 的倍数的序列</span></span><br><span class="line">    <span class="keyword">go</span> Producer(<span class="number">5</span>, ch) <span class="comment">// 生成 5 的倍数的序列</span></span><br><span class="line">    <span class="keyword">go</span> Consumer(ch)    <span class="comment">// 消费生成的队列</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Ctrl+C 退出</span></span><br><span class="line">    sig := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal, <span class="number">1</span>)</span><br><span class="line">    signal.Notify(sig, syscall.SIGINT, syscall.SIGTERM)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;quit (%v)\n&quot;</span>, &lt;-sig)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;Go语言的并发是最好用的，而channel也算是Go语言并发机制的半壁江山了。&lt;/p&gt;</summary>
    
    
    
    <category term="Golang" scheme="https://blog.eganx.cn/categories/Golang/"/>
    
    
    <category term="go" scheme="https://blog.eganx.cn/tags/go/"/>
    
    <category term="channel" scheme="https://blog.eganx.cn/tags/channel/"/>
    
  </entry>
  
  <entry>
    <title>Go Interface理解(2)</title>
    <link href="https://blog.eganx.cn/2022/10/30/Go_Interface_2/"/>
    <id>https://blog.eganx.cn/2022/10/30/Go_Interface_2/</id>
    <published>2022-10-30T13:45:56.000Z</published>
    <updated>2022-11-22T06:15:48.152Z</updated>
    
    <content type="html"><![CDATA[<p>接口有动态值和动态类型，只有当两者都是nil的时候，才有<code>接口值==nil</code>。这很重要‼️ 接口变量时常需要进行类型断言，找到真实类型。这也很重要‼️</p><span id="more"></span><h2 id="0x0-空接口-amp-nil"><a href="#0x0-空接口-amp-nil" class="headerlink" title="0x0.空接口&amp;nil"></a>0x0.空接口&amp;nil</h2><p>上来一个经典问题：一个包含nil指针的接口是不是nil接口？这个是真坑，在判空的时候，有可能就中招了。</p><p>空接口(<code>interface&#123;&#125;</code>)不包含任何的方法，但与此同时，所有的类型都实现了<code>interface&#123;&#125;</code>。在存储任意类型的时候，<code>interface&#123;&#125;</code>相当的有用。</p><p>nil 不是关键字，是一个预先声明的标识符，指针、通道、函数、接口、map、切片的零值就是nil，nil 是没有默认类型的，他的类型具有不确定性，我们在使用它时必须要提供足够的信息能够让编译器 推断nil期望的类型;</p><p>两个nil不能进行比较，因为nil是无类型的;</p><blockquote><ol><li>声明一个nil的map，map可以读数据，但是不能写数据</li><li>关闭一个nil的channel会引发panic</li><li>nil切片不能进行索引访问，会引发panic</li><li>方法接收者为nil时，如果在方法内使用到了会引发panic </li><li>空指针一个没有任何值的指针</li></ol></blockquote><p>接口的底层结构体有<code>iface、eface</code>两种不同的表示。前者是有方法的接口，后者是无任何方法的空接口：<code>interface&#123;&#125;</code>。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//src/runtime/runtime2.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> iface <span class="keyword">struct</span> &#123;</span><br><span class="line">tab  *itab</span><br><span class="line">data unsafe.Pointer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> eface <span class="keyword">struct</span> &#123;</span><br><span class="line">_type *_type</span><br><span class="line">data  unsafe.Pointer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> itab <span class="keyword">struct</span> &#123;</span><br><span class="line">inter *interfacetype</span><br><span class="line">_type *_type</span><br><span class="line">hash  <span class="keyword">uint32</span> <span class="comment">// copy of _type.hash. Used for type switches.</span></span><br><span class="line">_     [<span class="number">4</span>]<span class="keyword">byte</span></span><br><span class="line">fun   [<span class="number">1</span>]<span class="keyword">uintptr</span> <span class="comment">// variable sized. fun[0]==0 means _type does not implement inter.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>iface</code> 内部维护两个指针，<code>tab</code> 指向一个 <code>itab</code> 实体， 它表示接口的类型以及赋给这个接口的实体类型。<code>data</code> 则指向接口具体的值，一般而言是一个指向堆内存的指针。<code>tab</code>和<code>data</code>也分别被称为动态类型和动态值，接口值包括动态类型和动态值。只有当接口的动态类型和动态值都为nil的时候，才有<code>接口值==nil</code>。</p><h2 id="0x1-接口类型断言"><a href="#0x1-接口类型断言" class="headerlink" title="0x1.接口类型断言"></a>0x1.接口类型断言</h2><p>隐士类型转换在Go中是不允许的，这个时候类型就需要进行转换成另一个类型。有两种方式实现：<code>类型转换</code>，<code>类型断言</code>。两者的不同之处在于<font color=lgiblue>类型断言是针对接口变量。</font></p><h3 id="1-类型转换"><a href="#1-类型转换" class="headerlink" title="1).类型转换"></a>1).类型转换</h3><p><code>&lt;结果&gt; := &lt;目标类型&gt;(&lt;表达式&gt;)</code></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">f = <span class="number">10.101</span></span><br><span class="line">i := <span class="keyword">int</span>(f)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%T, %v\n&quot;</span>, i, i) <span class="comment">//output: int, 10</span></span><br></pre></td></tr></table></figure><p>类型转换前后的两个类型需要相互兼容才可以，不然编译器会报错。</p><h3 id="2-类型断言"><a href="#2-类型断言" class="headerlink" title="2).类型断言"></a>2).类型断言</h3><p>因为空接口 <code>interface&#123;&#125;</code> 没有定义任何函数，因此 Go 中所有类型都实现了空接口。当一个函数的形参是 <code>interface&#123;&#125;</code>，那么在函数中，需要对形参进行断言，从而得到它的真实类型。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;目标类型的值&gt; :&#x3D; &lt;表达式&gt;.( 目标类型 )　　&#x2F;&#x2F;非安全类型断言</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Duck <span class="keyword">struct</span> &#123;</span><br><span class="line">age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> d <span class="keyword">interface</span>&#123;&#125; = <span class="built_in">new</span>(Duck)</span><br><span class="line">s := d.(Duck)</span><br><span class="line">fmt.Println(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//run main.go</span></span><br><span class="line"><span class="comment">//panic: &quot;interface conversion: interface &#123;&#125; is *main.Duck, not main.Duck&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;目标类型的值&gt;，&lt;布尔参数&gt; :&#x3D; &lt;表达式&gt;.( 目标类型 ) &#x2F;&#x2F; comma-ok断言,安全类型断言 </span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Duck <span class="keyword">struct</span> &#123;</span><br><span class="line">age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> d <span class="keyword">interface</span>&#123;&#125; = <span class="built_in">new</span>(Duck)</span><br><span class="line">s, ok := d.(Duck)</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">fmt.Println(s)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;d type is %T&quot;</span>, d)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//run main.go</span></span><br><span class="line"><span class="comment">//d type is *main.Duck</span></span><br></pre></td></tr></table></figure><p>尽量使用comma-ok断言，即使断言失败也不会panic。</p><p>断言其实也可以使用 <code>switch</code> 语句判断接口的类型，每一个 <code>case</code> 会被顺序地考虑。当命中一个 <code>case</code> 时，就会执行 <code>case</code> 中的语句，因此 <code>case</code> 语句的顺序是很重要的，因为很有可能会有多个 <code>case</code> 匹配的情况。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> m := m.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="literal">nil</span>:</span><br><span class="line"><span class="keyword">case</span> Duck:</span><br><span class="line"><span class="keyword">case</span> *Duck:</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;接口有动态值和动态类型，只有当两者都是nil的时候，才有&lt;code&gt;接口值==nil&lt;/code&gt;。这很重要‼️ 接口变量时常需要进行类型断言，找到真实类型。这也很重要‼️&lt;/p&gt;</summary>
    
    
    
    <category term="Golang" scheme="https://blog.eganx.cn/categories/Golang/"/>
    
    
    <category term="go" scheme="https://blog.eganx.cn/tags/go/"/>
    
    <category term="interface" scheme="https://blog.eganx.cn/tags/interface/"/>
    
  </entry>
  
  <entry>
    <title>Go Interface理解(1)</title>
    <link href="https://blog.eganx.cn/2022/10/29/Go_Interface_1/"/>
    <id>https://blog.eganx.cn/2022/10/29/Go_Interface_1/</id>
    <published>2022-10-29T11:23:19.000Z</published>
    <updated>2022-11-22T06:10:18.113Z</updated>
    
    <content type="html"><![CDATA[<p>Go语言中，接口是不需要像传统的静态编程语言一样进行声明后才能使用。它引用了动态语言的接口使用方式，只需要实现接口要求的相关方法就行，同时还会在编译阶段进行类型匹配，个人觉得非常好用。</p><span id="more"></span><h2 id="0x0-Interface-amp-Duck-Typing"><a href="#0x0-Interface-amp-Duck-Typing" class="headerlink" title="0x0.Interface &amp; Duck Typing"></a>0x0.Interface &amp; Duck Typing</h2><p>所谓Go语言式的接口，就是不用显示声明类型<code>T</code>实现了接口<code>I</code>，只要类型<code>T</code>的公开方法完全满足接口<code>I</code>的要求，就可以把类型<code>T</code>的对象用在需要接口<code>I</code>的地方。这种做法的学名叫做<a href="http://en.wikipedia.org/wiki/Structural_type_system">Structural Typing</a>，也有人称它为一种静态的Duck Typing。</p><p>Duck Typing一般常见于动态语言中（比如python），但是动态语言不会在编译阶段去进行类型匹配，只有在运行到当前行代码的时候才会报错。而传统的静态语言（比如Java），必须显示地去声明实现了某个接口，然后才可以去使用。这跟动态语言静态语言的讨论类似，可以讨论优缺点，但是不能以好坏去下结论。</p><p>Go语言本身作为一种静态语言，静态语言的类型检查是肯定有的。但是在接口的使用上，引用了动态语言的接口使用方式。即不要求类型显示地去声明实现了某个接口，只需要实现接口要求的相关方法就行，编译阶段会去进行类型检查。如果没有实现相关方法，编译是会报错的。</p><p>举个🌰：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> IDuck <span class="keyword">interface</span> &#123;</span><br><span class="line">gaga()</span><br><span class="line">swimming()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Duck <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d Duck)</span> <span class="title">gaga</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Duck gaga&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Duck)</span> <span class="title">swimming</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Duck swimming&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> _ IDuck = (*Duck)(<span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color=red><code>var _ IDuck = (*Duck)(nil)  //这个很实用，编译器会由此检查 *Duck类型是否实现了 IDuck 接口。</code></font></p><p>以上的代码编译可以通过，表示A实现了Duck接口，那么A就是一只鸭子🦆。</p><p>但是当注释了A的游泳方法时，就会出现编译器会直接爆出以下错误，表示A并没有完全实现Duck接口，A不是一只鸭子🦆。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// func (d *Duck) swimming() &#123;</span></span><br><span class="line"><span class="comment">// fmt.Println(&quot;Duck swimming&quot;)</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> _ IDuck = (*Duck)(<span class="literal">nil</span>) <span class="comment">//编译报错：cannot use (*A)(nil) (value of type *A) as Duck value in variable declaration: *A does not implement Duck (missing method swimming) compiler(InvalidIfaceAssign)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0x1-方法"><a href="#0x1-方法" class="headerlink" title="0x1.方法"></a>0x1.方法</h2><p>接口方法方便接口添加新的行为。方法有接收者，当没有了接收者，方法就变成了函数。接收者有两种类型，一种是值接收者，另一种是指针接收者。</p><p>方法的调用者不必满足接收者类型。换句话说，无论方法的接收者是什么类型，该类型的值和指针都可以调用。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> _ IDuck = (*Duck)(<span class="literal">nil</span>) </span><br><span class="line">  </span><br><span class="line">  d := Duck&#123;&#125; <span class="comment">//d := &amp;Duck&#123;&#125; 也是可以的</span></span><br><span class="line">d.gaga() </span><br><span class="line">d.swimming()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当方法的接收者是值类型的时候，无论调用者是值类型还是指针类型，该方法操作的都是对应接收者的值的副本。即使你用指针类型去调用，方法内部操作还是对副本的操作，而不是指针操作。同理，当接收者是指针时，即使用值类型调用，方法内部也是对指针的操作，修改的是值指针指向的值本身。</p><h2 id="0x2-接口实现"><a href="#0x2-接口实现" class="headerlink" title="0x2.接口实现"></a>0x2.接口实现</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> IDuck <span class="keyword">interface</span> &#123;</span><br><span class="line">gaga()</span><br><span class="line">swimming()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Duck <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d Duck)</span> <span class="title">gaga</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;A gaga&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Duck)</span> <span class="title">swimming</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;A swimming&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">d := &amp;Duck&#123;&#125;</span><br><span class="line">dd := Duck&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _ IDuck = (*Duck)(d) <span class="comment">//OK</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _ IDuck = (Duck)(dd) <span class="comment">//编译报错：cannot use (Duck)(dd) (value of type Duck) as IDuck value in variable declaration: Duck does not implement IDuck (method swimming has pointer receiver)compilerInvalidIfaceAssign</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器不考虑我们的值是实现该接口的类型，接口的调用规则是建立在这些方法的接受者和接口如何被调用的基础上。下面的是语言规范里定义的规则，这些规则用来说明是否我们一个类型的值或者指针该接口：</p><ul><li>接收者是指针 <code>*T</code> 时，接口的实例必须是指针</li><li>接收者是值 <code>T</code> 时，接口的实例可以是指针也可以是值</li></ul><blockquote><p> 也就是说：实现了接收者是值类型的方法，相当于自动实现了接收者是指针类型的方法；而实现了接收者是指针类型的方法，不会自动生成对应接收者是值类型的方法。</p></blockquote><p><font color=green>Q&amp;A：既然实现接收者是值类型的方法时，会自动实现接收者是指针类型的方法，那么为啥要用指针类型去做接收者？什么时候会去使用指针作为方法的接收者？</font></p><blockquote><p>方法的接收者是值类型的时候，修改的永远是对象的副本，不会对调用者有影响。但是接收者是指针的时候，在方法里修改，就是修改了指针指向的对象本身。当类型是大型的结构体或者不能被安全的复制时，就定义指针接收者方法，例如文件结构体（struct File）。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;Go语言中，接口是不需要像传统的静态编程语言一样进行声明后才能使用。它引用了动态语言的接口使用方式，只需要实现接口要求的相关方法就行，同时还会在编译阶段进行类型匹配，个人觉得非常好用。&lt;/p&gt;</summary>
    
    
    
    <category term="Golang" scheme="https://blog.eganx.cn/categories/Golang/"/>
    
    
    <category term="go" scheme="https://blog.eganx.cn/tags/go/"/>
    
    <category term="interface" scheme="https://blog.eganx.cn/tags/interface/"/>
    
  </entry>
  
  <entry>
    <title>Go Map的遍历</title>
    <link href="https://blog.eganx.cn/2022/10/26/Go_Map_Range/"/>
    <id>https://blog.eganx.cn/2022/10/26/Go_Map_Range/</id>
    <published>2022-10-26T13:33:01.000Z</published>
    <updated>2022-11-20T04:33:57.713Z</updated>
    
    <content type="html"><![CDATA[<p>Map的遍历过程是便利所有的bucket(一般称之为桶)以及挂载的overflow bucket，然后逐一遍历bucket的所有cell，从有key的cell中取出key和value，遍历完成。实际在遍历的时候，有可能map处于扩容过程中,这时候map的状态就相当于是处于一个中间态，即有些bucket已经迁移，有些bucket还在原来的位置。也就是说遍历如果发生在扩容的过程中，就会涉及到遍历新老 bucket 的过程，就比较麻烦。</p><span id="more"></span><h2 id="0x0-Map遍历是无序的"><a href="#0x0-Map遍历是无序的" class="headerlink" title="0x0.Map遍历是无序的"></a>0x0.Map遍历是无序的</h2><p>在遍历map的时候，可以发现key是无序的。正常来说从一个固定Map的第一个bucket的第一个cell逐步遍历取出key的话，key应该是有序的。因为扩容会带来某些key的bucket或者cell发生变化，Go为了避免我们误认为遍历map会得到有序key，在遍历开始的时候，不是从0号bucket开始，而是会给一个随机数，从一个随机的bucket开始，更绝的是在开始bucket中的开始cell也是随机选择的。这样的话，<font color=red>就算是一个写死的map在遍历的时候依旧不会返回一个固定序列的key集合。</font></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// decide where to start</span></span><br><span class="line">r := <span class="keyword">uintptr</span>(fastrand())</span><br><span class="line"><span class="keyword">if</span> h.B &gt; <span class="number">31</span>-bucketCntBits &#123;</span><br><span class="line">r += <span class="keyword">uintptr</span>(fastrand()) &lt;&lt; <span class="number">31</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// start bucket</span></span><br><span class="line">it.startBucket = r &amp; bucketMask(h.B)</span><br><span class="line"><span class="comment">// start cell</span></span><br><span class="line">it.offset = <span class="keyword">uint8</span>(r &gt;&gt; h.B &amp; (bucketCnt - <span class="number">1</span>))</span><br></pre></td></tr></table></figure><h2 id="0x1-遍历过程"><a href="#0x1-遍历过程" class="headerlink" title="0x1.遍历过程"></a>0x1.遍历过程</h2><p>假如有一个起始<code>B=1</code>的map（有0号和1号两个bucket），现在触发扩容，B变成了2（有0-3号4个bucket）。假设现在老0号bucket已经迁移到新0号和新2号bucket中，老1号中的bucket尚未开始迁移。此时开始对map的遍历，假设<code>startBucket = 2,offset = 4</code>，遍历的起点就是2号bucket中第4个cell。bucket的遍历顺序就是：<code>2-&gt;3-&gt;0-&gt;1</code>。</p><ul><li><p>2号bucket对应的是老0号bucket，检查老0号bucket的迁移状态，发现完成已经完成迁移，从4号cell依次遍历2号bucket中所有cell。如果2号bucket返回的key是非空的，就会继续遍历2号bucket的overflow bucket。</p></li><li><p>完成2号bucket的遍历后，开始3号bucket的遍历，检查后发现3号bucket对应的老1号bucket并没有迁移，这个时候就会去遍历老1号bucket。但是并不会取出老1号bucket的全部key，只会取出hash值后两位为<code>11</code>的key，因为这些key最终会迁移进新3号bucket。</p></li><li><p>完成3号bucket的遍历，继续0号bucket的遍历，已迁移，取出新0号bucket中的key。</p></li><li><p>继续1号bucket的遍历，未迁移，遍历老1号bucket，取出hash值后两位为<code>01</code>的key。</p></li><li><p>再次到2号bucket的时候，表示所有bucket遍历完成，map的遍历也就结束了。</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Map的遍历过程是便利所有的bucket(一般称之为桶)以及挂载的overflow bucket，然后逐一遍历bucket的所有cell，从有key的cell中取出key和value，遍历完成。实际在遍历的时候，有可能map处于扩容过程中,这时候map的状态就相当于是处于一个中间态，即有些bucket已经迁移，有些bucket还在原来的位置。也就是说遍历如果发生在扩容的过程中，就会涉及到遍历新老 bucket 的过程，就比较麻烦。&lt;/p&gt;</summary>
    
    
    
    <category term="Golang" scheme="https://blog.eganx.cn/categories/Golang/"/>
    
    
    <category term="go" scheme="https://blog.eganx.cn/tags/go/"/>
    
    <category term="map" scheme="https://blog.eganx.cn/tags/map/"/>
    
  </entry>
  
</feed>
